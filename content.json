{"pages":[{"title":"about me","text":"####id: yuluo####location: Naning Jiangsu####Email: luoshatter#gmail.com####Github:https://github.com/yuluo-ding","link":"/about/index.html"}],"posts":[{"title":"Android-Context解释","text":"####Android中的Context解释 Android系统的上下文对象，即在Context中，Activity、Service、Application都是继承自Context。Android应用程序会在如下所示的几个时间点创建应用上下文Context 创建Application 创建Activity 创建Service 由上可知，创建Context的时机就是在创建Context的实现类的时候。应用程序第一次启动的时候，Android系统都会创建一个Application对象，同事创建Application Context，所有的组件都共同拥有这样一个Context对象，这个应用上下文对象贯穿整个应用进程的生命周期，为应用全局提供功能和环境支持。而创建Activity和Service组件时，系统也会给它们提供运行的上下文环境，即创建Activity实例、Service实例的Context对象。在Activity中获取Context对象时，可以直接使用this，而在匿名内部类中，就必须指定XXXXActivity.this才可以获得该Activity的Context对象。也可以通过getApplicationContext()方法来获取整个App的Context，但是通过getApplicationContext()方法获得是整个应用的上下文引用，这个与某个组件的上下文引用，在某些时候还是有区别的。","link":"/2016/01/06/Android-Context%E8%A7%A3%E9%87%8A/"},{"title":"Android Gson的使用","text":"Gson的使用Gson的使用","link":"/2016/01/19/Android-Gson%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"ADB的教程","text":"####ADB教程 什么是ADB adb的全称为Android Debug Bridge，就是起到调试桥的作用。通过adb我们可以在Eclipse中方便通过DDMS来调试Android程序，说白了就是debug工具。adb的工作方式比较特殊，采用监听Socket TCP 5554等端口的方式让IDE和Qemu通讯，默认情况下adb会daemon相关的网络端口，所以当我们运行Android Studio或者Eclipse时adb进程就会自动运行。 #####如何找到ADB可以在Android SDK 目录下&lt;Android SDK&gt;/platform-tools folders找到adb.exe或者下载ADB KitsADB Driver 在windows下调出CMD，WIN + R 123cd &lt;adb-path&gt; cd c:\\Users\\Linda\\AppData\\Local\\Android\\sdk\\platform-tools\\adb devices #####ADB的一些基本command可以在这个网站进行查看ADB Debugging 1234adb devicesadb forwardadb kill-server Wireless 123adb connectadb usb Package Manager 123456adb installadb uninstalladb shell pm list packagesadb shell pm pathadb shell pm clear File Manager 1234567891011adb pulladb pushadb shell lsadb shell cdadb shell rmadb shell mkdiradb shell touchadb shell pwdadb shell cpadb shell mv Network 12345adb shell netstatadb shell pingadb shell netcfgadb shell ip Logcat 1234adb logcatadb shell dumpsysadb shell dumpstate Screenshot 123adb shell screencapadb shell screenrecord [4.4+] System 1234567adb rootadb sideloadadb shell psadb shell topadb shell getpropadb shell setprop","link":"/2016/01/05/ADB%E7%9A%84%E6%95%99%E7%A8%8B/"},{"title":"Android Material Design中文版","text":"Material Design中文版Material Design中文版","link":"/2016/01/18/Android-Material-Design%E4%B8%AD%E6%96%87%E7%89%88/"},{"title":"Android O的感叹号或者叉 怎么去掉呢","text":"Andorid O上的感叹号看着确实烦人，只要运行以下命令就好。 1adb shell settings put global captive_portal_https_url https://www.google.cn/generate_204 7.0-7.1.0需要服务器支持https 或者使用命令 adb shell &quot;settings put global captive_portal_use_https 0&quot; 禁用https即可。 恢复可用 adb shell &quot;settings put global captive_portal_use_https 1&quot; 或者 adb shell &quot;settings delete global captive_portal_use_https&quot; 7.1.1 从7.1.1开始，检测用的服务器地址储存格式发生了变化，改为了： 123private static String getCaptivePortalServerHttpsUrl(Context context) { return getSetting(context, Settings.Global.CAPTIVE_PORTAL_HTTPS_URL, DEFAULT_HTTPS_URL);} 以及 123public static String getCaptivePortalServerHttpUrl(Context context) { return getSetting(context, Settings.Global.CAPTIVE_PORTAL_HTTP_URL, DEFAULT_HTTP_URL);} 可以看到，系统不会自动加入”generate_204″的后缀了，这意味着url可以设计的更加灵活，同时也意味着在设置的时候需要填入完整的url： adb shell ``&quot;settings put global captive_portal_https_url https://www.noisyfox.cn/generate_204&quot; 当然如果只有http的话，可以执行： adb shell &quot;settings put global captive_portal_use_https 0&quot; adb shell &quot;settings put global captive_portal_http_url http://www.noisyfox.cn/generate_204&quot; 7.1.2自7.1.2（开始？），”captive_portal_detection_enabled”设置已被废弃，现在改为了”captive_portal_mode”选项，该选项可设置为以下3种值： 0：彻底禁用检测(Don’t attempt to detect captive portals.) 1：检测到需要登录则弹窗提醒（默认值）(When detecting a captive portal, display a notification that prompts the user to sign in.) 2：检测到需要登录则自动断开此热点并不再自动连接(When detecting a captive portal, immediately disconnect from the network and do not reconnect to that network in the future.)","link":"/2017/10/18/Android-O%E7%9A%84%E6%84%9F%E5%8F%B9%E5%8F%B7%E6%88%96%E8%80%85%E5%8F%89-%E6%80%8E%E4%B9%88%E5%8E%BB%E6%8E%89%E5%91%A2/"},{"title":"Android Studio的Gradle的加速","text":"#####Android Studio和Gradle加速运行 Gradle的速度在win下真心惨不忍睹，除了加大内存和上SSD，也可以试试如下方法。1、修改 studio.xxx.vmoptions文件。路径在C:\\android-studio\\bin安装目录下的bin文件夹下。 如图，扩大启动和运行的内存。 2、让Gradle离线运行在Android Studio的setting中搜索Gradle，如图 Android Studio加速Android Studio是个一个很好的的Android开发平台，但是却比Eclipse更加吃配置，以下的几个方法可以提速 一次只打开一个工程 每次运行过模拟器之后，清理一下工程 使用真机代替模拟器 使用一次模拟器之后不要关闭，每次使用同一个模拟器来运行软件 在 File-&gt;Settings-&gt;Plugins and disable the following things这个路径，把以下插件禁止了 1.CVS Integration 2.Git Integration 3.GitHub 4.Google Cloud Tools for Android Studio 5.Subversion Integration","link":"/2015/10/08/Android-Studio%E7%9A%84Gradle%E7%9A%84%E5%8A%A0%E9%80%9F/"},{"title":"Android Studio的一些错误","text":"###1、cannot resolve symbol R android studio 1Click on Build-&gt;Clean Project and that will perform a gradle clean ###2、filed not resolve问题如下： 是因为设置了Gradle的offline模式，解开即可：","link":"/2015/06/14/Android-Studio%E7%9A%84%E4%B8%80%E4%BA%9B%E9%94%99%E8%AF%AF/"},{"title":"Android java.lang.OutOfMemoryError: GC overhead limit exceeded","text":"​ 再用 Android Studio 编辑项目的时候，会出现如下错误。 1java.lang.OutOfMemoryError: GC overhead limit exceeded ​ 根据 Sun 的描述： 1&quot;if too much time is being spent in garbage collection: if more than 98% of the total time is spent in garbage collection and less than 2% of the heap is recovered, an OutOfMemoryError will be thrown.&quot; ​ 首先更改 Android Studio 的运行内存，MacBook 在Content/bin/studio.vmoptions,修改如下 1234567891011## *DO NOT* modify this file directly. If there is a value that you would like to override,# please add it to your user specific configuration file.## See http://tools.android.com/tech-docs/configuration#-Xms256m-Xmx4096m-XX:MaxPermSize=1024m-XX:ReservedCodeCacheSize=768m-XX:+UseCompressedOops ​ 之后在项目的build.gradle中添加一个设置: 123exOptions { javaMaxHeapSize &quot;4g&quot;} ​ 接下来运行就能通过。","link":"/2017/02/13/Android-java-lang-OutOfMemoryError-GC-overhead-limit-exceeded/"},{"title":"Android hander错误及后续错误","text":"在用Android Studio的时候用原生的Handler的时候，要手动导入android.os.Handler，否则会报错。 把一个对象实例化的时候，在一个类里面的实例化的话，只能在这个类里面调用。","link":"/2015/05/12/Android-hander%E9%94%99%E8%AF%AF/"},{"title":"Android Studio 调试技巧","text":"Android Studio小技巧 Android Studio你不知道的调试技巧 12Error:Execution failed for task ':testcomment:transformClassesWithJarMergingForDebug'.&gt; com.android.build.api.transform.TransformException: java.util.zip.ZipException: duplicate entry: com/avos/avoscloud/ArchiveRequestTaskController$1.class 是libs和maven仓库重复","link":"/2016/01/10/Android-Studio-%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/"},{"title":"Android Studio插件","text":"Android Studio 实用插件推荐几款实用的Android Studio 插件 android-butterknife-zelezny Gsonformat Android Postfix Completion AndroidAccessors Lifecycle Sorter JsonOnlineViewer CodeGlance findBugs-IDEA ADB WIFI","link":"/2016/01/20/Android-Studio%E6%8F%92%E4%BB%B6/"},{"title":"Android toolbar","text":"####ToolBar Android在5.0之后引入了toolbar来替换actionbar，增加其灵活性。在Android Studio新建工程之后，添加设计类库compile 'com.android.support:design:23.0.1'和compile 'com.android.support:appcompat-v7:23.0.1'的依赖，可以直接通过Gradle来添加。1、添加主题文件在style文件下两种主题文件，分别对应5.0之前的版本和5.0之后的版本。style5.0之前的版本 123456789101112131415161718&lt;resources&gt; &lt;!-- Base application theme. --&gt; &lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.DarkActionBar&quot;&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt; &lt;/style&gt; &lt;style name=&quot;AppTheme.NoActionBar&quot;&gt; &lt;item name=&quot;windowActionBar&quot;&gt;false&lt;/item&gt; &lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt; &lt;/style&gt; &lt;style name=&quot;AppTheme.AppBarOverlay&quot; parent=&quot;ThemeOverlay.AppCompat.Dark.ActionBar&quot; /&gt; &lt;style name=&quot;AppTheme.PopupOverlay&quot; parent=&quot;ThemeOverlay.AppCompat.Light&quot; /&gt;&lt;/resources&gt; 5.0及以后的版本 12345678&lt;resources&gt; &lt;style name=&quot;AppTheme.NoActionBar&quot;&gt; &lt;item name=&quot;windowActionBar&quot;&gt;false&lt;/item&gt; &lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt; &lt;/style&gt; &lt;style name=&quot;AppTheme.AppBarOverlay&quot; parent=&quot;ThemeOverlay.AppCompat.Dark.ActionBar&quot; /&gt; &lt;style name=&quot;AppTheme.PopupOverlay&quot; parent=&quot;ThemeOverlay.AppCompat.Light&quot; /&gt;&lt;/resources&gt; 2、添加布局文件在layout的文件夹下面先添加一个content_main.xml代码如下 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot; android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot; android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot; android:paddingTop=&quot;@dimen/activity_vertical_margin&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot; tools:context=&quot;.MainActivity&quot; tools:showIn=&quot;@layout/activity_main&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Hello World!&quot; /&gt;&lt;/RelativeLayout&gt; 之后再添加一个activity_main.xml来承载toolbar、floatingAcitonButton和content-main 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:fitsSystemWindows=&quot;true&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:theme=&quot;@style/AppTheme.AppBarOverlay&quot;&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; android:background=&quot;?attr/colorPrimary&quot; app:popupTheme=&quot;@style/AppTheme.PopupOverlay&quot; /&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;include layout=&quot;@layout/content_main&quot; /&gt; &lt;android.support.design.widget.FloatingActionButton android:id=&quot;@+id/fab&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;bottom|end&quot; android:layout_margin=&quot;@dimen/fab_margin&quot; android:src=&quot;@android:drawable/ic_input_add&quot; /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 3、添加主Activity新建MainActivity.java文件 12345678910111213141516171819202122232425import android.os.Bundle;import android.support.design.widget.FloatingActionButton;import android.support.design.widget.Snackbar;import android.support.v7.app.AppCompatActivity;import android.support.v7.widget.Toolbar;import android.view.View;public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar); FloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab); fab.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { Snackbar.make(view, &quot;Replace with your own action&quot;, Snackbar.LENGTH_LONG).setAction(&quot;Action&quot;, null).show(); } }); }} 4、运行结果如下图&lt;% asset_img toolbar.jpg %&gt;","link":"/2015/09/26/Android-toolbar/"},{"title":"Android-使用Intent传递对象","text":"####使用Intent传递对象 Intent可以用来启动活动、发送广播、启动服务等，也可以在Intent中添加一个附加数据。在FirtActivity中添加如下代码: 1234Intent intent = new Intent(FirstActivity.this, SecondActivity.class);intent.putExtra(&quot;string_data&quot;, &quot;hello&quot;);intent.putExtra(&quot;int_data&quot;, 100);startActivity(intent); 这里调用了Intent的putExtra（）方法添加要传递的数据，之后再SecondActivity中就可以得到这些值 12getIntent.getStringExtra(&quot;string_data);getIntent.getStringExtra(&quot;int_data&quot;, 0); #####传递的类型是有限的，可以用两种来实现，Serializable和Parcelable1、Serializable是序列化的意思，表示将一个对象转换成可存储或可传输的状态。序列化后的对象可以在网络上进行传输，也可以存储到本地。之于序列化的方法也很简单，只需让一个类是实现Serializable这个接口就可以了.一个Person类，包含name和age两个字段，要将其序列化，可以这么写： 123456789101112131415161718192021public class Person implements Serializable { private String name; private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }} 接下来在FirstActivity中的写法很简单： 123456Person person = new Person();person.setName(&quot;Tom&quot;);person.setAge(20);Intent intent = new Intent(FirstActivity.this, SecondActivity.class);intent.putExtra(&quot;person_data&quot;, person);startActivity(intent); 创建一个Person的实例，然后就直接把它传入到putExtra()方法中。接下来获取这个对象也很简单： 1Person person = (Person)getIntent().getSerializable(&quot;person_data&quot;); 2、Parcelable方式，不同上面的方法，Parcelable实现原理是将一个完整的对象进行分解，而分解后的每一部分都是Intent所支持的数据类型，这样也就实现传递对象的功能了。修改Person中的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Person implements Parcelable { private String name; private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public int describeContents() { return 0; } @Override public void writeToParcel(Parcel dest, int flags) { dest.writeString(name); dest.writeInt(age); } public static final Parcelable.Creator&lt;Person&gt; CREATOR = new Parcelable.Creator&lt;Person&gt;(){ @Override public Person createFromParcel(Parcel source) { Person person = new Person(); person.name = source.readString(); person.age = source.readInt(); return person; } @Override public Person[] newArray(int size) { return new Person[size]; } };} 接下来在FirstActivity中我们仍然可以使用相同的代码来传递Person对象，在SecondActivity中获取对象的时候需要修改: 1Person person = (Person)getIntent().getParcelableExtra(&quot;person_data&quot;); 以上#####Serializable因为要把整个对象序列化，效率方面会比Parcelable方式低一点。","link":"/2015/08/27/Android-%E4%BD%BF%E7%94%A8Intent%E4%BC%A0%E9%80%92%E5%AF%B9%E8%B1%A1/"},{"title":"Android 从输入框获取信息","text":"在activity_main.xml中加入以下代码 123456789101112&lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/button&quot;/&gt;&lt;EditText android:id=&quot;@+id/edit_text&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:maxLines=&quot;2&quot; android:hint=&quot;Type something here&quot;/&gt; 接着在MainActivity.java中添加逻辑控制程序在onCreate之前定义Button和EditText，之后再在onCreate方法下添加代码 123456789101112131415161718192021222324private EditText editText;private Button button;@Overrideprotected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button = (Button)findViewById(R.id.button); editText = (EditText)findViewById(R.id.edit_text); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { switch (v.getId()){ case R.id.button: String inputText = editText.getText().toString(); Toast.makeText(MainActivity.this, inputText,Toast.LENGTH_SHORT).show(); break; default: break; } } });} 如果直接用EditText editText来定义会报错。","link":"/2015/04/28/Android-%E4%BB%8E%E8%BE%93%E5%85%A5%E6%A1%86%E8%8E%B7%E5%8F%96%E4%BF%A1%E6%81%AF/"},{"title":"Android 开发最佳实践","text":"Android 开发最佳实践这是Github上敢于Android开发的一些简要。 Android 开发最佳实践 摘要 使用 Gradle 和它推荐的工程结构 把密码和敏感数据放在gradle.properties 不要自己写 HTTP 客户端,使用Volley或OkHttp库 使用Jackson库解析JSON数据 避免使用Guava同时使用一些类库来避免65k method limit（一个Android程序中最多能执行65536个方法） 使用 Fragments来呈现UI视图 使用 Activities 只是为了管理 Fragments Layout 布局是 XMLs代码，组织好它们 在layoutout XMLs布局时，使用styles文件来避免使用重复的属性 使用多个style文件来避免单一的一个大style文件 保持你的colors.xml 简短DRY(不要重复自己)，只是定义调色板 总是使用dimens.xml DRY(不要重复自己)，定义通用常数 不要做一个深层次的ViewGroup 在使用WebViews时避免在客户端做处理，当心内存泄露 使用Robolectric单元测试，Robotium 做UI测试 使用Genymotion 作为你的模拟器 总是使用ProGuard 和 DexGuard混淆来项目 Android SDK将你的Android SDK放在你的home目录或其他应用程序无关的位置。 当安装有些包含SDK的IDE的时候，可能会将SDK放在IDE同一目录下，当你需要升级（或重新安装）IDE或更换的IDE时，会非常麻烦。 此外，若果你的IDE是在普通用户，不是在root下运行，还要避免吧SDK放到一下需要sudo权限的系统级别目录下。 构建系统你的默认编译环境应该是Gradle. Ant 有很多限制，也很冗余。使用Gradle，完成以下工作很方便： 构建APP不同版本的变种 制作简单类似脚本的任务 管理和下载依赖 自定义秘钥 更多 工程结构有两种流行的结构：老的Ant &amp; Eclipse ADT 工程结构，和新的Gradle &amp; Android Studio 工程结构， 你应该选择新的工程结构，如果你的工程还在使用老的结构，考虑放弃吧，将工程移植到新的结构。老的结构： 12345678910old-structure├─ assets├─ libs├─ res├─ src│ └─ com/futurice/project├─ AndroidManifest.xml├─ build.gradle├─ project.properties└─ proguard-rules.pro 新的结构 1234567891011121314151617new-structure├─ library-foobar├─ app│ ├─ libs│ ├─ src│ │ ├─ androidTest│ │ │ └─ java│ │ │ └─ com/futurice/project│ │ └─ main│ │ ├─ java│ │ │ └─ com/futurice/project│ │ ├─ res│ │ └─ AndroidManifest.xml│ ├─ build.gradle│ └─ proguard-rules.pro├─ build.gradle└─ settings.gradle 主要的区别在于，新的结构明确的分开了source sets (main,androidTest)，Gradle的一个理念。 你可以做到，例如，添加源组‘paid’和‘free’在src中，这将成为您的应用程序的付费和免费的两种模式的源代码。 你的项目引用第三方项目库时（例如，library-foobar），拥有一个顶级包名app从第三方库项目区分你的应用程序是非常有用的。 然后settings.gradle不断引用这些库项目，其中app/build.gradle可以引用。 Gradle 配置常用结构 参考Google’s guide on Gradle for Android小任务 除了(shell, Python, Perl, etc)这些脚本语言，你也可以使用Gradle 制作任务。 更多信息请参考Gradle’s documentation。*密码 ** 在做版本release时你app的 build.gradle你需要定义 signingConfigs.此时你应该避免以下内容：不要做这个*.这会出现在版本控制中。 12345678signingConfigs { release { storeFile file(&quot;myapp.keystore&quot;) storePassword &quot;password123&quot; keyAlias &quot;thekey&quot; keyPassword &quot;password789&quot; }} 而是，建立一个不加入版本控制系统的gradle.properties文件。 12KEYSTORE_PASSWORD=password123KEY_PASSWORD=password789 那个文件是gradle自动引入的，你可以在buld.gradle文件中使用，例如： 12345678910111213signingConfigs { release { try { storeFile file(&quot;myapp.keystore&quot;) storePassword KEYSTORE_PASSWORD keyAlias &quot;thekey&quot; keyPassword KEY_PASSWORD } catch (ex) { throw new InvalidUserDataException(&quot;You should define KEYSTORE_PASSWORD and KEY_PASSWORD in gradle.properties.&quot;) } }} 使用 Maven 依赖方案代替使用导入jar包方案 如果在你的项目中你明确使用率 jar文件，那么它们可能成为永久的版本，如2.1.1.下载jar包更新他们是很繁琐的， 这个问题Maven很好的解决了，这在Android Gradle构建中也是推荐的方法。你可 以指定版本的一个范围，如2.1.+,然后Maven会自动升级到制定的最新版本，例如： 123456789dependencies { compile 'com.netflix.rxjava:rxjava-core:0.19.+' compile 'com.netflix.rxjava:rxjava-android:0.19.+' compile 'com.fasterxml.jackson.core:jackson-databind:2.4.+' compile 'com.fasterxml.jackson.core:jackson-core:2.4.+' compile 'com.fasterxml.jackson.core:jackson-annotations:2.4.+' compile 'com.squareup.okhttp:okhttp:2.0.+' compile 'com.squareup.okhttp:okhttp-urlconnection:2.0.+'} IDEs and text editorsIDE集成开发环境和文本编辑器无论使用什么编辑器，一定要构建一个良好的工程结构 编辑器每个人都有自己的 选择，让你的编辑器根据工程结构和构建系统运作，那是你自己的责任。 当下首推Android Studio,因为他是由谷歌开发，最接近Gradle，默认使用最新的工程结构，已经到2.0preview5阶段，它就是为Android开发定制的。 你也可以使用Eclipse ADT ，但是你需要对它进行配置，因为它使用了旧的工程结构 和Ant作为构建系统。你甚至可以使用纯文版编辑器如Vim，Sublime Text，或者Emacs。如果那样的话，你需要使用Gardle和adb命令行。如果使用Eclipse集成Gradle 不适合你，你只是使用命令行构建工程，或迁移到Android Studio中来吧。 无论你使用何种开发工具，只要确保Gradle和新的项目结构保持官方的方式构建应用程序，避免你的编辑器配置文件加入到版本控制。例如，避免加入Ant build.xml文件。 特别如果你改变Ant的配置，不要忘记保持build.gradle是最新和起作用的。同时，善待其他开发者，不要强制改变他们的开发工具和偏好。 类库Jackson是一个将java对象转换成JSON与JSON转化java类的类库。Gson 是解决这个问题的流行方案，然而我们发现Jackson更高效,因为它支持替代的方法处理JSON:流、内存树模型,和传统JSON-POJO数据绑定。不过，请记住， Jsonkson库比起GSON更大，所以根据你的情况选择，你可能选择GSON来避免APP 65k个方法限制。 网络请求，缓存，图片执行请求后端服务器，有几种交互的解决方案，你应该考虑实现你自己的网络客户端。使用 Volley 或Retrofit。Volley 同时提供图片缓存类。若果你选择使用Retrofit,那么考虑使用Picasso 来加载图片和缓存，同时使用OkHttp作为高效的网络请求。Retrofit，Picasso和OkHttp都是有同一家公司开发（注： 是由Square 公司开发），所以它们能很好的在一起运行。OkHttp 同样可以和Volley在一起使用 Volley. RxJava 是函数式反应性的一个类库，换句话说，能处理异步的事件。 这是一个强大的和有前途的模式，同时也可能会造成混淆，因为它是如此的不同。 我们建议在使用这个库架构整个应用程序之前要谨慎考虑。 有一些项目是使用RxJava完成的，如果你需要帮助可以跟这些人取得联系： Timo Tuominen, Olli Salonen, Andre Medeiros, Mark Voit, Antti Lammi, Vera Izrailit, Juha Ristolainen. RxJava开发精要如若你之前有使用过Rx的经历，开始从API响应应用它。 另外，从简单的UI事件处理开始运用，如单击事件或在搜索栏输入事件。 若对你的Rx技术有信心，同时想要将它应用到你的整体架构中，那么请在复杂的部分写好Javadocs文档。 请记住其他不熟悉RxJava的开发人员，可能会非常难理解整个项目。 尽你的的全力帮助他们理解你的代码和Rx。 Retrolambda 是一个在Android和预JDK8平台上的使用Lambda表达式语法的Java类库。 它有助于保持你代码的紧凑性和可读性，特别当你使用如RxJava函数风格编程时。 使用它时先安装JDK8，在Android Studio工程结构对话框中把它设置成为SDK路径，同时设置JAVA8_HOME和JAVA7_HOME环境变量， 然后在工程根目录下配置 build.gradle： 123dependencies { classpath 'me.tatarka:gradle-retrolambda:2.4.+'} 同时在每个module 的build.gradle中添加 12345678910111213apply plugin: 'retrolambda'android { compileOptions { sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8}retrolambda { jdk System.getenv(&quot;JAVA8_HOME&quot;) oldJdk System.getenv(&quot;JAVA7_HOME&quot;) javaVersion JavaVersion.VERSION_1_7} Android Studio 提供Java8 lambdas表带是代码提示支持。如果你对lambdas不熟悉，只需参照以下开始学习吧： 任何只包含一个接口的方法都是”lambda friendly”同时代码可以被折叠成更紧凑的语法 如果对参数或类似有疑问，就写一个普通的匿名内部类，然后让Android Status为你生成一个lambda。 当心dex方法数限制，同时避免使用过多的类库 Android apps，当打包成一个dex文件时，有一个65535个应用方法强硬限制[1] [2] [3]。 当你突破65k限制之后你会看到一个致命错误。因此，使用一个正常范围的类库文件，同时使用dex-method-counts 工具来决定哪些类库可以再65k限制之下使用，特别的避免使用Guava类库，因为它包含超过13k个方法。 Activities and FragmentsFragments应该作为你实现UI界面默认选择。你可以重复使用Fragments用户接口来 组合成你的应用。我们强烈推荐使用Fragments而不是activity来呈现UI界面，理由如下： 提供多窗格布局解决方案 Fragments 的引入主要将手机应用延伸到平板电脑，所以在平板电脑上你可能有A、B两个窗格，但是在手机应用上A、B可能分别充满 整个屏幕。如果你的应用在最初就使用了fragments，那么以后将你的应用适配到其他不同尺寸屏幕就会非常简单。 屏幕间数据通信 从一个Activity发送复杂数据(例如Java对象)到另外一个Activity，Android的API并没有提供合适的方法。不过使用Fragment，你可以使用 一个activity实例作为这个activity子fragments的通信通道。即使这样比Activity与Activity间的通信好，你也想考虑使用Event Bus架构，使用如 Otto 或者 greenrobot EventBus作为更简洁的实现。 如果你希望避免添加另外一个类库，RxJava同样可以实现一个Event Bus。 Fragments 一般通用的不只有UI 你可以有一个没有界面的fragment作为Activity提供后台工作。 进一步你可以使用这个特性来创建一个fragment 包含改变其它fragment的逻辑 而不是把这个逻辑放在activity中。 甚至ActionBar 都可以使用内部fragment来管理 你可以选择使用一个没有UI界面的fragment来专门管理ActionBar,或者你可以选择使用在每个Fragment中 添加它自己的action 来作为父Activity的ActionBar.参考. 很不幸，我们不建议广泛的使用嵌套的fragments，因为 有时会引起matryoshka bugs。我们只有当它有意义(例如，在水平滑动的ViewPager在 像屏幕一样fragment中)或者他的确是一个明智的选择的时候才广泛的使用fragment。 在一个架构级别，你的APP应该有一个顶级的activity来包含绝大部分业务相关的fragment。你也可能还有一些辅助的activity ，这些辅助的activity与主activity 通信很简单限制在这两种方法 Intent.setData() 或 Intent.setAction()或类似的方法。 Java 包结构Android 应用程序在架构上大致是Java中的Model-View-Controller结构。 在Android 中 Fragment和Activity通常上是控制器类(http://www.informit.com/articles/article.aspx?p=2126865). 换句话说，他们是用户接口的部分，同样也是Views视图的部分。 正是因为如此，才很难严格的将fragments (或者 activities) 严格的划分成 控制器controlloers还是视图 views。 最还是将它们放在自己单独的 fragments 包中。只要你遵循之前提到的建议，Activities 则可以放在顶级目录下。 若果你规划有2到3个以上的activity，那么还是同样新建一个activities包吧。 然而，这种架构可以看做是另一种形式的MVC， 包含要被解析API响应的JSON数据，来填充的POJO的models包中。 和一个views包来包含你的自定义视图、通知、导航视图，widgets等等。 适配器Adapter是在数据和视图之间。然而他们通常需要通过getView()方法来导出一些视图， 所以你可以将adapters包放在views包里面。 一些控制器角色的类是应用程序级别的，同时是接近系统的。 这些类放在managers包下面。 一些繁杂的数据处理类，比如说”DateUtils”,放在utils包下面。 与后端交互负责网络处理类，放在network包下面。 总而言之，以最接近用户而不是最接近后端去安排他们。 1234567891011com.futurice.project├─ network├─ models├─ managers├─ utils├─ fragments└─ views ├─ adapters ├─ actionbar ├─ widgets └─ notifications 资源文件 Resources 命名 遵循前缀表明类型的习惯，形如type_foo_bar.xml。例如：fragment_contact_details.xml,view_primary_button.xml,activity_main.xml.组织布局文件 若果你不确定如何排版一个布局文件，遵循一下规则可能会有帮助。 每一个属性一行，缩进4个空格 android:id 总是作为第一个属性 android:layout_**** 属性在上边 style 属性在底部 关闭标签/&gt;单独起一行，有助于调整和添加新的属性 考虑使用Designtime attributes 设计时布局属性，Android Studio已经提供支持，而不是硬编码android:text (译者注：墙内也可以参考stormzhang的这篇博客链接。 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; &gt; &lt;TextView android:id=&quot;@+id/name&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentRight=&quot;true&quot; android:text=&quot;@string/name&quot; style=&quot;@style/FancyText&quot; /&gt; &lt;include layout=&quot;@layout/reusable_part&quot; /&gt;&lt;/LinearLayout&gt; 作为一个经验法则,android:layout_****属性应该在 layout XML 中定义,同时其它属性android:**** 应放在 styler XML中。此规则也有例外，不过大体工作 的很好。这个思想整体是保持layout属性(positioning, margin, sizing) 和content属性在布局文件中，同时将所有的外观细节属性（colors, padding, font）放 在style文件中。 例外有以下这些: android:id 明显应该在layout文件中 layout文件中android:orientation对于一个LinearLayout布局通常更有意义 android:text 由于是定义内容，应该放在layout文件中 有时候将android:layout_width 和 android:layout_height属性放到一个style中作为一个通用的风格中更有意义，但是默认情况下这些应该放到layout文件中。 使用styles 几乎每个项目都需要适当的使用style文件，因为对于一个视图来说有一个重复的外观是很常见的。 在应用中对于大多数文本内容，最起码你应该有一个通用的style文件，例如： 1234&lt;style name=&quot;ContentText&quot;&gt; &lt;item name=&quot;android:textSize&quot;&gt;@dimen/font_normal&lt;/item&gt; &lt;item name=&quot;android:textColor&quot;&gt;@color/basic_black&lt;/item&gt;&lt;/style&gt; 应用到TextView 中: 123456&lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/price&quot; style=&quot;@style/ContentText&quot; /&gt; 你或许需要为按钮控件做同样的事情，不要停止在那里。将一组相关的和重复android:****的属性放到一个通用的style中。 将一个大的style文件分割成多个文件 可以有多个style.xml文件，因为没影响，因此你可以有多个style文件styles.xml,style_home.xml,style_item_details.xml,styles_forms.xml。 不用于资源文件路径需要为系统构建起的有意义，在res/values目录下的文件可以任意命名。 ** colors.xml 是一个调色板** 在你的colors.xml文件中应该只是映射颜色的名称一个RGBA值，而没有其它的。不要使用它为不同的按钮来定义RGBA值。 不要这样做 123456789&lt;resources&gt; &lt;color name=&quot;button_foreground&quot;&gt;#FFFFFF&lt;/color&gt; &lt;color name=&quot;button_background&quot;&gt;#2A91BD&lt;/color&gt; &lt;color name=&quot;comment_background_inactive&quot;&gt;#5F5F5F&lt;/color&gt; &lt;color name=&quot;comment_background_active&quot;&gt;#939393&lt;/color&gt; &lt;color name=&quot;comment_foreground&quot;&gt;#FFFFFF&lt;/color&gt; &lt;color name=&quot;comment_foreground_important&quot;&gt;#FF9D2F&lt;/color&gt; ... &lt;color name=&quot;comment_shadow&quot;&gt;#323232&lt;/color&gt; 使用这种格式，你会非常容易的开始重复定义RGBA值，这使如果需要改变基本色变的很复杂。同时，这些定义是跟一些环境关联起来的，如button或者comment, 应该放到一个按钮风格中，而不是在color.xml文件中。相反，这样做: 12345678910111213141516&lt;resources&gt; &lt;!-- grayscale --&gt; &lt;color name=&quot;white&quot; &gt;#FFFFFF&lt;/color&gt; &lt;color name=&quot;gray_light&quot;&gt;#DBDBDB&lt;/color&gt; &lt;color name=&quot;gray&quot; &gt;#939393&lt;/color&gt; &lt;color name=&quot;gray_dark&quot; &gt;#5F5F5F&lt;/color&gt; &lt;color name=&quot;black&quot; &gt;#323232&lt;/color&gt; &lt;!-- basic colors --&gt; &lt;color name=&quot;green&quot;&gt;#27D34D&lt;/color&gt; &lt;color name=&quot;blue&quot;&gt;#2A91BD&lt;/color&gt; &lt;color name=&quot;orange&quot;&gt;#FF9D2F&lt;/color&gt; &lt;color name=&quot;red&quot;&gt;#FF432F&lt;/color&gt;&lt;/resources&gt; 向应用设计者那里要这个调色板，名称不需要跟”green”, “blue”, 等等相同。 “brand_primary”, “brand_secondary”, “brand_negative” 这样的名字也是完全可以接受的。 像这样规范的颜色很容易修改或重构，会使应用一共使用了多少种不同的颜色变得非常清晰。 通常一个具有审美价值的UI来说，减少使用颜色的种类是非常重要的。 像对待colors.xml一样对待dimens.xml文件 与定义颜色调色板一样，你同时也应该定义一个空隙间隔和字体大小的“调色板”。 一个好的例子，如下所示： 123456789101112131415161718192021&lt;resources&gt; &lt;!-- font sizes --&gt; &lt;dimen name=&quot;font_larger&quot;&gt;22sp&lt;/dimen&gt; &lt;dimen name=&quot;font_large&quot;&gt;18sp&lt;/dimen&gt; &lt;dimen name=&quot;font_normal&quot;&gt;15sp&lt;/dimen&gt; &lt;dimen name=&quot;font_small&quot;&gt;12sp&lt;/dimen&gt; &lt;!-- typical spacing between two views --&gt; &lt;dimen name=&quot;spacing_huge&quot;&gt;40dp&lt;/dimen&gt; &lt;dimen name=&quot;spacing_large&quot;&gt;24dp&lt;/dimen&gt; &lt;dimen name=&quot;spacing_normal&quot;&gt;14dp&lt;/dimen&gt; &lt;dimen name=&quot;spacing_small&quot;&gt;10dp&lt;/dimen&gt; &lt;dimen name=&quot;spacing_tiny&quot;&gt;4dp&lt;/dimen&gt; &lt;!-- typical sizes of views --&gt; &lt;dimen name=&quot;button_height_tall&quot;&gt;60dp&lt;/dimen&gt; &lt;dimen name=&quot;button_height_normal&quot;&gt;40dp&lt;/dimen&gt; &lt;dimen name=&quot;button_height_short&quot;&gt;32dp&lt;/dimen&gt;&lt;/resources&gt; 布局时在写 margins 和 paddings 时，你应该使用spacing_****尺寸格式来布局，而不是像对待String字符串一样直接写值。 这样写会非常有感觉，会使组织和改变风格或布局是非常容易。避免深层次的视图结构 有时候为了摆放一个视图，你可能尝试添加另一个LinearLayout。你可能使用这种方法解决： 123456789101112131415161718192021222324252627282930&lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; &gt; &lt;RelativeLayout ... &gt; &lt;LinearLayout ... &gt; &lt;LinearLayout ... &gt; &lt;LinearLayout ... &gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;/RelativeLayout&gt;&lt;/LinearLayout&gt; 即使你没有非常明确的在一个layout布局文件中这样使用，如果你在Java文件中从一个view inflate到其他views当中，也是可能会发生的。因此尽量保持你的视图tree：学习如何使用RelativeLayout, 如何 optimize 你的布局 和如何使用 标签. 测试框架Android SDK的测试框架还处于初级阶段，特别是关于UI测试方面。Android Gradle 目前实现了一个叫connectedAndroidTest的测试， 它使用一个JUnit 为Android提供的扩展插件 extension of JUnit with helpers for Android.可以跑你生成的JUnit测试，只当做单元测试时使用 Robolectric ，views 不用 它是一个最求提供”不连接设备的”为了加速开发的测试， 非常时候做 models 和 view models 的单元测试。 然而，使用Robolectric测试时不精确的，也不完全对UI测试。 当你对有关动画的UI元素、对话框等，测试时会有问题， 这主要是因为你是在 “在黑暗中工作”（在没有可控的界面情况下测试） *Robotium 使写UI测试非常简单。 * 对于UI测试你不需 Robotium 跑与设备连接的测试。 但它可能会对你有益，是因为它有许多来帮助类的获得和分析视图，控制屏幕。 测试用例看起来像这样简单： 12345solo.sendKey(Solo.MENU);solo.clickOnText(&quot;More&quot;); // searches for the first occurence of &quot;More&quot; and clicks on itsolo.clickOnText(&quot;Preferences&quot;);solo.clickOnText(&quot;Edit File Extensions&quot;);Assert.assertTrue(solo.searchText(&quot;rtf&quot;)); 模拟器如果你全职开发Android App,那么买一个Genymotion emulatorlicense吧。 Genymotion 模拟器运行更快的秒帧的速度，比起典型的AVD模拟器。他有演示你APP的工具，高质量的模拟网络连接，GPS位置，等等。它同时还有理想的连接测试。 你若涉及适配使用很多不同的设备，买一个Genymotion 版权是比你买很多真设备便宜多的。 注意：Genymotion模拟器没有装载所有的Google服务，如Google Play Store和Maps。你也可能需 要测试Samsung指定的API，若这样的话你还是需要购买一个真实的Samsung设备。 混淆配置ProGuard 是一个在Android项目中广泛使用的压缩和混淆打包的源码的工具。 你是否使用ProGuard取决你项目的配置，当你构建一个release版本的apk时，通常你应该配置gradle文件。 12345678910buildTypes { debug { minifyEnabled false } release { signingConfig signingConfigs.release minifyEnabled true proguardFiles 'proguard-rules.pro' }} 为了决定哪些代码应该被保留，哪些代码应该被混淆，你不得不指定一个或多个实体类在你的代码中。 这些实体应该是指定的类包含main方法，applets，midlets，activities，等等。 Android framework 使用一个默认的配置文件，可以在SDK_HOME/tools/proguard/proguard-android.txt 目录下找到。自定义的工程指定的 project-specific 混淆规则，如在my-project/app/proguard-rules.pro中定义， 会被添加到默认的配置中。 关于 ProGuard 一个普遍的问题，是看应用程序是否崩溃并报ClassNotFoundException 或者 NoSuchFieldException 或类似的异常， 即使编译是没有警告并运行成功。 这意味着以下两种可能： ProGuard 已经移除了类，枚举，方法，成员变量或注解，考虑是否是必要的。 ProGuard 混淆了类，枚举，成员变量的名称，但是这些名字又被拿原始名称使用了，比如通过Java的反射。 检查app/build/outputs/proguard/release/usage.txt文件看有问题的对象是否被移除了。 检查 app/build/outputs/proguard/release/mapping.txt 文件看有问题的对象是否被混淆了。 In order to prevent ProGuard from stripping away needed classes or class members, add a keep options to your proguard config: 以防 ProGuard 剥离 需要的类和类成员，添加一个 keep选项在你的 proguard 配置文件中：-keep class com.futurice.project.MyClass { *; } 防止 ProGuard 混淆 一些类和成员，添加 keepnames:-keepnames class com.futurice.project.MyClass { *; } 在构建项目之初，发布一个版本 来检查ProGuard规则是否正确的保持了重要的部分。 同时无论何时你添加了新的类库，做一个发布版本，同时apk在设备上跑起来测试一下。 不要等到你的app要发布 “1.0”版本了才做版本发布，那时候你可能会碰到好多意想不到的异常，需要一些时间去修复他们。 Tips每次发布新版本都要写 mapping.txt。每发布一个版本，如果用户遇到一个bug，同时提交了一个混淆过的堆栈跟踪。 通过保留mapping.txt文件，来确定你可以调试的问题。 DexGuard 若果你需要核心工具来优化，和专门混淆的发布代码，考虑使用DexGuard, 一个商业软件，ProGuard 也是有他们团队开发的。 它会很容易将Dex文件分割，来解决65K个方法限制问题。 致谢感谢Antti Lammi, Joni Karppinen, Peter Tackage, Timo Tuominen, Vera Izrailit, Vihtori Mäntylä, Mark Voit, Andre Medeiros, Paul Houghton 这些人和Futurice 开发者分享他们的Android开发经验。 LicenseFuturice Oy Creative Commons Attribution 4.0 International (CC BY 4.0) TranslationTranslated to Chinese by andyiac","link":"/2016/01/23/Android-%E5%BC%80%E5%8F%91%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"title":"Android-四大组件的简介","text":"Android四大组件 ####1、ActivityActivity是Android应用中负责与用户交互的组件，为其提供了可视化用户界面，如果Activity应用需要多个应用界面，那么这个Activity应用将会包含多个Activity，多个Activity组成Activity栈，当前活动的Activity位于栈顶。 ####2、ServiceService与Activity的地位是并列的，它也代表一个单独的Android组件。Service与Activity的区别在于：Service通常位于后台运行，它一般不需要与用户交互，因此Servcie组件没有图形用户界面。与Activity组件需要继承Acitivity基类相似，Service组件需要继承Service基类。拥有自己的生命周期，通常为其他组件提供后台服务或监控其他组件的运行状态。 ####3、BroadcastReceiverBroadcastReceivr代表广播消息接收器，从代码实现角度来看，BroadcastReceiver非常类似于事件编程中的监听器。与普通事件监听器的事件源氏程序中的对象；而BroadcastReceiver监听的事件源是Android应用中的其他组件。 ####4、ContentProviderAndroid系统为跨应用的数据交换提供了一个标准：ContentProvider。通常与ContentProvider结合使用的ContentResolver,一个应用程序使用ContentProvider暴露自己的数据，另一个应用程序则通过ContentResolver来访问数据。","link":"/2015/09/03/Android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E7%AE%80%E4%BB%8B/"},{"title":"Android6.0 新特性详解","text":"Android6.0 新特性详解Android6.0 新特性详解","link":"/2016/01/17/Android6-0-%E6%96%B0%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/"},{"title":"Android 提示信息的乱码问题","text":"在使用Android Studio中，错误信息的提示有时会出现乱码。这主要是因为Projiect Encoding的编码默认是UTF-16，只要将其改为UTF-8即可。 1.中文乱码显示解决：Settings -&gt; Editor -&gt; Appearance -&gt; 选择Theme -&gt; 然后勾选上下面的Override default fonts by:在Name中选择一个支持中文字体的字体：比如微软雅黑，serif, sansSerif等，并设定Size，一般为15就可以了，自己可以调，这个设置主要是IDE的菜单标题栏字体和样式等，然后保存即可。2.让编辑窗口支持Ctr+鼠标左键缩放修改字体大小Settings -&gt; Editor -&gt; Mouse选项栏中勾选“Change font size(Zoom) with Ctrl+Mouse Wheel”3.修改主题和字体 大小Settings -&gt; Editor -&gt; Colors &amp; Fonts -&gt; Font -&gt; 在“Scheme name”选择一个主题样式并另存为：xx,xx自己起名，font size自己可以设置如15,17等，下面的左栏是可选字体列表，右侧为当前系统编辑器的字体，选择一个字体，并修改字体大小，保存即可。4.Android Studio设置主题 和 不支持中文File –&gt; Settings –&gt; Appearance， 然后右边的 Override default fonts by 打上勾，然后选择一种支持中文的字体，如GB213即可","link":"/2015/04/25/Android-%E6%8F%90%E7%A4%BA%E4%BF%A1%E6%81%AF%E7%9A%84%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"},{"title":"Android各国分发渠道","text":"绝大多数国家，主要市场是Google Play，部分国家有一些第三方市场。通用的商店：Aptoide、Mobango、Mobogenie 美洲美国： Google Play （主要）​ Amazon Appstore ​ GetJar​ AppBrain​ SlideME (slide Me会在超过两千万的不同的OEM APP STORE上预安装) 巴西： 1.Mobo Robo market MoboRobo - The Android Smartphone PC Manager. Free for Life!​ 2.F-Droid F-Droid | Free and Open Source Android App Repository 墨西哥 Google Play阿根廷 Google Play哥伦比亚 Google Play加拿大 Google Play 亚洲印度 Google Play泰国 Google Play越南 越南大部分Market并不提供自己的下载，而是直接指向Google Play链接 印尼： 1. Jalan Tikus​ 2. Gudang Aplikasi​ 3.TemanDev​ 4. WePlay 韩国：SK T-Store,​ Naver NStore,​ APPZIL,olleh Market​ Sumsang Apps会在超过1亿的Galaxy智能机上预安装 欧洲俄罗斯： 1.Yandex: Yandex.Store​ 2. Androidpit: Новости, игры и приложения для Android​ 3. Все для Андроид. Cкачать лучшие приложения для Андроид 意大利： 1.Androidpit Tutte le applicazioni per Android AndroidPIT2.Vshare vShare Android Market: Free download Android Apps &amp; Best Android Apk games for Android tablet and mobilephones3.appbrain AppBrain App Market (Android)4.softonic . http://best-apps-market.softonic.it/android 英国 Google Play 德国： 1.avira app store Avira AppStore2.9 apps Free Android Apps Download3.Apk4fun APK4Fun - Download APK for Fun Android Apps &amp; Games4.Androidpit Alle Android-Apps &amp; Android-Spiele aus dem Google Play Store AndroidPIT5. goodereader Android App Store &amp; Blackberry App Store 芬兰 Google Play 法国： 1. 1 mobile market 1Mobile Market2.androidpit Tout sur Android: Nouveautés, applications, tests, astuces, forum &amp; communauté 波兰 Google Play土耳其 Google Play西班牙 Google Play","link":"/2018/11/05/Android%E5%90%84%E5%9B%BD%E5%88%86%E5%8F%91%E6%B8%A0%E9%81%93/"},{"title":"Android关于TextView 点击的问题","text":"在xml文件中定义一个android:onClick=&quot;NextQuestion&quot;之后在方法类中点击Textview进行操作没反应，需要在onCreate中定义onClick方法才可以。","link":"/2015/05/13/Android%E5%85%B3%E4%BA%8ETextView-%E7%82%B9%E5%87%BB%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"CentOS 7.3 升级Python 2.7.13","text":"Centos7自动的 python 版本为2.7.5，要升级到2.7.x 的最新版。 安装依赖：1yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel gcc openssl-devel 下载并正确配置123#官网下载python源代码wget https://www.python.org/ftp/python/2.7.13/Python-2.7.13.tgztar -zxvf Python-2.7.13.tgz 编译并安装12345cd Python-2.7.13/#请注意一定要加 `--enable-shared --prefix=/usr/local CFLAGS=-fPIC LDFLAGS=&quot;-Wl,-rpath /usr/local/lib&quot; --enable-unicode=ucs4`./configure --enable-shared --prefix=/usr/local CFLAGS=-fPIC LDFLAGS=&quot;-Wl,-rpath /usr/local/lib&quot; --enable-unicode=ucs4make -j24sudo make install 替换旧版本请注意千万不要覆盖原有的系统自带的python，否则会导致yum不再可用，无法修复 1234mv /usr/bin/python /usr/bin/python2.7.5ln -sf /usr/local/bin/python /usr/bin/python#验证版本python -V 修改配置文件，解决yum、firewall-cmd等报错问题123vi /usr/bin/yum#修改第一句，替换成保留的2.7.5的版本：!/usr/bin/python2.7.5 修改/usr/libexec/urlgrabber-ext-down下的第一句： 1!/usr/bin/python2.7.5 修改/usr/bin/firewall-cmd下的第一句： 1#!/usr/bin/python2.7.5 -Es 修改/sbin/authconfig下的第一句： 1#!/usr/bin/python2.7.5 安装setuptools12wget https://bootstrap.pypa.io/ez_setup.pypython ez_setup.py 安装最新版本的pip123456wget https://bootstrap.pypa.io/get-pip.pypython get-pip.py ln -s /usr/local/bin/pip /usr/bin/pipln -s /usr/local/bin/pip /usr/bin/pip2pip -V","link":"/2017/08/27/CentOS-7-3-%E5%8D%87%E7%BA%A7Python-2-7-13/"},{"title":"Android知识清单","text":"##Android 岗知识点清单 如何自学Android编程？ ###Java 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？ 2.JDK和JRE的区别是什么？ “static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？ Java支持的数据类型有哪些？什么是自动拆装箱？ Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？ Java支持多继承么？如果不支持，如何实现 什么是值传递和引用传递？ 进程和线程的区别是什么？ 创建线程有几种不同的方式？哪种更好？为什么? 概括的解释下线程的几种可用状态 HashMap和Hashtable有什么区别？ java中的HashMap的工作原理是什么？ java中的四种引用 JVM内存分区，每个区的作用是什么? java垃圾收集机制？收集方法? Java接口与抽象类的区别，能否在接口中声明final方法、为什么 java类加载过程？解释双亲委派模型 java内存模型 什么是反射，反射机制 java泛型、泛型与类型擦除 java中的四大特性 volatile 变量和 atomic 变量有什么不同？ ThrealLocal是什么，原理 Thread 类中的 start () 和 run () 方法有什么区别？ java JNI相关 线程同步的方法有哪些 java socket编程 Callable和Runnable的区别 ConcurrentHashMap原理 线程池的概念、好处、常见的线程池举例 原子性与可见性 如何判断一个对象是否存活 java IO，NIO 《java编程思想》###Android 安卓中的四大组件 android中的五种布局，原理 android中的动画有哪几种，区别 android种有哪几种解析xml的方式，原理，区别 android中解析json方法，原理，区别 为什么现在以json数据格式居多 listview优化方法 数据存储方式 四种启动模式 activity,fragment生命周期 广播机制，注册方式有哪些，顺序广播和无序广播 Message+Handler+Looper MVC，MVP android中应用 区别 什么是ANR 什么情况下会出现ANR，如何避免 什么情况下会导致，Force Close 如何避免 描述android系统架构 android中webview AIDL是什么 如何工作 dvm虚拟机 IPC进程间通信 NDK开发 内存泄露与优化 电量优化 AsyncTask AsyncTask相对于java自带的线程池的好处 android 事件分发机制 什么是OOM，如何避免 android中如何传递数据，有哪几种方式 谷歌官方最好，最全，也最权威###数据结构与算法 九个排序算法，时间复杂度，什么情况下用哪种排序。 链表 栈 队列 二叉树，遍历方式的实现，递归与非递归版 图：BFS，DFS，最短路径等 字符串匹配，kmp算法 二分查找，hash表 理解数据结构原理后，多做题，剑指offer，程序员面试宝典等###计算机网络 tcp三次握手，四次挥手（常问） tcp可靠原理，流量控制，拥塞控制 tcp，udp原理 OSI分层与TCP/P分层,每层作用 解释ARP,ICMP DNS域名解析 交换机，网关，路由器概念，作用 TCP连接管理，优化 Http请求头，请求报文，相应报文，状态码及含义 IP地址的分类，无分类CIDR，划分子网，ip数据报格式，ip网络地址及广播地址的计算（笔试常考） 说一下在浏览器输入www.xxx.com背后的原理(dns,http,tcp相关知识) URI与URL web缓存，代理，https等（了解） Http怎么处理长连接，http有无状态，如何保持状态 Cookie和Session(知道最好) 参考书籍《计算机网络》、《HTTP权威指南》###操作系统 死锁的必要条件，怎么处理死锁。 进程的几种状态 IPC几种通信方式。 什么是虚拟内存。 虚拟地址、逻辑地址、线性地址、物理地址的区别 内存管理方式 进程调度的一些算法策略 了解linux吗，linux常用命令，内核原理 《深入理解操作系统》","link":"/2015/12/28/Android%E7%9F%A5%E8%AF%86%E6%B8%85%E5%8D%95/"},{"title":"CentOS 7下安装Python3.7","text":"CentOS 7只有默认的Python2，并没有Python3，为了不影响使用，做个安装记录。 编译安装Python 3 相关的包1sudo yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make libffi-devel 这里面有一个包很关键libffi-devel，因为只有3.7才会用到这个包，如果不安装这个包的话，在 make 阶段会出现如下的报错： ModuleNotFoundError: No module named ‘_ctypes’ 下载安装CentOS 默认没有wget，需要下载安装下，并且添加一个扩展源： 123yum -y install wget#运行这个命令添加epel扩展源 yum -y install epel-release 下载，解压，安装： 123456mkdir py &amp;&amp; cd pywget https://www.python.org/ftp/python/3.7.1/Python-3.7.1.tgztar -zxvf Python-3.7.1.tgz cd Python-3.7.1./configure -prefix=/usr/local/python3make &amp;&amp; make install 添加软链接1234567#添加python3的软链接 ln -s /usr/local/python3/bin/python3.7 /usr/bin/python3#添加 pip3 的软链接 ln -s /usr/local/python3/bin/pip3.7 /usr/bin/pip3#测试是否安装成功了 python3 -V# Python 3.7.1","link":"/2019/07/03/CentOS-7%E4%B8%8B%E5%AE%89%E8%A3%85Python3-7/"},{"title":"CentOS 7 安装最新的 Git","text":"yum 源仓库里的 Git 版本更新不及时，最新版本的 Git 是 1.8.3.1，但是官方最新版本已经到了 2.9.2。想要安装最新版本的的 Git，只能下载源码进行安装。 查看 yum 源仓库的 Git 信息： 1# yum info git ​可以看出，截至目前，yum 源仓库中最新的 Git 版本才 1.8.3.1，而查看最新的 Git 发布版本，已经 2.14.1 了。 依赖库安装 12# yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel# yum install gcc perl-ExtUtils-MakeMaker 卸载低版本Git,下载行的源码包，并解压 123# yum remove git# wget https://github.com/git/git/archive/v2.14.1.tar.gz# tar -zxvf v2.14.1.tar.gz 编译安装 12# make prefix=/usr/local/git all# make prefix=/usr/local/git install 添加到环境变量 12# echo &quot;export PATH=$PATH:/usr/local/git/bin&quot; &gt;&gt; /etc/bashrc# source /etc/bashrc # 实时生效 ​ 以上 CentOS 7.3就完成了更新 Git。​","link":"/2017/08/29/CentOS-7-%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%9A%84-Git/"},{"title":"Chrome插件开发入门教程","text":"####Chrome插件开发，只要你敢露我就敢抓 Chrome插件开发，只要你敢露我就敢抓全文简单介绍了Chrome插件开发的简单教程，需要js基础。","link":"/2015/12/30/Chrome%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"title":"Debian 10 升级到Debian 11","text":"Debian 11 (bullseye) 终于正式发布稳定版本了，带来了更多的特性和新的内核。 那么如何从Debian 10升级到Debian 11呢？ 更新软件包 1apt update &amp;&amp; apt upgrade -y 更新sources.list 1vi /etc/apt/sources.list 把该文件的源改成如下 12345678deb http://deb.debian.org/debian bullseye maindeb-src http://deb.debian.org/debian bullseye maindeb http://deb.debian.org/debian-security/ bullseye-security maindeb-src http://deb.debian.org/debian-security/ bullseye-security maindeb http://deb.debian.org/debian bullseye-updates maindeb-src http://deb.debian.org/debian bullseye-updates main 升级到11 1apt update &amp;&amp; apt full-upgrade 之后就是等待安装，建议保留中途提醒的网络配置。 清理旧的软件包 如果不需要旧的软件包了，可以用一下命令清理 12apt --purge autoremoveapt autoclean","link":"/2021/08/26/Debian-10-%E5%8D%87%E7%BA%A7%E5%88%B0Debian-11/"},{"title":"CentOS 7 ping baidu.com 报错name or service not know","text":"在用 VirtualBox 安装了CentOS 7 的虚拟机之后，尝试测试用ping baidu.com来测试网络的连接性，提示name or service not know这个错误，解决办法如下： 首先在/etc/sysonfit/network-scripts的路径下找到网卡的配置文件 用vi编辑配置文件，例如vi ifcfg-eth0，把其中的ONBOOT=NO改成ONBOOT=yes 重启网卡systemctl restart network 如果以上还不行，则按照如下步骤： 添加DNS服务器：vi /etc/resolv.conf 添加nameserver 114.114.114.114 保存该配置文件，重启网络服务systemctl restart network","link":"/2019/12/03/CentOS-7-ping-baidu-com-%E6%8A%A5%E9%94%99name-or-service-not-know/"},{"title":"Eclipse安装插件","text":"Eclipse中添加web dynamic project很多Eclipse版本是不能直接新建web dynamic project的，需要从网上找插件或更新。 我的Eclipse的版本是（Version: 4.5.1）代号为Mars版本号和代号如下图 比较方便的是在Help → Install-New-Software 选择Web，Xml，Java EE Development，点击next，finish，更新一段时间，重启Eclipse就能在File→New→other中找到Web及其目录下的web dynamic project了。 在Eclipse配置tomcat的时候，我发现在Eclipse—Preferences—server—Runtime Environment中，点击“Add”按钮，里面看不到tomcat的，只有个“J2EE Runtime Library”。 解决办法： Help -&gt; Install New Software Choose “Luna - http://download.eclipse.org/releases/Luna&quot; site Expand “Web, XML, and Java EE Development” Check JST Server Adapters (version 3.2.2) and JST Server Adapters Extentions 参考：Eclipse Eclipse配置文件导入和导出导出配置 设置好workspace配置后可以将配置保存为 *.epf 文件。 进入 File -&gt; Export ； 选择 General -&gt; Preferences ，下一步； 选择 Export all，在 To preference file 中输入要保存的路径和文件名； Finish。 导入配置 将 *.epf 配置文件导入workspace。 进入 File -&gt; Export ； 选择 General -&gt; Preferences ，下一步； 选择 Import all，在 From Preference File 中选择 *.epf 文件； Finish。","link":"/2016/01/21/Eclipse%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6/"},{"title":"Git移除.deal等配置文件","text":"如何在已经提交代码之后，移除.idea等配置文件总结，先删除，再提交。 先把.idea的配置文件剪贴到别的地方 通过git提交 git add . git commit -m &quot;&quot; git push origin master 去git仓库会发现配置文件已经没有了 干净后，git rm -r --cached .idea 取消跟踪 新建.gitignore文件，由于在windows中，无法新建没有名称的txt文件，所以需要通过git bash来创建。 在项目根目录下打开git bash touch .gitignore 打开新建的文件，添加.idea等要忽略的文件 把第一部的配置文件重新剪切回来 重新添加提交","link":"/2016/11/10/Git%E7%A7%BB%E9%99%A4-deal%E7%AD%89%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"},{"title":"Git配置不同项目的不同账号","text":"​ 在公司里做项目，一般都是公司直接分配git账号。而我自己在GitHub上也托管了自己的博客。两边使用的账号是不同的对应的ssh key也不一样。每次都手工更改是很麻烦的，也不是程序员应有的解决方案。这里我记录下我是如何解决git多账号登录的。 ​ 首先当初最开始设置 Git 的时候，都是默认全局设置的。例如： 12git config --global user.name &quot;your_name&quot; git config --global user.email &quot;your_email&quot; ​ 一般情况下，参与的项目都是同一个邮箱用户名是没啥问题的。但是碰到我这种情况，又不想换掉其中一个项目的用户名（我也没有这个决定权）。我就需要针对不同的项目设置不同的用户名邮箱。 1234cd ~/you project #进入项目文件夹 git init #初始化项目（如果已经是git目录了则不需要） git config user.name &quot;your_name&quot; #重新设置用户名和邮箱 git config user.email &quot;your_email&quot; ​ 说白了，也就是进入到你的git项目相对根目录下，然后执行git config设置记录。这时候我们打开项目中的.git文件夹，查看config文件会发现多了两行. 123456[branch &quot;master&quot;] remote = origin merge = refs/heads/master[user] name = you name email = youemail@host.com 在下一次提交的时候就优先是用项目文件中的git配置信息了。如果有必要可以执行取消全局设置的命令 12git config --global --unset user.namegit config --global --unset user.email SSH配置邮箱不同也会对应不同的SSH key，所以要针对不同的项目使用不同的key。所以打开git全局配置文件。一般在用户目录下的.ssh文件夹中。比如windows用户就是：C:\\Users\\用户名\\.ssh Linux就是～/.ssh找到config文件。没有就新建一个，用文本编辑器打开，添加如下配置： 123456789101112#第一个git项目账号Host first #给这个项目服务器起个名字，待会用到HostName test.com #这里需要用真实的项目检出hostname，为了项目安全，我这里随意写的User A #用户名IdentityFile ~/.ssh/id_rsa_first #该项目ssh key 所在路径#第二个git项目账号 和上面的项目配置一样Host secondHostName test2.comPort 1334User BIdentityFile ~/.ssh/id_rsa_second ​ 如果还没有生成ssh key 可以用一下命令生成,不同项目起不同名字或者放到不同路径，在上面的config配置中应用不同路径即可 1ssh-keygen -C &quot;your_email&quot; -t rsa 使配置生效 上面配置了ssh key时候指定了host名称，所以再次打开项目文件夹下的.git目录下的config文件，修改url配置，把原来的host name url 改成你上面配置的host 值比如 ‘first’ 、’seceond’等，类似如下 123[remote &quot;origin&quot;] url = git@first:A/proxy.git fetch = +refs/heads/*:refs/remotes/origin/* 也可以使用命令行完成配置。这里需要注意，使用.ssh目录下的host代替真实的hostname，这样才能让git识别出来 1git remote add first git@first:A/project.git 如果使用的是repo，也是同样操作 1repo init -u ssh://A@first -b branch push的时候，push到对应的Host即可 1git push fist master #first项目中： 作者： K_Biao链接：http://www.imooc.com/article/7419","link":"/2017/12/05/Git%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%90%8C%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%B8%8D%E5%90%8C%E8%B4%A6%E5%8F%B7/"},{"title":"Git常用命令","text":"####GIT常用的命令 一、新建仓库12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 二、配置123456789# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot; 三、增改文件1234567891011121314151617# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 四、提交123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 五、分支123456789101112131415161718192021222324252627282930313233343536373839# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 六、标签123456789101112131415161718192021222324252627# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 七、查看信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 八、远程同步123456789101112131415161718192021222324# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 九、撤销12345678910111213141516171819202122232425262728# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到工作区$ git checkout [commit] [file]# 恢复上一个commit的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit] 十、其他12# 生成一个可供发布的压缩包$ git archive Git基础","link":"/2016/01/09/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"Google play and something","text":"#####1、google play连接不上 在挂好VPN之后，浏览器可以正常访问外网，只有Google Play打开之后显示无连接。解决方案hosts文件有问题，在/etc/目录下面（需要root权限）找到hosts文件，用文本编辑器打开，删除127.0.0.1 Iocalhosts以外的所有内容后保存。","link":"/2015/10/10/Google-play-and-something/"},{"title":"Gradle for Android系列","text":"关于Android Studio的Gradle 系列文章 Gradle for Android 第一篇( 从 Gradle 和 AS 开始 )Gradle for Android 第二篇( Build.gradle入门 )Gradle for Android 第三篇( 依赖管理 )Gradle for Android 第四篇( 构建变体 )Gradle for Android 第五篇( 多模块构建 )Gradle for Android 第六篇( 测试)Gradle for Android 第七篇( Groovy入门 ) 用Gradle 构建你的android程序用Gradle 构建你的android程序","link":"/2016/01/14/Gradle-for-Android%E7%B3%BB%E5%88%97/"},{"title":"HTTP","text":"所有 HTTP 状态代码及其定义。HTTP 响应状态代码指示特定 HTTP 请求是否已成功完成。响应分为五类：信息响应(100–199)，成功响应(200–299)，重定向(300–399)，客户端错误(400–499)和服务器错误 (500–599)。状态代码由 section 10 of RFC 2616定义 代码 指示HTTP 100 Continue 这个临时响应表明，迄今为止的所有内容都是可行的，客户端应该继续请求，如果已经完成，则忽略它。HTTP 101 Switching Protocol 该代码是响应客户端的 Upgrade 标头发送的，并且指示服务器也正在切换的协议。HTTP 102 Processing (WebDAV) 此代码表示服务器已收到并正在处理该请求，但没有响应可用。HTTP 103 Early Hints 此状态代码主要用于与Link 链接头一起使用，以允许用户代理在服务器仍在准备响应时开始预加载资源。HTTP 2xx 成功HTTP 200 正常；请求已完成。HTTP 201 正常；紧接 POST 命令。HTTP 202 正常；已接受用于处理，但处理尚未完成。HTTP 203 正常；部分信息 — 返回的信息只是一部分。HTTP 204 正常；无响应 — 已接收请求，但不存在要回送的信息。HTTP 206 正常；代表数据的分段传输HTTP 3xx 重定向HTTP 301 已移动 — 请求的数据具有新的位置且更改是永久的。HTTP 302 已找到 — 请求的数据临时具有不同 URI。HTTP 303 请参阅其它 — 可在另一 URI 下找到对请求的响应，且应使用 GET 方法检索此响应。HTTP 304 未修改 — 未按预期修改文档。HTTP 305 使用代理 — 必须通过位置字段中提供的代理来访问请求的资源。HTTP 306 未使用 — 不再使用；保留此代码以便将来使用。HTTP 400 - 请求无效HTTP 401.1 - 未授权：登录失败HTTP 401.2 - 未授权：服务器配置问题导致登录失败HTTP 401.3 - ACL 禁止访问资源HTTP 401.4 - 未授权：授权被筛选器拒绝HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败HTTP 403 - 禁止访问HTTP 403 - 对 Internet 服务管理器 (HTML) 的访问仅限于 LocalhostHTTP 403.1 禁止访问：禁止可执行访问HTTP 403.2 - 禁止访问：禁止读访问HTTP 403.3 - 禁止访问：禁止写访问HTTP 403.4 - 禁止访问：要求 SSLHTTP 403.5 - 禁止访问：要求 SSL 128HTTP 403.6 - 禁止访问：IP 地址被拒绝HTTP 403.7 - 禁止访问：要求客户证书HTTP 403.8 - 禁止访问：禁止站点访问HTTP 403.9 - 禁止访问：连接的用户过多HTTP 403.10 - 禁止访问：配置无效HTTP 403.11 - 禁止访问：密码更改HTTP 403.12 - 禁止访问：映射器拒绝访问HTTP 403.13 - 禁止访问：客户证书已被吊销HTTP 403.15 - 禁止访问：客户访问许可过多HTTP 403.16 - 禁止访问：客户证书不可信或者无效HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效HTTP 404.1 - 无法找到 Web 站点HTTP 404 - 无法找到文件HTTP 405 - 资源被禁止HTTP 406 - 无法接受HTTP 407 - 要求代理身份验证HTTP 410 - 永远不可用HTTP 412 - 先决条件失败HTTP 414 - 请求 - URI 太长HTTP 415 介质类型不受支持 — 服务器拒绝服务请求，因为不支持请求实体的格式HTTP 500 - 内部服务器错误HTTP 500.100 - 内部服务器错误 - ASP 错误HTTP 500-11 服务器关闭HTTP 500-12 应用程序重新启动HTTP 500-13 - 服务器太忙HTTP 500-14 - 应用程序无效HTTP 500-15 - 不允许请求 global.asaError 501 - 未实现HTTP 502 - 网关错误","link":"/2015/10/21/HTTP/"},{"title":"HTTP协议下的分段下载","text":"在 HTTP 协议下分段下载文件假如一个文件有1000个字节，那么其范围就是0-999，则：Range: bytes=500- 表示读取该文件的500-999字节，共500字节。Range: bytes=500-599 表示读取该文件的500-599字节，共100字节。Range还有其它几种写法，但上面这两种是最常用的，对于断点续传也足矣了。如果HTTP请求中包含Range字段，那么服务器会返回206（Partial Content），同时HTTP头中也会有一个相应的Content-Range字段，类似下面的格式： Content-Range: bytes 500-999/1000Content-Range字段说明服务器返回了文件的某个范围及文件的总长度。这时Content-Length字段就不是整个文件的大小了，而是对应文件这个范围的字节数，这一点一定要注意。","link":"/2016/08/09/HTTP%E5%8D%8F%E8%AE%AE%E4%B8%8B%E7%9A%84%E5%88%86%E6%AE%B5%E4%B8%8B%E8%BD%BD/"},{"title":"HTTP基础和变迁","text":"HTTP​ HTTP（HyperTextTransferProtocol）是超文本传输协议的缩写，它用于传送WWW方式的数据，关于HTTP 协议的详细内容请参考RFC2616。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求，请求头包含请求的方法、URI、协议版本、以及包含请求修饰符、客户 信息和内容的类似于MIME的消息结构。服务器以一个状态行作为响应，相应的内容包括消息协议的版本，成功或者错误编码加上包含服务器信息、实体元信息以及可能的实体内容。HTTP是一种无状态性的协议。这是因为此种协议不要求浏览器在每次请求中标明它自己的身份，并且浏览器以及服务器之间并没有保持一个持久性的连接用于多个页面之间的访问。当一个用户访问一个站点的时候，用户的浏览器发送一个HTTP请求到服务器，服务器返回给浏览器一个HTTP响应。其实很简单的一个概念，客户端一个请求，服务器端一个回复，这就是整个基于HTTP协议的通讯过程。 URL​ 在WWW上，每一信息资源都有统一的且在网上唯一的地址，该地址就叫URL（Uniform Resource Locator,统一资源定位符），它是WWW的统一资源定位标志。URL分为绝对URL与相对URL两种。绝对URL和访问时的状态完全无关。与之相对应的是省略了部分信息的相对（relative）URL，如../file.php?text=hello+world，它需要根据当前浏览所在上下文环境里的基准URL，才能确定完整的URL地址。 ​ URL由三部分组成：资源类型、存放资源的主机域名、资源文件名。URL的一般语法格式为：(带方括号[]的为可选项)：protocol :// hostname[:port] / path / ;parameters#fragment 消息格式​ 通常HTTP消息包括客户机向服务器的请求消息和服务器向客户机的响应消息。这两种类型的消息由一个起始行，一个或者多个头域，一个只是头域结束的空行和可选的消息体组成。HTTP的头域包括通用头，请求头，响应头和实体头四个部分。每个头域由一个域名，冒号（:）和域值三部分组成。域名是大小写无关的，域值前可以添加任何数量的空格符，头域可以被扩展为多行，在每行开始处，使用至少一个空格或制表符。 ​ 当用户访问HTTP://example.com这个域名的时候，浏览器就会自动和服务器建立tcp/ip连接，然后发送HTTP请求到example.com的服务器的80端口。该个请求的语法如下所示： 12GET / HTTP/1.1Host: example.org ​ 以上第一行叫做请求行，第二个参数(一个反斜线在这个例子中)表示所请求资源的路径。反斜线代表了根目录;服务器会转换这个根目录为服务器文件系统中的一个具体目录。 ​ Apache的用户常用DocumentRoot这个命令来设置这个文档根路径。如果请求的url是HTTP://example.org/path/to/sc…那么请求的路径就是/path/to/script.php。假如document root 被定义为usr/lcoal/apache/htdocs的话,整个请求的资源路径就是/usr/local/apache/htdocs/path/to/script.php。 ​ 第二行描述的是HTTP头部的语法。在这个例子中的头部是Host, 它标识了浏览器希望获取资源的域名主机。还有很多其它的请求头部可以包含在HTTP请求中，比如user-Agent头部，在php可以通过$_SERVER['HTTP_USER_AGENT']获取请求中所携带的这个头部信息。 HTTP前世今生HTTP 0.9​ 最早版本是1991年发布的0.9版。该版本极其简单，只有一个命令GET。 1GET /index.html ​ 上面命令表示，TCP 连接（connection）建立后，客户端向服务器请求（request）网页index.html。协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。 123&lt;html&gt; &lt;body&gt;Hello World&lt;/body&gt;&lt;/html&gt; ​ 服务器发送完毕，就关闭TCP连接。 HTTP1.0​ 1996年5月，HTTP/1.0 版本发布，内容大大增加。首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。其次，除了GET命令，还引入了POST命令和HEAD命令，丰富了浏览器与服务器的互动手段。再次，HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。 短暂连接的缺陷​ HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。但是，这也造成了一些性能上的缺陷，例如，一个包含有许多图像的网页文件中并没有包含真正的图像数据内容，而只是指明了这些图像的URL地址，当WEB浏览器访问这个网页文件时，浏览器首先要发出针对该网页文件的请求，当浏览器解析WEB服务器返回的该网页文档中的HTML内容时，发现其中的图像标签后，浏览器将根据标签中的src属性所指定的URL地址再次向服务器发出下载图像数据的请求： ​ 显然，访问一个包含有许多图像的网页文件的整个过程包含了多次请求和响应，每次请求和响应都需要建立一个单独的连接，每次连接只是传输一个文档和图像，上一 次和下一次请求完全分离。即使图像文件都很小，但是客户端和服务器端每次建立和关闭连接却是一个相对比较费时的过程，并且会严重影响客户机和服务器的性 能。当一个网页文件中包含Applet，JavaScript文件，CSS文件等内容时，也会出现类似上述的情况。 HTTP1.1持久连接​ 在HTTP1.0中，每对Request/Response都使用一个新的连接。HTTP 1.1则支持持久连接Persistent Connection, 并且默认使用persistent connection. 在同一个tcp的连接中可以传送多个HTTP请求和响应. 多个请求和响应可以重叠，多个请求和响应可以同时进行. 更加多的请求头和响应头(比如HTTP1.0没有host的字段).HTTP 1.1的持续连接，也需要增加新的请求头来帮助实现，例如，Connection请求头的值为Keep-Alive时，客户端通知服务器返回本次请求结果后保持连接；Connection请求头的值为close时，客户端通知服务器返回本次请求结果后关闭连接。HTTP 1.1还提供了与身份认证、状态管理和Cache缓存等机制相关的请求头和响应头。HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪 每个客户也不记录过去的请求。此外，由于大多数网页的流量都比较小，一次TCP连接很少能通过slow-start区，不利于提高带宽利用率。 管道机制1.1 版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。 分块传输编码​ 分块传输编码（Chunked transfer encoding）是超文本传输协议（HTTP）中的一种数据传输机制，允许HTTP由应用服务器发送给客户端应用（ 通常是网页浏览器）的数据可以分成多个部分。分块传输编码只在HTTP协议1.1版本（HTTP/1.1）中提供。通常，HTTP应答消息中发送的数据是整个发送的，Content-Length消息头字段表示数据的长度。数据的长度很重要，因为客户端需要知道哪里是应答消息的结束，以及后续应答消息的开始。然而，使用分块传输编码，数据分解成一系列数据块，并以一个或多个块发送，这样服务器可以发送数据而不需要预先知道发送内容的总大小。通常数据块的大小是一致的，但也不总是这种情况。 ​ HTTP 1.1引入分块传输编码提供了以下几点好处： HTTP分块传输编码允许服务器为动态生成的内容维持HTTP持久连接。通常，持久链接需要服务器在开始发送消息体前发送Content-Length消息头字段，但是对于动态生成的内容来说，在内容创建完之前是不可知的。**[动态内容，content-length无法预知]** 分块传输编码允许服务器在最后发送消息头字段。对于那些头字段值在内容被生成之前无法知道的情形非常重要，例如消息的内容要使用散列进行签名，散列的结果通过HTTP消息头字段进行传输。没有分块传输编码时，服务器必须缓冲内容直到完成后计算头字段的值并在发送内容前发送这些头字段的值。**[散列签名，需缓冲完成才能计算]** HTTP服务器有时使用压缩 （gzip或deflate）以缩短传输花费的时间。分块传输编码可以用来分隔压缩对象的多个部分。在这种情况下，块不是分别压缩的，而是整个负载进行压缩，压缩的输出使用本文描述的方案进行分块传输。在压缩的情形中，分块编码有利于一边进行压缩一边发送数据，而不是先完成压缩过程以得知压缩后数据的大小。**[gzip压缩，压缩与传输同时进行]** ​ 一般情况HTTP的Header包含Content-Length域来指明报文体的长度。有时候服务生成HTTP回应是无法确定消息大小的，比如大文件的下载，或者后台需要复杂的逻辑才能全部处理页面的请求，这时用需要实时生成消息长度，服务器一般使用chunked编码。在进行Chunked编码传输时，在回复消息的Headers有transfer-coding域值为chunked，表示将用chunked编码传输内容。使用chunked编码的Headers如下（可以利用FireFox的FireBug插件或HttpWatch查看Headers信息）： 1234567891011121314151617 Chunked-Body=*chunk &quot;0&quot;CRLF footer CRLF chunk=chunk-size[chunk-ext]CRLF chunk-dataCRLF hex-no-zero=&lt;HEXexcluding&quot;0&quot;&gt; chunk-size=hex-no-zero*HEX chunk-ext=*(&quot;;&quot;chunk-ext-name[&quot;=&quot;chunk-ext-value]) chunk-ext-name=token chunk-ext-val=token|quoted-string chunk-data=chunk-size(OCTET) footer=*entity-header ​ 编码使用若干个Chunk组成，由一个标明长度为0的chunk结束，每个Chunk有两部分组成，第一部分是该Chunk的长度和长度单位（一般不 写），第二部分就是指定长度的内容，每个部分用CRLF隔开。在最后一个长度为0的Chunk中的内容是称为footer的内容，是一些没有写的头部内容。下面给出一个Chunked的解码过程（RFC文档中有）： 123456789101112131415 length:=0 readchunk-size,chunk-ext(ifany)andCRLF while(chunk-size&gt;0){ readchunk-dataandCRLF appendchunk-datatoentity-body length:=length+chunk-size readchunk-sizeandCRLF } readentity-header while(entity-headernotempty){ appendentity-headertoexistingheaderfields readentity-header } Content-Length:=length Remove&quot;chunked&quot;fromTransfer-Encoding HTTP2二进制协议支持​ HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧。二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。 多工复用​ HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。这样双向的、实时的通信，就叫做多工（Multiplexing）。 数据流​ 因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。 头信息压缩​ HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。 服务器推送​ HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。 HTTP General Header:HTTP 通用头​ 就整个网络资源传输而言，包括message-header和message-body两部分。首先传递message-header，即HTTP header消息。HTTP header 消息通常被分为4个部分：general header, request header, response header, entity header。但是这种分法就理解而言，感觉界限不太明确。根据维基百科对HTTP header内容的组织形式，大体分为Request和Response两部分。笔者在这里只是对于常见的协议头内容做一个列举，不同的设置会有不同的功能效果，会在下文中详细说明。本部分只介绍请求头的通用构成，具体的请求与响应参考各自章节。 注意每个Header的冒号后面有个空格 ​ 通用头域包含请求和响应消息都支持的头域，通用头域包含Cache-Control、 Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via。对通用头域的扩展要求通讯双方都支持此扩展，如果存在不支持的通用头域，一般将会作为实体头域处理。 Date​ Date头域表示消息发送的时间，时间的描述格式由rfc822定义。例如，Date:Mon,31Dec200104:25:57GMT。Date描述的时间表示世界标准时，换算成本地时间，需要知道用户所在的时区。 Pragma​ Pragma头域用来包含实现特定的指令，最常用的是Pragma:no-cache。在HTTP/1.1协议中，它的含义和Cache-Control:no-cache相同。 Entity​ 请求消息和响应消息都可以包含实体信息，实体信息一般由实体头域和实体组成。实体头域包含关于实体的原信息，实体头包括Allow、Content- Base、Content-Encoding、Content-Language、 Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、 Etag、Expires、Last-Modified、extension-header。extension-header允许客户端定义新的实体 头，但是这些域可能无法未接受方识别。实体可以是一个经过编码的字节流，它的编码方式由Content-Encoding或Content-Type定 义，它的长度由Content-Length或Content-Range定义。 Content-Type​ Content-Type实体头用于向接收方指示实体的介质类型，指定HEAD方法送到接收方的实体介质类型，或GET方法发送的请求介质类型Content-Range实体头。关于字符的编码，1.0版规定，头信息必须是 ASCII 码，后面的数据可以是任何格式。因此，服务器回应的时候，必须告诉客户端，数据是什么格式。Content-Range实体头用于指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。一般格式： 1Content-Range:bytes-unitSPfirst-byte-pos-last-byte-pos/entity-legth ​ Content-Type表明信息类型，缺省值为” text/plain”。它包含了主要类型（primary type）和次要类型（subtype）两个部分，两者之间用”/“分割。主要类型有9种，分别是application、audio、example、image、message、model、multipart、text、video。每一种主要类型下面又有许多种次要类型，常见的有： text/plain：纯文本，文件扩展名.txt text/html：HTML文本，文件扩展名.htm和.html image/jpeg：jpeg格式的图片，文件扩展名.jpg image/gif：GIF格式的图片，文件扩展名.gif audio/x-wave：WAVE格式的音频，文件扩展名.wav audio/mpeg：MP3格式的音频，文件扩展名.mp3 video/mpeg：MPEG格式的视频，文件扩展名.mpg application/zip：PK-ZIP格式的压缩文件，文件扩展名.zip Content-Length​ TCP 1.0中允许单个TCP连接可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是Content-length字段的作用，声明本次回应的数据长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入ByteArrayOutputStram，完成后查看其大小，然后把该值放入Content-Length头，最后通过 byteArrayStream.writeTo(response.getOutputStream()发送内容。 Content-Encoding​ 由于发送的数据可以是任何格式，因此可以把数据压缩后再发送。Content-Encoding字段说明数据的压缩方法。 123Content-Encoding: gzipContent-Encoding: compressContent-Encoding: deflate ​ 客户端在请求时，用Accept-Encoding字段说明自己可以接受哪些压缩方法。 1Accept-Encoding: gzip, deflate HTTP Lint1[Lint for HTTP:HTTPolice]() ​ HTTPolice是一个简单的基于命令行的对于HTTP请求格式规范进行检测的工具，可以直接使用pip命令进行安装: 1pip install HTTPolice ​ 当我们使用Google Chrome、Firefox或者Microsoft Edge进行网络访问时，可以使用开发者工具导出某个HAR文件，这也就是HTTP Lint工具可以用来解析的文件。使用如下命令进行分析: 12$ httpolice -i har /path/to/file.har------------ request: GET /1441/25776044114_0e5b9879a0_z.jpg------------ response: 200 OKC 1277 Obsolete 'X-' prefix in X-Photo-FarmC 1277 Obsolete 'X-' prefix in X-Photo-OriginE 1000 Malformed Expires headerE 1241 Date + Age is in the future ​ 默认的HTTPolice以文本形式输出报告文本，如下所示 1234567------------ request: PUT /articles/109226/E 1000 Malformed If-Match headerC 1093 User-Agent contains no actual product------------ response: 204 No ContentC 1110 204 response with no Date headerE 1221 Strict-Transport-Security without TLS------------ request: POST /articles/109226/comments/ ​ 纯文本的方式可能比较难以理解，我们可以使用-o html选项来设置更详细的基于HTML风格的输出，譬如: 1$ httpolice -i har -o html /path/to/file.har &gt;report.html 转载来自此链接","link":"/2016/08/24/HTTP%E5%9F%BA%E7%A1%80%E5%92%8C%E5%8F%98%E8%BF%81/"},{"title":"Hexo添加文章自动打开编辑器","text":"​ Hexo新建一篇文章的命令很简单hexo new arctical's title，然后在Hexo的根目录的source文件夹下的_posts目录下自动创建相应的md文件，之后打开该目录，找到Hexo自动生成的文件打开编辑即可。但是当文件比较多的时候，找一个新的文件是很麻烦的一件事。那么我们便可以通过 js 脚本自动打开相应的编辑器来省事。 分为两个平台，如果是 Windows 平台 123456789var spawn = require('child_process').exec;// Hexo 2.x 用户复制这段hexo.on('new', function(path){ exec('start &quot;markdown编辑器绝对路径.exe&quot; ' + path);});// Hexo 3 用户复制这段hexo.on('new', function(data){ exec('start &quot;markdown编辑器绝对路径.exe&quot; ' + data.path);}); 如果是MacBook 平台 123456789var exec = require('child_process').exec;// Hexo 2.x 用户复制这段hexo.on('new', function(path){ exec('open -a &quot;markdown编辑器绝对路径.app&quot; ' + path);});// Hexo 3 用户复制这段hexo.on('new', function(data){ exec('open -a &quot;markdown编辑器绝对路径.app&quot; ' + data.path);}); 之后重新新建文件，变回自动打开文件。","link":"/2017/02/11/Hexo%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E8%87%AA%E5%8A%A8%E6%89%93%E5%BC%80%E7%BC%96%E8%BE%91%E5%99%A8/"},{"title":"IMEI 和 IMSI 区别","text":"IMSI号：IMSI是国际移动用户识别码的简称(International Mobile Subscriber Identity)它是在公众陆地移动电话网（PLMN）中用于唯一识别移动用户的一个号码。在GSM网络，这个号码通常被存放在SIM卡中。IMSI共有15位，其结构如下： **MCC+MNC+MSIN ** MCC：Mobile Country Code，移动国家码，MCC的资源由国际电联（ITU）统一分配和管理，唯一识别移动用户所属的国家，共3位，中国为460; **MNC:**Mobile NetworkCode，移动网络码，共2位 在中国，中国移动TD系统使用00，中国联通GSM系统使用01，中国移动GSM系统使用02，中国电信CDMA系统使用03， 合起来就是（也是Android手机中APN配置文件中的代码）： 中国移动：46000 46002 中国联通：46001 中国电信：46003 举例，一个典型的IMSI号码为460030912121001 MSIN号： MSIN:Mobile Subscriber IdentificationNumber，为移动客户识别码，采用等长11位数字构成，其结构如下： 09+M0M1M2M3+ABCD 其中的M0M1M2M3和MDN号码中的H0H1H2H3可存在对应关系，ABCD四位为自由分配。 唯一地识别国内GSM移动通信网中移动客户。所以要区分是移动还是联通，只需取得SIM卡中的MNC字段即可 可以看出IMSI在MSIN号码前加了MCC即NMSI，可以区别出每个用户的来自的国家，因此可以实现国际漫游。在同一个国家内，如果有多个移动网络运营商，可以通过MNC来进行区别. IMEI号：IMEI是International Mobile Equipment Identity （国际移动设备标识）的简称 即通常所说的手机序列号，用于在手机网络中识别每一部独立的手机，是国际上公认的手机标志序号，相当于移动电话的身份证。国际移动装备辨识码一般贴于机身背面与外包装上，同时也存在于手机记忆体中，通过输入*#06#即可查询。 IMEI由15位数字组成的”电子串号”，它与每台手机一一对应，而且该码是全世界唯一的 其组成为： 前6位数(TAC)是”型号核准号码”，一般代表机型 接着的2位数(FAC)是”最后装配号”，一般代表产地 之后的6位数(SNR)是”串号”，一般代表生产顺序号 最后1位数(SP)通常是”0″，为检验码，目前暂备用 来源","link":"/2017/08/08/IMEI-%E5%92%8C-IMSI-%E5%8C%BA%E5%88%AB/"},{"title":"IMEI和MEID的区别","text":"​ 手机中的IMEI和MEID号码就如同我们生活中的身份证一样，它是识别手机身份的重要依据，如用虚假号码的手机，网络运营商可随时通过技术手段关闭此手机在网络中的运营，这将给手机的使用者带来巨大的使用风险。手机中所使用的IMEI或MEID等号段均可透过摩尔实验室等相关机构合法申请。 IMEI国际移动设备识别码（IMEI：International Mobile Equipment Identification Number）是区别移动设备的标志，储存在移动设备中，可用于监控被窃或无效的移动设备。目前GSM和WCDMA手机终端需要使用IMEI号码 手机制造商在申请IMEI号码之前，必须先在IMEI网上进行注册，BABT审核通过后会发该制造商的厂家注册码，申请人凭借厂家注册码在IMEI网站上进行在线申请。 目前GSM和WCDMA手机终端需要使用IMEI号码，IMEI号码由GSMA组织进行管理，并授权英国BABT和美国的PTCRB两个认证机构进行发放。在北美地区进行销售的手机产品，需要向PTCRB机构申请IMEI号码。其他国家或地区进行销售的手机产品向BABT进行申请。 手机普通用户可以通过输入*＃06＃来查看手机的IMEI号码。 MEID 移动设备识别码(Mobile Equipment Identifier)是CDMA手机的身份识别码，也是每台手机有唯一的识别码。通过这个识别码，网络端可以对该手机进行跟踪和监管。用于CDMA制式的手机。MEID的数字范围是十六进制的，和IMEI的格式类似。 MEID号码是由Telecommunications Industry Association（TIA）进行分配管理的。申请MEID是需要付费的。目前的价格是每1M范围的MEID的费用是8000美元，每增加1M范围的MEID号码需要额外付费8000美元。 MEID号码的查看，目前没有一个通用的方法，由各手机制造商自己设置。可以通过查看手机说明书得到查看MEID号码的方法。","link":"/2016/08/22/IMEI%E5%92%8CMEID%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"title":"Java回调机制","text":"####一个关于Java回调机制的小案例一个经典例子让你彻彻底底理解java回调机制","link":"/2016/01/08/Javva%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6/"},{"title":"Java HashMap工作原理及实现","text":"Java HashMap工作原理及实现Java HashMap工作原理及实现","link":"/2016/01/27/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"},{"title":"Linux tar","text":"简单的说： 123456#压缩tar -zcvf ***.tar.gztar -jcvf ***.tar.bz2#解压tar -zxvf ***.tar.gztar -jxvf ***.tar.bz2 tar [-cxtzjvfpPN] 文件与目录 …. 常用参数： -c ：建立一个压缩文件的参数指令(create 的意思)； -x ：解开一个压缩文件的参数指令！ -t ：查看 tarfile 里面的文件！ Ps: 特别注意，在参数的下达中， c/x/t 仅能存在一个,不可同时存在. -z ：是否同时具有 gzip 的属性？亦即是否需要用 gzip 压缩？ -j ：是否同时具有 bzip2 的属性？亦即是否需要用 bzip2 压缩？ -v ：压缩的过程中显示文件！这个常用，但不建议用在背景执行过程！ -f ：使用档名，请留意，在 f 之后要立即接档名 -p ：使用原文件的原来属性（属性不会依据使用者而变） -P ：可以使用绝对路径来压缩！ -N ：比后面接的日期(yyyy/mm/dd)还要新的才会被打包进新建的文件中！ –exclude FILE：在压缩的过程中，不要将 FILE 打包！ 参考 ：linux tar (打包.压缩.解压缩)命令说明 | tar如何解压文件到指定的目录？","link":"/2019/12/10/Linux-tar/"},{"title":"Linux 下后台运行Python脚本","text":"如果要在Linux服务器端一直运行一个Python脚本，当然就想到了在命令后面加&amp;符号。 例如： 1$ python /data/python/server.py &gt;python.log &amp; ​ 1、 &gt; 表示把标准输出（STDOUT）重定向到 那个文件，这里重定向到了python.log。 ​ 2、 &amp; 表示在后台执行脚本。这样可以到达目的，但是，我们退出shell窗口的时候，必须用exit命令来退出，否则，退出之后，该进程也会随着shell的消失而消失（退出、关闭） 使用nohup(not hang up)： 1$ nohup python /data/python/server.py &gt; python.log3 2&gt;&amp;1 &amp; ​ 1、1是标准输出（STDOUT）的文件描述符，2是标准错误（STDERR）的文件描述符 ​ 1&gt; python.log 简化为 &gt; python.log，表示把标准输出重定向到python.log这个文件 ​ 2、2&gt;&amp;1 表示把标准错误重定向到标准输出，这里&amp;1表示标准输出，为什么需要将标准错误重定向到标准输出的原因，是因为标准错误没有缓冲区，而STDOUT有。​这就会导致 commond &gt; python.log 2&gt; python.log 文件python.log被两次打开，而STDOUT和 STDERR将会竞争覆盖，这肯定不是我门想要的 ​ 3、好了，我们现在可以直接关闭shell窗口（我用的是SecureCRT，用的比较多的还有Xshell），而不用再输入exit这个命令来退出shell了 123$ ps aux|grep pythontomener 1885 0.1 0.4 13120 4528 pts/0 S 15:48 0:00 python /data/python/server.pytomener 1887 0.0 0.0 5980 752 pts/0 S+ 15:48 0:00 grep python ​ 现在当我们直接关闭shell窗口，再连接上服务器，查看Python的进程，发现进程还在,但是，在python运行中却查看不到输出！ ​ 因为：Python的输出有缓冲，导致python.log3并不能够马上看到输出。使用-u参数，使得python不启用缓冲。所以改正命令，就可以正常使用了。 1$ nohup python -u test.py &gt; out.log 2&gt;&amp;1 &amp;","link":"/2017/11/01/Linux-%E4%B8%8B%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8CPython%E8%84%9A%E6%9C%AC/"},{"title":"Linux 下的五个查找命令","text":"使用电脑的时候，经常需要查找文件。 在Linux中，有很多方法可以做到这一点。 国外网站LinuxHaxor总结了五条命令，你可以看看自己知道几条。大多数程序员，可能经常使用其中的2到3条，对这5条命令都很熟悉的人应该是不多的。 find find是最常见和最强大的查找命令，你可以用它找到任何你想找的文件。 find的使用格式如下： $ find &lt;指定目录&gt; &lt;指定条件&gt; &lt;指定动作&gt; - &lt;指定目录&gt;： 所要搜索的目录及其所有子目录。默认为当前目录。 - &lt;指定条件&gt;： 所要搜索的文件的特征。 - &lt;指定动作&gt;： 对搜索结果进行特定的处理。 如果什么参数也不加，find默认搜索当前目录及其子目录，并且不过滤任何结果（也就是返回所有文件），将它们全都显示在屏幕上。 find的使用实例： $ find . -name ‘my*‘ 搜索当前目录（含子目录，以下同）中，所有文件名以my开头的文件。 $ find . -name ‘my*‘ -ls 搜索当前目录中，所有文件名以my开头的文件，并显示它们的详细信息。 $ find . -type f -mmin -10 搜索当前目录中，所有过去10分钟中更新过的普通文件。如果不加-type f参数，则搜索普通文件+特殊文件+目录。 locate locate命令其实是”find -name”的另一种写法，但是要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库（/var/lib/locatedb），这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，所以使用locate命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。 locate命令的使用实例： $ locate /etc/sh 搜索etc目录下所有以sh开头的文件。 $ locate ~/m 搜索用户主目录下，所有以m开头的文件。 $ locate -i ~/m 搜索用户主目录下，所有以m开头的文件，并且忽略大小写。 whereis whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。 whereis命令的使用实例： $ whereis grep which which命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。 which命令的使用实例： $ which grep type type命令其实不能算查找命令，它是用来区分某个命令到底是由shell自带的，还是由shell外部的独立二进制文件提供的。如果一个命令是外部命令，那么使用-p参数，会显示该命令的路径，相当于which命令。 type命令的使用实例： $ type cd 系统会提示，cd是shell的自带命令（build-in）。 $ type grep 系统会提示，grep是一个外部命令，并显示该命令的路径。 $ type -p grep 加上-p参数后，就相当于which命令。 Linux的五个查找命令","link":"/2017/09/01/Linux-%E4%B8%8B%E7%9A%84%E4%BA%94%E4%B8%AA%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4/"},{"title":"Linux 下安装 zsh","text":"Zsh 是一款功能强大终端（shell）软件，既可以作为一个交互式终端，也可以作为一个脚本解释器。它在兼容 Bash 的同时 (默认不兼容，除非设置成 emulate sh) 还有提供了很多改进。 安装更新过程： 1. 安装 zsh 软件包和 git12CentOS： yum -y install zsh gitUbuntu: sudo apt -y install zsh git 2. 克隆 oh-my-zsh1$ git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh 3. 复制 .zshrc，修改命令提示符样式12$ cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrcZSH_THEME=&quot;ys&quot; 4. 修改 shell 类型1$ chsh -s /bin/zsh 5. 更新 oh-my-zsh 1$ omz update 6. 如果要换 oh-my-fish 123$ uninstall_oh_my_zsh$ brew install fish$ curl -L https://github.com/bpinto/oh-my-fish/raw/master/tools/install.sh | sh","link":"/2017/10/19/Linux-%E4%B8%8B%E5%AE%89%E8%A3%85-zsh/"},{"title":"Linux 免密登录","text":"A为本地主机(即用于控制其他主机的机器) ;B为远程主机(即被控制的机器Server), 假如ip为192.168.1.1 ;A和B的系统都是Linux. 什么是 SSH？ Secure Shell（缩写为SSH），由IETF的网络工作小组（Network Working Group）所制定；SSH为一项创建在应用层和传输层基础上的安全协议，为计算机上的Shell（壳层）提供安全的传输和使用环境。 传统的网络服务程序，如rsh、FTP、POP和Telnet其本质上都是不安全的；因为它们在网络上用明文传送数据、用户帐号和用户口令，很容易受到中间人（man-in-the-middle）攻击方式的攻击。就是存在另一个人或者一台机器冒充真正的服务器接收用户传给服务器的数据，然后再冒充用户把数据传给真正的服务器。 而SSH是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用SSH协议可以有效防止远程管理过程中的信息泄露问题。通过SSH可以对所有传输的数据进行加密，也能够防止DNS欺骗和IP欺骗。 SSH之另一项优点为其传输的数据可以是经过压缩的，所以可以加快传输的速度。SSH有很多功能，它既可以代替Telnet，又可以为FTP、POP、甚至为PPP提供一个安全的“通道”。 Secure Shell 基本用法 假设要以用户名 user,远程登录主机 host 1ssh user@host SSH的默认端口是22，如果不是这个端口登录，需要添加-p参数 1ssh -p port user@host 公钥登录 如最开始的说明，每次登录固定的 host，不想输入密码在怎么登录。 ​ 在A上的命令: 123ssh-keygen -t rsa #(连续三次回车,即在本地生成了公钥和私钥,不设置密码)ssh root@172.24.253.2 &quot;mkdir .ssh;chmod 0700 .ssh&quot; #(需要输入密码， 注:必须将.ssh的权限设为700)scp ~/.ssh/id_rsa.pub root@172.24.253.2:.ssh/id_rsa.pub #(需要输入密码) 在 B 上的命令: 123touch /root/.ssh/authorized_keys #(如果已经存在这个文件, 跳过这条)chmod 600 ~/.ssh/authorized_keys #(# 注意： 必须将~/.ssh/authorized_keys的权限改为600, 该文件用于保存ssh客户端生成的公钥，可以修改服务器的ssh服务端配置文件/etc/ssh/sshd_config来指定其他文件名）cat /root/.ssh/id_rsa.pub &gt;&gt; /root/.ssh/authorized_keys #(将id_rsa.pub的内容追加到 authorized_keys 中, 注意不要用 &gt; ，否则会清空原有的内容，使其他人无法使用原有的密钥登录) ​","link":"/2017/04/27/Linux-%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/"},{"title":"Linux 解决Vi输入中文乱码的问题","text":"在VPS 中, 有时vi 打开一个文件中, 中文会显示乱码, 用locale 查看如下, 12345678910111213141516➜ ~ localeLANG=en_US.UTF-8LANGUAGE=en_US.UTF-8LC_CTYPE=&quot;en_US.UTF-8&quot;LC_NUMERIC=&quot;en_US.UTF-8&quot;LC_TIME=&quot;en_US.UTF-8&quot;LC_COLLATE=&quot;en_US.UTF-8&quot;LC_MONETARY=&quot;en_US.UTF-8&quot;LC_MESSAGES=&quot;en_US.UTF-8&quot;LC_PAPER=&quot;en_US.UTF-8&quot;LC_NAME=&quot;en_US.UTF-8&quot;LC_ADDRESS=&quot;en_US.UTF-8&quot;LC_TELEPHONE=&quot;en_US.UTF-8&quot;LC_MEASUREMENT=&quot;en_US.UTF-8&quot;LC_IDENTIFICATION=&quot;en_US.UTF-8&quot;LC_ALL=en_US.UTF-8 其实vi中输入中文乱码与上述系统语言编码无关，是vi自身的环境变量设置出了问题, 解决办法如下 123~ vi .viminfo # ubuntu 18encoding=latin1#修改成下面encoding=utf-8","link":"/2018/06/19/Linux-%E8%A7%A3%E5%86%B3Vi%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"Linux中的apt-get和apt-cache命令的原理","text":"先介绍几个和apt-get相关的目录: /var/lib/dpkg/available文件的内容是软件包的描述信息, 该软件包括当前系统所使用的 Debian 安装源中的所有软件包,其中包括当前系统中已安装的和未安装的软件包. /var/cache/apt/archives目录是在用 apt-get install 安装软件时，软件包的临时存放路径 /etc/apt/sources.list存放的是软件源站点, 当你执行 sudo apt-get install xxx 时，Ubuntu 就去这些站点下载软件包到本地并执行安装 /var/lib/apt/lists使用apt-get update命令会从/etc/apt/sources.list中下载软件列表，并保存到该目录 APT工作原理： Ubuntu采用集中式的软件仓库机制，将各式各样的软件包分门别类地存放在软件仓库中，进行有效地组织和管理。然后，将软件仓库置于许许多多的镜像服务器中，并保持基本一致。这样，所有的Ubuntu用户随时都能获得最新版本的安装软件包。因此，对于用户，这些镜像服务器就是他们的软件源（Reposity）。 然而，由于每位用户所处的网络环境不同，不可能随意地访问各镜像站点。为了能够有选择地访问，在Ubuntu系统中，使用软件源配置文件/etc/apt/sources.list列出最合适访问的镜像站点地址。 apt-get的更新过程:执行apt-get update程序分析/etc/apt/sources.list自动连网寻找list中对应的Packages/Sources/Release列表文件，如果有更新则下载之，存入/var/lib/apt/lists/目录然后 apt-get install 相应的包 ，下载并安装。 即使这样，软件源配置文件只是告知Ubuntu系统可以访问的镜像站点地址，但那些镜像站点具体都拥有什么软件资源并不清楚。若每安装一个软件包，就在服务器上寻找一遍，效率是很低的。因而，就有必要为这些软件资源列个清单（建立索引文件），以便本地主机查询。 apt-get install 下载的软件存放到 /var/cache/apt/archives/下。 同时，APT能够检查Ubuntu Linux系统中的软件包依赖关系，大大简化了Ubuntu用户安装和卸载软件包的过程。","link":"/2017/05/04/Linux%E4%B8%AD%E7%9A%84apt-get%E5%92%8Capt-cache%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8E%9F%E7%90%86/"},{"title":"Linux压缩解压的几个命令","text":"该Linux解压是在Ubuntu14LTS下进行的，主要是几个常见的命令 .tar 解包：tar xvf FileName.tar 打包：tar cvf FileName.tar DirName PS：打包和压缩是两个概念 .gz 解压1：gunzip FileName.gz解压2：gzip -d FileName.gz压缩：gzip FileName .tar.gz 和 .tgz解压：tar zxvf FileName.tar.gz压缩：tar zcvf FileName.tar.gz DirName .bz2 解压1：bzip2 -d FileName.bz2解压2：bunzip2 FileName.bz2压缩： bzip2 -z FileName .tar.bz2解压：tar jxvf FileName.tar.bz2压缩：tar jcvf FileName.tar.bz2 DirName .zip 解压：unzip FileName.zip压缩：zip FileName.zip DirName .rar 解压：rar x FileName.rar压缩：rar a FileName.rar DirName .rmp 解包：rpm2cpio FileName.rpm | cpio -div .deb 解包：ar p FileName.deb data.tar.gz | tar zxf - .tar .tgz .tar.gz .tar.Z .tar.bz .tar.bz2 .zip .cpio .rpm .deb .slp .arj .rar .ace .lha .lzh .lzx .lzs .arc .sda .sfx .lnx .zoo .cab .kar .cpt .pit .sit .sea 解压：sEx x FileName.*压缩：sEx a FileName.* FileName PS：sEx只是调用相关程序，本身并无压缩、解压功能，请注意！ ​ ​","link":"/2016/09/21/Linux%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%E7%9A%84%E5%87%A0%E4%B8%AA%E5%91%BD%E4%BB%A4/"},{"title":"Linux查找并杀死多个进程","text":"ps -ef|grep python|grep -v grep|cut -c 9-15|xargs kill -9 ps -ef查看所有进程 grep python塞选出含有python的进程 grep -v grep排除最上面那个命令的进程 cut -c 9-15是截取输入行的第9个字符到第15个字符，而这正好是进程号PID xargs kill -9中的xargs命令是用来把前面命令的输出结果（PID）作为“kill -9”命令的参数，并执行该命令","link":"/2019/09/27/Linux%E6%9F%A5%E6%89%BE%E5%B9%B6%E6%9D%80%E6%AD%BB%E5%A4%9A%E4%B8%AA%E8%BF%9B%E7%A8%8B/"},{"title":"Linux提示Give root password for maintenance","text":"由于非法重启或硬盘故障，会导致linux系统无法启动，无法进入操作系统。当你看到提示：give root password for maintenance(or type control-D to continue):的时候，你还有补救的机会。问题原因应该是/usr /home /boot分区磁盘检测出了问题。 用两个办法可以尝试。 方法一： 输入root密码，回车 此时画面便会出现以下指令提示：(Repair filesystem)1#: 在提示后输入e2fsck -y /dev/hda2，再按回车，便可检查档案系统 系统即会自动进行修复并于画面显示修复进度 完成后会自动重启，或者输入exit 大部份档案系统都可用此方法修复好，但如系统或重要的系统档案损毁严重，则必须重新安装系统 方法二： 重启后界面停在： 12give root password for maintenance(or type control-D to continue): 此时输入root密码，回车 输入fsck -y回车，会开始修复文件系统，时间长短不一。 修复完成后输入reboot回车重启电脑即可","link":"/2017/01/09/Linux%E6%8F%90%E7%A4%BAGive-root-password-for-maintenance/"},{"title":"Linux知识点小结","text":"####关于Linux的一些小知识点 Linux一些小知识点 $1 我的Linux需求 Linux博大精深。我只在此讨论一些我对线上Linux机器维护人员的基本需求，比如装机，加硬盘，配网络。只讨论CentOS 6，或者类似的RHEL，当然Ubuntu也可以此类推，但是一些新特性不予讨论，因为我不懂，比如CentOS 7的xfs不予讨论，并不是说xfs不好，而是以目前我的Linux水平需要更新很多xfs的知识，驾驭需要时间。CentOS 7将ifconfig，netstat等原来常用的命令也干掉了，用ip，lsof替换是更加好的工具，但是大部分的线上机器都应该还没有更新到CentOS 7。下面我们以CentOS 6作为基础，谈我认为最基本的4点。 $1.1 最小化安装 CentOS有一个minimal版本，相对于标准版去掉了很多Service，比如Network Manager，安装最小版本以后的网络配置是需要admin进行写配置文件的。我个人认为这样是比较好的，因为这样才能知道Linux内核真正关心的是哪些配置文件，直达核心。一些必要的监控工具，完全可以通过yum install来完成。作为线上机器，还是最小化安装，做到能不开的服务就不开，能关掉的端口就关掉，这样既能将宝贵的硬件资源留下来给应用程序，也能够做到更加的安全。 $1.2 足够安全 除了将能关的端口关掉，能不用的服务关掉以外，安全还需要做到特定的服务只能访问特定的内容。哪怕是root账户，不能访问的文件和文件夹还是不能访问，更加不能操作。开启SELinux以后，能够做到在不修改SELinux的情况下，指定的服务只能访问指定的资源。对于ssh要做到关闭账户密码登录，只能通过秘钥登录，这样在保证秘钥不被盗用的情况下是最安全的。 $1.3 资源按需调度 我们经常会遇到这样一个问题，假设将磁盘sda挂载到/var目录，但是由于log太多或者上传的文件等等其他因素将硬盘吃光了，再创建一块sdb磁盘就无法挂载到/var目录了，其实Linux自带的lvm已经解决了这个问题，并且CentOS默认就是用lvm来管理磁盘的。我们需要学会如何格式化一块硬盘为lvm，然后挂载到对应目录，在空间被吃光前能够添加一块硬盘就自动扩容。 $1.4 网络监控 Linux本地要利用好net_filter，也就是iptables，来规划服务哪些网络流量，抛弃哪些网络流量。以及在进行组网的时候需要用router来进行网关的创建，在遇到网络问题的时候通过netstat来查看网络访问异常。网络这块内容很多很杂，各种参数，TCP/IP协议栈等等，但是往往问题还就是出在网络这块，所以要给与高度的关注。 $2 Linux的理念与基础 小谈几点我对Linux的认识。 $2.1 Linux的文件系统 Linux将所有的事物都看成文件，这一点人尽皆知。我想说的是，除了传统的ext文件系统，Linux在抽象不同的资源的时候其实有各种不同的文件系统，都是从需求和使用出发，比如proc文件系统就是针对进程的抽象，使得修改对应进程的值就可以直接改变进程的行为。再比如，对于远程ssh登录的pts设备，Linux有对应的devpts文件系统。看下面表哥的type一栏。 123456789file_system dir type options dump pass/dev/mapper/VolGroup-lv_root / ext4 defaults 1 1UUID=xxx /boot ext4 defaults 1 2/dev/mapper/VolGroup-lv_swap swap swap defaults 0 0tmpfs /dev/shm tmpfs defaults 0 0devpts /dev/pt devpts gid=5,mod=620 0 0sysfs /sys sysfs defaults 0 0proc /proc proc defaults 0 0 $2.2 Linux的权限管理 Linux的-rwxrwxrwx权限管理也可谓人尽皆知，其实Linux自己也意识到了这样的权限管理所带来的一些局限性。首先rwx的权限管理是基于用户和组的，并且只是大致的分为owner|group|other这三类，无法再作更加细粒度的划分。有鉴于此，Linux目前默认是有ACL(Access Control List)管理的，所谓ACL就是能够提供更加细粒度的用户和组管理，比如可以明确哪个user可以有什么样的权限。如下示例 123456789getfacl abc# file: abc# owner: someone# group: someoneuser::rw-user:johny:r-xgroup::r--mask::r-xother::r-- 而SELinux提供了不基于用户与组的权限管理，SELinux是基于应用程序的，什么样的应用程序可以使用什么资源，对于这些资源这个应用程序能干嘛，这个就是SELinux的管理方式。 $2.3 Linux上的Service Linux上的Service组织得非常清晰，/etc/init.d/里面包含了所有的Service启动脚本，对应的二进制文件在/usr/bin 、 /usr/sbin 、 /usr/local/bin等目录下，一般而言配置文件在/etc/app_name下，还有一个chkconfig的工具来管理各个runlevel下需要启动的Service。这样的约定俗成使得管理员在配置和使用的时候非常方便。Linux标准的Service都会将log记录到/var/log/messages中，使得系统管理员不需要翻阅各种log，直接在/var/log/messages中就可以找到绝大部分的log来判断当前系统是否正常。更甚者，syslogd被rsyslogd替换以后，可以将/var/log/messages中的内容通过UDP发送到远端用专业的log分析工具进行分析。我们需要学习Linux上Service的这些优秀的编程习惯和技巧。 $3 磁盘 根据$1中的需求，下面是我记录的一些基本的磁盘操作。 df -lah 查看磁盘的使用情况fdisk -l 查看插入到磁盘驱动器中的硬盘; sd(a,b,c)(1,2,3)，其中a是第一块磁盘，b是第二块磁盘，1，2，3表示磁盘上的主分区，最多4个。用fdisk从磁盘创建分区并且格式化。LVM(logical volume manager)，主要就是满足加硬盘就能直接写数据的功能，而不会出现磁盘满了，新的磁盘只能挂载其他目录的情况。lvm有几个概念，VG, PV。将磁盘lvm格式化，创建PV, 创建VG，将创建的PV加入VG，然后在VG中创建lvm，然后就可以动态增加大小了。注意，将磁盘格式化为lvm，但是lv的格式化需要用ext，然后才能mount上去。参考这篇文章CentOS 6 卷组挂载硬盘教程mount -t type(ext4|nfs) /dev/sdxn /path/dir 来挂载。如果要重启生效，必须将挂载信息写入到/etc/fstab磁盘IO效率(IOPS)需要用vmstat, top等工具来查看。和性能相关的调优和监控留待后续文章详述。$4 网络 网络的坑很多，需要把网络搞通没个3，4年很难。下面从网络的配置文件着手，简单理一下网络方面的内容。网络最难的方面应该是如何搭建一个合理的高效的局域网或者城域网，这个需要有专业的网络知识。 $4.1 配置文件 /etc/hosts私有IP对应主机名/etc/resolv.confnameserver DNS的IP/etc/sysconfig/network其中NETWORKING=要不要有网络，HOSTNAME=主机名，NETWORKING_IPV6=支持ipv6否/etc/sysconfig/network-scripts/ifcfg-xxx其中DEVICE=网卡代号，BOOTPROTO=是否使用dhcp，HWADDR，IPADDR，NETMASK，ONBOOT，GATEWAY$4.2 与网络有关的一些命令 router -n查看路由的命令，特别是要看带G的，表示gateway，而带U的表示up。netstat -anp查看所有启动的tcp,udp,unix stream的应用程序，以及他们的状态，具体可以参考TCP/IP,JavaSocket简单分析一文。$5 安全 $5.1 PAM PAM只需要简单了解就行，是一个可插拔的认证模块。我的理解是：开发Linux的极客们搞出来的可复用的一个组件。举个例子，现在有一个app，想要验证当前的登录用户是否有权限操作某个目录，那么在PAM里面有现成的模块，app只需要include这个模块，给出一个配置文件，就可以了。有一个非常好的关于PAM的视频教程，请看这里 PAM是应用程序用来进行身份验证的。早期的身份验证和应用程序本身耦合，后来把身份验证单独抽出来，通过PAM来进行管理/etc/pam.d/xxx 是能用pam来进行管理的应用程序PAM设置，在安装应用程序的时候安装。/etc/security/mmm, /lib/security/pam_mmm是一套。$5.2 SELinux SELinux也有一个非常好的视频教程，请看这里 getenforce来查看SELinux是否被启用/etc/sysconfig/selinux enforcing启用SELinuxSELinux对“运行程序”配置和检查其是否有权限操作“对象”（文件系统），而普通的ACL(rwx)就是根据文件所属owner及其组来判断。SELinux是看可执行文件的type和目录文件的type是否兼容，来决定可执行文件是否能操作资源$5.3 防火墙 下面是学习时候的一些摘录。特别一点，要开启内核参数net.ipv4.ip_forward=1，在/etc/sysctl.conf文件中，用sysctl -p来保存。所谓ip_forward指的是内核提供的从一个iface到另外一个iface的IP包转发，比如将IP包从192.168.1.10的eth0转发到10.0.0.123的eth1上。防火墙配置是需要专业技能的。 tcp_wrapper需要libwrap.so的支持，可执行文件在ldd bin_file出来没有libwrap.so的，都不能用tcp_wrapperiptables是按照规则进行短路判断的，即 满足条件1-&gt;执行action1-&gt;结束iptables-save来更加清晰的查看先删掉全部规则，然后添加，比较简单。添加的时候，先添加策略，再添加细部规则。一般来讲，我们需要关注的是filter这个表的INPUT与OUTPUTiptables -A(I) INPUT(OUTPUT,FORWARD) -i(o) iface -p tcp(ump,imp,all) -s (!)source -d dest -j ACCEPT(REJECT,DROP), 还支持的参数 —dport —sport$6 工具 一个好的Linux命令参考网站 $6.1 CPU top 特别注意loadps aux和ps -ef 特别注意进程状态vmstat 1表示每秒采集一次sar -u 1 查看所有cpu相关的运行时间$6.2 Memory freevmstat 1 注意其中的swap ram block之间的关系sar -r 1 内存使用率sar -W 1 查看swap，查询是否由于内存不足产生大量内存交换$6.3 IO lsof -i:port 查询哪个进程占用了这个端口号lsof -u username 用户打开的文件lsof -p pid 进程打开的文件杂项 关于安装好系统之后的运行脚本，这边有一个参考 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253#!/bin/bash################################################## author huachao# date 2015-12-09# email i@huachao.me# web blog.huachao.me#################################################flagFile=&quot;/root/centos6-init.executed&quot;precheck(){ if [[ &quot;$(whoami)&quot; != &quot;root&quot; ]]; then echo &quot;please run this script as root .&quot; &gt;&amp;2 exit 1 fi if [ -f &quot;$flagFile&quot; ]; then echo &quot;this script had been executed, please do not execute again!!&quot; &gt;&amp;2 exit 1 fi echo -e &quot;\\033[31m WARNING! THIS SCRIPT WILL \\033[0m\\n&quot; echo -e &quot;\\033[31m *1 update the system; \\033[0m\\n&quot; echo -e &quot;\\033[31m *2 setup security permissions; \\033[0m\\n&quot; echo -e &quot;\\033[31m *3 stop irrelevant services; \\033[0m\\n&quot; echo -e &quot;\\033[31m *4 reconfig kernel parameters; \\033[0m\\n&quot; echo -e &quot;\\033[31m *5 setup timezone and sync time periodically; \\033[0m\\n&quot; echo -e &quot;\\033[31m *6 setup tcp_wrapper and netfilter firewall; \\033[0m\\n&quot; echo -e &quot;\\033[31m *7 setup vsftpd; \\033[0m\\n&quot; sleep 5 }yum_update(){ yum -y update #update system at 5:40pm daily echo &quot;40 3 * * * root yum -y update &amp;&amp; yum clean packages&quot; &gt;&gt; /etc/crontab}permission_config(){ #chattr +i /etc/shadow #chattr +i /etc/passwd}selinux(){ sed -i 's/SELINUX=disabled/SELINUX=enforcing/g' /etc/sysconfig/selinux setenforce 1}stop_services(){ for server in `chkconfig --list |grep 3:on|awk '{print $1}'` do chkconfig --level 3 $server off done for server in crond network rsyslog sshd iptables do chkconfig --level 3 $server on done}limits_config(){cat &gt;&gt; /etc/security/limits.conf &lt;&lt;EOF* soft nproc 65535* hard nproc 65535* soft nofile 65535* hard nofile 65535EOFecho &quot;ulimit -SH 65535&quot; &gt;&gt; /etc/rc.local}sysctl_config(){sed -i 's/net.ipv4.tcp_syncookies.*$/net.ipv4.tcp_syncookies = 1/g' /etc/sysctl.confsed -i 's/net.ipv4.ip_forward.*$/net.ipv4.ip_forward = 1/g' /etc/sysctl.confcat &gt;&gt; /etc/sysctl.conf &lt;&lt;EOFnet.ipv4.tcp_max_syn_backlog = 65536net.core.netdev_max_backlog = 32768net.core.somaxconn = 32768net.core.wmem_default = 8388608net.core.rmem_default = 8388608net.core.rmem_max = 16777216net.core.wmem_max = 16777216net.ipv4.tcp_timestamps = 0net.ipv4.tcp_synack_retries = 2net.ipv4.tcp_syn_retries = 2net.ipv4.tcp_tw_recycle = 1net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_mem = 94500000 915000000 927000000net.ipv4.tcp_max_orphans = 3276800net.ipv4.ip_local_port_range = 1024 65535EOFsysctl -p}sshd_config(){ if [ ! -f &quot;/root/.ssh/id_rsa.pub&quot; ]; then ssh-keygen -t rsa -P '' -f /root/.ssh/id_rsa cat /root/.ssh/id_rsa.pub &gt;&gt; /root/.ssh/authorized_keys chmod 600 /root/.ssh/authorized_keys fi #sed -i '/^#Port/s/#Port 22/Port 65535/g' /etc/ssh/sshd_config sed -i '/^#UseDNS/s/#UseDNS no/UseDNS yes/g' /etc/ssh/sshd_config #sed -i 's/#PermitRootLogin yes/PermitRootLogin no/g' /etc/ssh/sshd_config sed -i 's/#PermitEmptyPasswords yes/PermitEmptyPasswords no/g' /etc/ssh/sshd_config sed -i 's/PasswordAuthentication yes/PasswordAuthentication no/g' /etc/ssh/sshd_config /etc/init.d/sshd restart}time_config(){ #timezone echo &quot;TZ='Asia/Shanghai'; export TZ&quot; &gt;&gt; /etc/profile # Update time if [! -f &quot;/usr/sbin/ntpdate&quot;]; then yum -y install ntpdate fi /usr/sbin/ntpdate pool.ntp.org echo &quot;30 3 * * * root (/usr/sbin/ntpdate pool.ntp.org &amp;&amp; /sbin/hwclock -w) &amp;&gt; /dev/null&quot; &gt;&gt; /etc/crontab /sbin/service crond restart}iptables(){cat &gt; /etc/sysconfig/iptables &lt;&lt; EOF# Firewall configuration written by system-config-securitylevel# Manual customization of this file is not recommended.*filter:INPUT DROP [0:0]:FORWARD ACCEPT [0:0]:OUTPUT ACCEPT [0:0]:syn-flood - [0:0]-A INPUT -i lo -j ACCEPT-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPT-A INPUT -p icmp -m limit --limit 100/sec --limit-burst 100 -j ACCEPT-A INPUT -p icmp -m limit --limit 1/s --limit-burst 10 -j ACCEPT-A INPUT -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -j syn-flood-A INPUT -j REJECT --reject-with icmp-host-prohibited-A syn-flood -p tcp -m limit --limit 3/sec --limit-burst 6 -j RETURN-A syn-flood -j REJECT --reject-with icmp-port-unreachableCOMMITEOF/sbin/service iptables restartsource /etc/profile}other(){ # initdefault sed -i 's/^id:.*$/id:3:initdefault:/' /etc/inittab /sbin/init q # PS1 #echo 'PS1=&quot;\\[\\e[32m\\][\\[\\e[35m\\]\\u\\[\\e[m\\]@\\[\\e[36m\\]\\h \\[\\e[31m\\]\\w\\[\\e[32m\\]]\\[\\e[36m\\]$\\[\\e[m\\]&quot;' &gt;&gt; /etc/profile # Wrong password five times locked 180s sed -i '4a auth required pam_tally2.so deny=5 unlock_time=180' /etc/pam.d/system-auth}vsftpd_setup(){ yum -y install vsftpd mv /etc/vsftpd/vsftpd.conf /etc/vsftpd/vsftpd.conf.bak touch /etc/vsftpd/chroot_list setsebool -P ftp_home_dir=1cat &gt;&gt; /etc/vsftpd/vsftpd.conf &lt;&lt;EOF# normal user settingslocal_enable=YESwrite_enable=YESlocal_umask=022chroot_local_user=YESchroot_list_enable=YESchroot_list_file=/etc/vsftpd/chroot_listlocal_max_rate=10000000# anonymous settingsanonymous_enable=YESno_anon_password=YESanon_max_rate=1000000data_connection_timeout=60idle_session_timeout=600# ssl settings#ssl_enable=YES #allow_anon_ssl=NO #force_local_data_ssl=YES #force_local_logins_ssl=YES #ssl_tlsv1=YES #ssl_sslv2=NO#ssl_sslv3=NO#rsa_cert_file=/etc/vsftpd/vsftpd.pem # server settingsmax_clients=50max_per_ip=5use_localtime=YESdirmessage_enable=YESxferlog_enable=YESconnect_from_port_20=YESxferlog_std_format=YESlisten=YESpam_service_name=vsftpdtcp_wrappers=YES#banner_file=/etc/vsftpd/welcome.txtdual_log_enable=YESpasv_min_port=65400pasv_max_port=65410EOF chkconfig --level 3 vsftpd on service vsftpd restart} main(){ precheck printf &quot;\\033[32m================%40s================\\033[0m\\n&quot; &quot;updating the system &quot; yum_update printf &quot;\\033[32m================%40s================\\033[0m\\n&quot; &quot;re-config permission &quot; permission_config printf &quot;\\033[32m================%40s================\\033[0m\\n&quot; &quot;enabling selinux &quot; selinux printf &quot;\\033[32m================%40s================\\033[0m\\n&quot; &quot;stopping irrelevant services &quot; stop_services printf &quot;\\033[32m================%40s================\\033[0m\\n&quot; &quot;/etc/security/limits.config &quot; limits_config printf &quot;\\033[32m================%40s================\\033[0m\\n&quot; &quot;/etc/sysctl.conf &quot; sysctl_config printf &quot;\\033[32m================%40s================\\033[0m\\n&quot; &quot;sshd re-configuring &quot; sshd_config printf &quot;\\033[32m================%40s================\\033[0m\\n&quot; &quot;configuring time &quot; time_config printf &quot;\\033[32m================%40s================\\033[0m\\n&quot; &quot;configuring firewall &quot;# iptables printf &quot;\\033[32m================%40s================\\033[0m\\n&quot; &quot;someother stuff &quot; other printf &quot;\\033[32m================%40s================\\033[0m\\n&quot; &quot;done! rebooting &quot; touch &quot;$flagFile&quot; sleep 5 reboot}main","link":"/2016/01/06/Linux%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E7%BB%93/"},{"title":"Linux自定义命令","text":"很多常用的命令，很长的路径输出很麻烦，用户可利用alias，自定指令的别名。 可以利用 alias 来解决 语 法：alias[别名]=[指令名称] 补充说明：若仅输入alias，则可列出目前所有的别名设置。alias的效力仅及于该次登入的操作。若要每次登入是即自动设好别名，可在/etc/profile或自己的~/.bashrc中设定指令的别名。 bashrc是环境变量的配置文件 /etc/bashrc和~/.bashrc 区别就在于 /etc/bashrc 是设置给全系统 ~/.bashrc 是设置给单用户使用. 有的系统里没有ll这个命令,原因就是没有定义ll=’ls -l –color=tty’这个别名. 如果想永久生效,就把这条写入到 /etc/bashrc里面 修改后，通过以下命令即可生效： 1234#全局配置source /etc/bashrc#个人配置source .bashrc","link":"/2017/03/23/Linux%E8%87%AA%E5%AE%9A%E4%B9%89%E5%91%BD%E4%BB%A4/"},{"title":"Linux防火墙的关闭","text":"在连接MySQL中，遇到ERROR 2002 (HY000): mysql这个其实是Linux防火墙的阻拦 解决办法就是关闭防火墙即可。 步骤如下： 立即关闭：service iptables stop 永久关闭：iptables -F 禁止启动：chkconfig iptables off 另外，运行 setup 在界面，选择Firewall configuration，进入下一界面，选择 Security Level为Disabled，保存。","link":"/2016/12/02/Linux%E9%98%B2%E7%81%AB%E5%A2%99%E7%9A%84%E5%85%B3%E9%97%AD/"},{"title":"Linux虚拟机分辨率设置","text":"虚拟机中的Ubuntu16.04启动时自动设置分辨率1920x1080​ vmware不能自动适应Ubuntu16.04的分辨率，而且Ubuntu16.04的display设置中也没有1920x1080的分辨率，因此需要通过修改/etc/profile文件文件来实现登录时自动设置分辨率为1920x1080。 ​ 步骤如下： 打开Terminal终端 输入如下命令cvt 1920 1080，得到结果1920x108059.96 Hz(CVT 2.07M9) hsync:67.16kHz; pclk: 173.00 MHz Modeline &quot;1920x1080_60.00&quot; 173.00 1920 2048 2248 2576 1080 1083 10881120 -hsync +vsync 再输入xrandr结果中有显示器的名称 再输入sudo xrandr --newmode &quot;1920x1080_60.00&quot; 173.00 1920 2048 2248 2576 1080 1083 1088 1120 -hsync +vsync 和sudo xrandr --addmode Virtual-0 &quot;1920x1080_60.00&quot; 找到system setting &gt; display, 在resolution列表下可以看到1920x1080的选项，勾选并apply 完成之后保存退出","link":"/2016/10/24/Linux%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%88%86%E8%BE%A8%E7%8E%87%E8%AE%BE%E7%BD%AE/"},{"title":"GitHub不再支持密码验证的解决方案","text":"最近在重新弄了Hexo之后，提交文件出现了错误提示： remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead. 查了下官方的说明： Git password authentication is shutting down 所以就是SSH的密码验证不再支持，需使用 personal access token 替代。 操作方法如下： 打开GitHub主页，点击头像找到Settings 在左边目录栏找到Personal access tokens，点击Generate new token，按照步骤申请 Scopes那里可以全选 在mac上打开keychain access，搜索GitHub，输入刚刚的Token 执行以下命令 1$ git remote add origin https://“刚刚得到的Token“@github.com/“User名”/“仓库名（XXX.github.io）”.git 修改Hexo的 config.yml配置文件 1234deploy: type: git repo: https://&quot;Token&quot;@github.com/“用户名”/“仓库名（XXX.github.io）”.git branch: master","link":"/2021/11/30/GitHub%E4%B8%8D%E5%86%8D%E6%94%AF%E6%8C%81%E5%AF%86%E7%A0%81%E9%AA%8C%E8%AF%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"title":"Open GApps 的不同版本","text":"虽然现在刷机的人群比之前少了很多，但是由于各种原因还是需要刷机的。 其中绝大部分还是需要GMS的服务，也就有了opengapps，但是官网有各种版本，每个版本的还是有区别。 OpenGApps有几个不同的版本，super、stock、full、mini、micro、nano、pico，很多人不知道差别是什么，这里说明一下 Aroma 与 super 版所包含的 GApps 相同，但是在 Recovery 中引入了图形化界面，可以自行选择安装哪些 GApps super 包含了所有 GApps ，像韩语日语中文拼音中文注音输入法等。（请注意：如果你是用的是基于原生的 ROM ，本版本会替换相机，通讯录等等所有有关应用）。体积1G左右，如果System分区剩余空间不够，就会刷入失败。 stock 类似于 Google Pixel 出厂内置的 GApps ，相比 super 版少了其他语种的输入法以及 Google 地球等。（请注意：如果你是用的是基于原生的 ROM ，本版本会替换相机，通讯录等等所有有关应用）。体积820M~840M左右，如果System分区剩余空间不够，就会刷入失败。 full 与 stock 版所包含的内容相同，但此版本不会替换手机原本的应用。体积670~690M左右，如果System分区剩余空间不够，就会刷入失败。 mini 包含基础的 Google 服务框架，以及一些影响力较大的 GApps ，相比 full 版去掉了 Docs 等应用。体积370M~390M左右，如果System分区剩余空间不够，就会刷入失败。 micro 包含基础的 Google 服务框架和 Gmail 等常见 GApps。体积190~210M左右，如果System分区剩余空间不够，就会刷入失败。 nano 包含基础的 Google 服务框架，但不会有其他 不必要的 GApps。体积160M~180M左右，如果System分区剩余空间不够，就会刷入失败。 pico 包含最迷你的 Google 服务框架，但由于框架并非完整，部分 GApps 可能无法运行。体积110~120M左右，如果System分区剩余空间不够，就会刷入失败。 以上关于体积的描述，指的是arm64设备。第三方原生ROM的System空间会更大一点，但仍需谨慎选择Super、Stock和full版本版本。因此，选择谷歌服务包的版本不能任性，要量力而为。","link":"/2020/09/13/Open-GApps-%E7%9A%84%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC/"},{"title":"MUT和MSS的关系","text":"TCP层的分段和IP层的分片之间的关系 数据报的分段和分片确实发生，分段发生在传输层，分片发生在网络层。但是对于分段来说，这是经常发生在UDP传输层协议上的情况，对于传输层使用TCP协议的通道来说，这种事情很少发生。1. MTU（Maximum Transmission Unit，MTU），最大传输单元（1）以太网和802.3对数据帧的长度都有一个限制，其最大 值分别是1500和1492个字节。链路层的这个特性称作MTU。不同类型的网络大多数都有一个上限。如果IP层有一个数据要传，且数据的长度比链路层的 MTU还大，那么IP层就要进行分片（fragmentation），把数据报分成若干片，这样每一个分片都小于MTU。 （2）把一份IP数据报进行分片以后，由到达目的端的IP层来进行重新组装，其目的是使分片和重新组装过程对运输层（TCP/UDP）是透明的。由于每一分片都是一个独立的包，当这些数据报的片到达目的端时有可能会失序，但是在IP首部中有足够的信息让接收端能正确组装这些数据报片。 （3）尽管IP分片过程看起来透明的，但有一点让人不想使用它：即使只丢失一片数据也要重新传整个数据报。why？因为IP层本身没有超时重传机制——由更高层（比如TCP）来负责超时和重传。当来自TCP报文段的某一片丢失后，TCP在超时后会重发整个TCP报文段，该报文段对应于一份IP数据报（而不是一个分片），没有办法只重传数据报中的一个数据分片。 （4）使用UDP很容易导致IP分片，TCP试图避免IP分片。 那么TCP是如何试图避免IP分片的呢？其实说白了，采用TCP协议进行数据传输是不会造成IP分片的，因为一旦TCP数据过大，超过了MSS，则在传输 层会对TCP包进行分段（如何分，见下文！），自然到了IP层的数据报肯定不会超过MTU，当然也就不用分片了。而对于UDP数据报，如果UDP组成的 IP数据报长度超过了1500，那么IP数据报显然就要进行分片，因为UDP不能像TCP一样自己进行分段。总结：UDP不会分段，就由我IP来分。TCP会分段，当然也就不用我IP来分了！ 2. MSS（Maxitum Segment Size）最大分段大小的缩写，是TCP协议里面的一个概念（1）MSS就是TCP数据包每次能够传输的最大数据分段。为了达到最佳的传输效能TCP协议在建立连接的时候通常要协商双方的MSS值，这个值TCP协议在实现的时候往往用MTU值代替（需要减去IP数据包包头的大小20Bytes和TCP数据段的包头20Bytes）所以往往MSS为1460。通讯双方会根据双方提供的MSS值得最小值确定为这次连接的最大MSS值。（2）相信看到这里，还有最后一个问题：TCP是如何实现分段的呢？其实TCP无所谓分段，因为每个TCP数据报在组成前其大小就已经被MSS限制了，所以TCP数据报的长度是不可能大于MSS的，当然由它形成的IP包的长度也就不会大于MTU，自然也就不用IP分片了。 3. 结论 1.IP分片产生的原因是网络层的MTU；TCP分段产生原因是MSS. 2.IP分片由网络层完成，也在网络层进行重组；TCP分段是在传输层完成，并在传输层进行重组. //透明性 3.对于以太网，MSS为1460字节，而MUT往往会大于MSS. 故采用TCP协议进行数据传输，是不会造成IP分片的。若数据过大，只会在传输层进行数据分段，到了IP层就不用分片。 所以可以看成是这种情况：传输层协议想发送一个超过了MTI的数据报，这个时候网络层就需要对其进行分片，一般UDP和ICMP会出现分片情况，但是TCP不会出现这种情况！因为TCP使用了MSS来避免分片！ IP分片只有第一个带有传输层或ICMP首部，其余的分片只有IP头。至于怎么重组就是到对端以后IP层的事情了。若TCP报文非常长那么在IP层传输时就有可能要分解成多个短数据报片。（计算机网络谢希仁）TCP分段每个都有完整首部。PS:所以我觉得是这样的，TCP的分段是针对应用层的数据来说的，比如使用TCP发送70KB的数据，这个时候就需要将70KB分成若干个MSS，到了网络层就不需要分片了。MSS的存在就避免了网络层分片的发生， IP层的分片是针对传输层中使用UDP协议来说的，如果使用UDP发送数据，UDP并不知道如何分段，那么到了IP层就需要进行分片，分片的原则根据MTU，那么分UDP最大的数据负载就是1500-8=1492 转载自： TCP层的分段和IP层的分片之间的关系 &amp; MTU和MSS之间的关系","link":"/2016/08/09/MUT%E5%92%8CMSS%E7%9A%84%E5%85%B3%E7%B3%BB/"},{"title":"Mac使用 Git和 Github 连接","text":"记录整理下怎么在 MacBook 上使用 Git 连接 Github。 Git 的安装有几个方式： 源码安装： Git 官网下载地址 for Mac XCode自带： XCode 自带 Git 程序，但是因为权限问题，不建议使用。 Homebrew 安装： 这个是最简便的方式，如果 MacBook 安装了 Homebrew，那么安装 Git 就一个命令 1$ brew install git ​ 创建 SSH KEY 按照提示输入以下信息： 12345678910111213141516171819 $ ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot; #记得输入你的github账号的邮箱 #会输出下面语句 $ Generating public/private rsa key pair. Enter file in which to save thekeys (/Users/your_user_directory/.ssh/id_rsa): # 这里需要按下 enter 键就好 #按下 enter 之后，又会出现下面的提示：#输入回车后提示输入一个类似于密码的自定义的通行证号，如果直接回车则为空$Enter passphrase(empty for no passphrase):#提示重新输入以便确认输入是否正确$Enter same passphraseagain:#随后，你会收到一大串的提示，大概的意思是告诉你创建好了 id_rsa 和 id_rsa.pub 文件。 在 Github 上添加 SSH KEY 在Github中添加ssh（如图示）： 登陆Github，选择Account Settings–&gt;SSH Keys 添加ssh Title：xxxxx@xxxx.com Key：打开你生成的id_rsa.pub文件，将其中内容拷贝至此。创建成功会有相应的提示。 验证连接 1$ ssh -T git@github.com 第一次会出现这个信息： 123The authenticity of host 'github.com (207.97.227.239)' can't be established. RSA key fingerprint is XXXXXXXXX Are you sure you want to continue connecting (yes/no)? 输入 yes： 1Hi username! You've successfully authenticated, but GitHub does not provide shell access. 配置个人信息 设置本地 Git 的个人信息，来方便Git 进行 commit 的追踪管理 12$git config --global user.name &quot;your real name&quot;$git config --global user.email &quot;xxxxx@gmail.com&quot;","link":"/2017/06/28/Mac%E4%BD%BF%E7%94%A8-Git%E5%92%8C-Github-%E8%BF%9E%E6%8E%A5/"},{"title":"Pyhton 去掉字符串前边的u","text":"在用json.load导入json 格式的文件的时候, 打印出来的dict, 会显示的是unicode 编码形式, 下面一种方法可以利用检测编码的形式把u去掉. 1234567891011for i in range(len(colnames)): print type(rowData[i]) if type(rowData[i]) == float :#如果是字符串类型，则进行编码 print colnames[i] eachRowData[colnames[i].encode('ascii')] = rowData[i] #.encode('raw_unicode_escape') elif type(rowData[i]) == unicode: eachRowData[colnames[i].encode('ascii')] = rowData[i].encode('ascii')list.append(eachRowData)","link":"/2018/04/08/Pyhton-%E5%8E%BB%E6%8E%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%89%8D%E8%BE%B9%E7%9A%84u/"},{"title":"No toolchains found in the NDK toolchains folder for ABI with prefix:mips64el-linux-android","text":"在使用Android Studio编译Demo的时候, 提示No toolchains found in the NDK toolchains folder for ABI with prefix: mips64el-linux-android错误 这个其实是Android的SDK里面缺少一个编译工具 解决办法: 从NDK下载对应平台的NDK 解压, 找到ndk-bundle成长文件夹, 找到toolchains下的mips类似的文件夹 最后把上面的文件夹复制到对应SDK的android-sdk-&gt;ndk-bundle-&gt;toolchains 下面.","link":"/2019/01/10/No-toolchains-found-in-the-NDK-toolchains-folder-for-ABI-with-prefix-mips64el-linux-android/"},{"title":"Pyhton标准模块logging","text":"GetLoggerGetLogger() returns a reference to a logger instance with the specified name if it is provided, or root if not. The names are period-separated hierarchical structures. Multiple calls to getLogger() with the same name will return a reference to the same logger object. 后面会看到这种以’.’分隔的hierarchical structures有什么用.FormatterFormatter对象定义了最终log信息的顺序,结构和内容.Handler这儿用到了StreamHandler和FileHandler, 用于向不同的输出端打log.SetLevelLogging有如下级别: DEBUG，INFO，WARNING，ERROR，CRITICAL默认级别是WARNING, logging模块只会输出指定level以上的log这样的好处, 就是在项目开发时debug用的log, 在产品release阶段不用一一注释, 只需要调整logger的级别就可以了, 很方便的. FormatterFormatter对象定义了最终log信息的顺序,结构和内容.于基本的logging.Handler类不同,应用可以直接实例化formatter类,当然,如果需要你也可以子例化formatter以便定制它的一些行为.构造函数接受两个可选参数:一个信息格式字符串和一个日期格式字符串.如果没有信息格式字符串,直接输出log信息.如果没有日期格式字符串,默认的格式是:%Y-%m-%d %H:%M:%S 12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/python #coding:utf-8 import logging import time def log(error_msg): #获取时间 fm = '%Y-%m-%d %H:%M:%S' YMD = time.strftime(fm,time.localtime()) #设置文件的存储路径,及文件 save_log_file = 'error.log' # 第一步创建一个logger的句柄 logger = logging.getLogger('error') #创建一个处理写入日志文件的handler,参数保存的&quot;日志文件 handler = logging.FileHandler(save_log_file) #设置日志输出的格式 formatter = logging.Formatter(&quot;%(asctime)s-%(levelname)s-%(message)s&quot;) handler.setFormatter(formatter) #将处理文件的的handler假如到logger中去 logger.addHandler(handler) # Logging有如下级别: DEBUG，INFO，WARNING，ERROR，CRITICAL # 默认级别是WARNING, logging模块只会输出指定level以上的log # 这样的好处, 就是在项目开发时debug用的log, 在产品release阶段不用一一注释, # 只需要调整logger的级别就可以了, 很方便的. logger.setLevel(logging.INFO) #写入日志 logger.info(error_msg) #其他的写入方法 logger.debug(error_msg) logger.warn(error_msg) logger.error(error_msg) logger.critical(error_msg) logger.removeHandler(handler) if __name__ == '__main__': log_info = '传入日志信息' log(log_info)","link":"/2016/08/16/Pyhton%E6%A0%87%E5%87%86%E6%A8%A1%E5%9D%97logging/"},{"title":"Pyhton 显示时间","text":"Python显示当前时间可以用Pyhton提供的time模块来实现 12import timeprint time.time() 输出的结果是:1470817592.43 但是这样是一连串的数字不是我们想要的结果，我们可以利用time模块的格式化时间的方法来处理: time.localtime(time.time()) 用time.localtime()方法，作用是格式化时间戳为本地的时间。输出的结果是： time.struct_time(tm_year=2016, tm_mon=8, tm_mday=10, tm_hour=16, tm_min=28, tm_sec=2, tm_wday=2, tm_yday=223, tm_isdst=0) 现在看起来更有希望格式成我们想要的时间了。 time.strftime('%Y-%m-%d',time.localtime(time.time())) 最后用time.strftime()方法，把刚才的一大串信息格式化成我们想要的东西，现在的结果是： '2016-08-10' time.strftime里面有很多参数，可以让你能够更随意的输出自己想要的东西：下面是time.strftime的参数：strftime(format[, tuple]) -&gt; string将指定的struct_time(默认为当前时间)，根据指定的格式化字符串输出 Python中时间日期格式化符号： %y 两位数的年份表示（00-99） %Y 四位数的年份表示（000-9999） %m 月份（01-12） %d 月内中的一天（0-31） %H 24小时制小时数（0-23） %I 12小时制小时数（01-12） %M 分钟数（00=59） %S 秒（00-59） %a 本地简化星期名称 %A 本地完整星期名称 %b 本地简化的月份名称 %B 本地完整的月份名称 %c 本地相应的日期表示和时间表示 %j 年内的一天（001-366） %p 本地A.M.或P.M.的等价符 %U 一年中的星期数（00-53）星期天为星期的开始 %w 星期（0-6），星期天为星期的开始 %W 一年中的星期数（00-53）星期一为星期的开始 %x 本地相应的日期表示 %X 本地相应的时间表示 %Z 当前时区的名称 %% %号本身","link":"/2016/08/10/Pyhton-%E6%98%BE%E7%A4%BA%E6%97%B6%E9%97%B4/"},{"title":"Pyhton的文件操作","text":"​ 最近搞处理文件，各种命令搞的头晕眼花，此处做个合并，以便之后观察使用。 1.重命名：os.rename(old, new)2.删除：os.remove(file)3.列出目录下的文件 ：os.listdir(path)4.获取当前工作目录：os.getcwd()5.改变工作目录：os.chdir(newdir)6.创建多级目录：os.makedirs(r&quot;c:\\python \\test&quot;)7.创建单个目录：os.mkdir(&quot;test&quot;)8.删除多个目录：os.removedirs(r&quot;c:\\python&quot;) #删除所给路径最后一个目录下所有空目录。也可用shutil.rmtree()9.删除单个目录：os.rmdir(&quot;test&quot;)10.获取文件属性：os.stat(file)11.修改文件权限与时间戳：os.chmod(file)12.执行操作系统命令：os.system(&quot;dir&quot;)13.启动新进程：os.exec(), os.execvp()14.在后台执行程序：osspawnv()15.终止当前进程：os.exit(), os._exit()16.分离文件名：os.path.split(r&quot;c:\\python\\hello.py&quot;) --&gt; (&quot;c:\\\\python&quot;, &quot;hello.py&quot;)17.分离扩展名：os.path.splitext(r&quot;c:\\python\\hello.py&quot;) --&gt; (&quot;c:\\\\python\\\\hello&quot;, &quot;.py&quot;)18.获取路径名：os.path.dirname(r&quot;c:\\python\\hello.py&quot;) --&gt; &quot;c:\\\\python&quot;19.获取文件名：os.path.basename(r&quot;r:\\python\\hello.py&quot;) --&gt; &quot;hello.py&quot;20.判断文件或目录是否存在：os.path.exists(r&quot;c:\\python\\hello.py&quot;) --&gt; True21.判断是否是绝对路径：os.path.isabs(r&quot;.\\python\\&quot;) --&gt; False22.判断是否是目录：os.path.isdir(r&quot;c:\\python&quot;) --&gt; True23.判断是否是文件：os.path.isfile(r&quot;c:\\python\\hello.py&quot;) --&gt; True24.判断是否是链接文件：os.path.islink(r&quot;c:\\python\\hello.py&quot;) --&gt; False25.获取文件大小：os.path.getsize(filename)26.搜索目录下的所有文件：os.path.walk()","link":"/2017/01/12/Pyhton%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"title":"Pyhton遍历文件夹","text":"这是一个常用的功能，可以有两种方法，os.walk和os.listdir 文档是这么解释的： os.listdir(path) Return a list containing the names of the entries in the directory given by path. The list is in arbitrary order. It does not include the special entries ‘.’ and ‘..’ even if they are present in the directory. os.walk(top, topdown=True, onerror=None, followlinks=False) Generate the file names in a directory tree by walking the tree either top-down or bottom-up. For each directory in the tree rooted at directory top (including top itself), it yields a 3-tuple (dirpath, dirnames, filenames). 代码如下： 123456789# -*- coding: utf-8 -*- import os def list_dir(rootDir): list_dirs = os.walk(rootDir) for root, dirs, files in list_dirs: for d in dirs: print os.path.join(root, d) for f in files: print os.path.join(root, f) 12345678# -*- coding: utf-8 -*- import os def list_dir(rootDir): for lists in os.listdir(rootDir): path = os.path.join(rootDir, lists) print path if os.path.isdir(path): list_dir(path) 对于第一种方法，输出总是先文件夹后文件名的，对于第二种，则是按照目录树结构以及按照首字母排序进行输出的。","link":"/2017/03/10/Pyhton%E9%81%8D%E5%8E%86%E6%96%87%E4%BB%B6%E5%A4%B9/"},{"title":"Python ConfigParser模块常用方法示例","text":"在程序中使用配置文件来灵活的配置一些参数是一件很常见的事情，配置文件的解析并不复杂，在Python里更是如此，在官方发布的库中就包含有做这件事情的库，那就是ConfigParser，这里简单的做一些介绍。 Python ConfigParser模块解析的配置文件的格式比较象ini的配置文件格式，就是文件中由多个section构成，每个section下又有多个配置项. 12345678[db] db_host=192.168.1.1 db_port=3306 db_user=root db_pass=password [concurrent] thread=200 processor=400 假设上面的配置文件的名字为test.conf。里面包含两个section,一个是db, 另一个是concurrent, db里面还包含有4项，concurrent里面有两项。这里来做做解析： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#-*- encoding: utf-8 -*- import ConfigParser,string,os,sys cf = ConfigParser.ConfigParser() cf.read(&quot;test.conf&quot;) # 返回所有的section s = cf.sections() print 'section:', s o = cf.options(&quot;db&quot;) print 'options:', o v = cf.items(&quot;db&quot;) print 'db:', v print '-'*60 #可以按照类型读取出来 db_host = cf.get(&quot;db&quot;, &quot;db_host&quot;) db_port = cf.getint(&quot;db&quot;, &quot;db_port&quot;) db_user = cf.get(&quot;db&quot;, &quot;db_user&quot;) db_pass = cf.get(&quot;db&quot;, &quot;db_pass&quot;) # 返回的是整型的 threads = cf.getint(&quot;concurrent&quot;, &quot;thread&quot;) processors = cf.getint(&quot;concurrent&quot;, &quot;processor&quot;) print &quot;db_host:&quot;, db_host print &quot;db_port:&quot;, db_port print &quot;db_user:&quot;, db_user print &quot;db_pass:&quot;, db_pass print &quot;thread:&quot;, threads print &quot;processor:&quot;, processors #修改一个值，再写回去 cf.set(&quot;db&quot;, &quot;db_pass&quot;, &quot;zhaowei&quot;) cf.write(open(&quot;test.conf&quot;, &quot;w&quot;)) #添加一个section。（同样要写回） cf.add_section('liuqing') cf.set('liuqing', 'int', '15') cf.set('liuqing', 'bool', 'true') cf.set('liuqing', 'float', '3.1415') cf.set('liuqing', 'baz', 'fun') cf.set('liuqing', 'bar', 'Python') cf.set('liuqing', 'foo', '%(bar)s is %(baz)s!') cf.write(open(&quot;test.conf&quot;, &quot;w&quot;)) #移除section 或者option 。（只要进行了修改就要写回的哦） cf.remove_option('liuqing','int') cf.remove_section('liuqing') cf.write(open(&quot;test.conf&quot;, &quot;w&quot;))","link":"/2017/10/30/Python-ConfigParser%E6%A8%A1%E5%9D%97%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E7%A4%BA%E4%BE%8B/"},{"title":"Python OS文件操作模块常用函数","text":"Python提供了一个os模块，里面包含了很多操作文件和目录的函数全部函数可以用help(os)或是dir(os)查看其用法。 1.重命名：os.rename(old, new) 2.删除：os.remove(file) 3.列出目录下的文件 ：os.listdir(path) 4.获取当前工作目录：os.getcwd() 5.改变工作目录：os.chdir(newdir) 6.创建多级目录：os.makedirs(r&quot;c:\\python \\test&quot;) 7.创建单个目录：os.mkdir(&quot;test&quot;) 8.删除多个目录：os.removedirs(r&quot;c:\\python&quot;) #删除所给路径最后一个目录下所有空目录。 9.删除单个目录：os.rmdir(&quot;test&quot;) 10.获取文件属性：os.stat(file) 11.修改文件权限与时间戳：os.chmod(file) 12.执行操作系统命令：os.system(&quot;dir&quot;) 13.启动新进程：os.exec(), `os.execvp() 14.在后台执行程序：osspawnv() 15.终止当前进程：os.exit(), os._exit() 16.分离文件名：os.path.split(r&quot;c:\\python\\hello.py&quot;) –&gt; (&quot;c:\\\\python&quot;, &quot;hello.py&quot;) 17.分离扩展名：os.path.splitext(r&quot;c:\\python\\hello.py&quot;) –&gt; (&quot;c:\\\\python\\\\hello&quot;, &quot;.py&quot;) 18.获取路径名：os.path.dirname(r&quot;c:\\python\\hello.py&quot;) –&gt; &quot;c:\\\\python&quot; 19.获取文件名：os.path.basename(r&quot;r:\\python\\hello.py&quot;) –&gt; &quot;hello.py&quot; 20.判断文件或目录是否存在：os.path.exists(r&quot;c:\\python\\hello.py&quot;) –&gt; True 21.判断是否是绝对路径：os.path.isabs(r&quot;.\\python\\&quot;) –&gt; False 22.判断是否是目录：os.path.isdir(r&quot;c:\\python&quot;) –&gt; True 23.判断是否是文件：os.path.isfile(r&quot;c:\\python\\hello.py&quot;) –&gt; True 24.判断是否是链接文件：os.path.islink(r&quot;c:\\python\\hello.py&quot;) –&gt; False 25.获取文件大小：os.path.getsize(filename) 26.搜索目录下的所有文件：os.path.walk()","link":"/2017/04/12/Python-OS%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E6%A8%A1%E5%9D%97%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"title":"Python Pip 使用警告","text":"在macOS更新完pip(9.0.1)之后使用会出现如下警告： 1DEPRECATION: The default format will switch to columns in the future. You can use --format=(legacy|columns) (or define a format=(legacy|columns) in your pip.conf under the [list] section) to disable this warning. 虽然不影响使用，但是还是要解决。方法如下： 虽然不影响使用，但是还是要解决。方法如下： 1234cd ~mkdir .pipcd .pip/vi pip.conf 接着在 vim 编辑 12[list]format=columns 最后进行保存， 再次使用pip list，会发现效果如下。 至于 Windows 也依旧类似。 在C:\\Users\\Administrator下建立pip文件夹，在pip下新建pip.ini： 内容为： 12[list]format=columns","link":"/2017/05/17/Python-Pip-%E4%BD%BF%E7%94%A8%E8%AD%A6%E5%91%8A/"},{"title":"Python 两个list 求交集，并集，差集","text":"在python中，分别求两个list 的交集，并集与差集，怎么实现比较方便呢？除了两个for 循环, 还有其余的更方便的方法 12345678910111213141516171819202122232425262728293031#!/usr/bin/python#coding:utf-8def diff(listA,listB): #求交集的两种方式 retA = [i for i in listA if i in listB] retB = list(set(listA).intersection(set(listB))) print &quot;retA is: &quot;,retA print &quot;retB is: &quot;,retB #求并集 retC = list(set(listA).union(set(listB))) print &quot;retC1 is: &quot;,retC #求差集 retD = list(set(listB).difference(set(listA)))+list(set(listA).difference(set(listA))) print &quot;retD is: &quot;,retD retD_new = list(set(listA)^set(listB)) retE = [i for i in listB if i not in listA] print &quot;retE is: &quot;,retEdef main(): listA = [1,2,3,4,5] listB = [3,4,5,6,7] diff(listA,listB)if __name__ == '__main__': main() 大体上是两种思路：1.使用列表解析式. 列表解析式一般来说比循环更快.2.将list转成set以后，使用set的各种方法去处理.","link":"/2018/09/14/Python-%E4%B8%A4%E4%B8%AAlist-%E6%B1%82%E4%BA%A4%E9%9B%86%EF%BC%8C%E5%B9%B6%E9%9B%86%EF%BC%8C%E5%B7%AE%E9%9B%86/"},{"title":"Python 两个列表合并","text":"有两个列表，分别为： 12names = ['Alice', 'Beth', 'Ceil']numbers = ['2341', '9102', '3158'] 生成一个字典： book = {'Alice': '2341', 'Beth': '9102', 'Ceil': '3158'} 有两种方法，一个是不断迭代，另外一种就是用zip函数 方法一： 123456book = {}i=0while i&lt;len(names): phonebook[names[i]]=numbers[i] i+=1print book 方法二： 12book = dict(zip(names, numbers))print phone","link":"/2017/03/20/Python-%E4%B8%A4%E4%B8%AA%E5%88%97%E8%A1%A8%E5%90%88%E5%B9%B6/"},{"title":"Python 字符串和常用数据结构","text":"Python中常用的字符串： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647def main(): str1 = 'hello, world!' # 通过len函数计算字符串的长度 print(len(str1)) # 13 # 获得字符串首字母大写的拷贝 print(str1.capitalize()) # Hello, world! # 获得字符串变大写后的拷贝 print(str1.upper()) # HELLO, WORLD! # 从字符串中查找子串所在位置 print(str1.find('or')) # 8 print(str1.find('shit')) # -1 # 与find类似但找不到子串时会引发异常 # print(str1.index('or')) # print(str1.index('shit')) # 检查字符串是否以指定的字符串开头 print(str1.startswith('He')) # False print(str1.startswith('hel')) # True # 检查字符串是否以指定的字符串结尾 print(str1.endswith('!')) # True # 将字符串以指定的宽度居中并在两侧填充指定的字符 print(str1.center(50, '*')) # 将字符串以指定的宽度靠右放置左侧填充指定的字符 print(str1.rjust(50, ' ')) str2 = 'abc123456' # 从字符串中取出指定位置的字符(下标运算) print(str2[2]) # c # 字符串切片(从指定的开始索引到指定的结束索引) print(str2[2:5]) # c12 print(str2[2:]) # c123456 print(str2[2::2]) # c246 print(str2[::2]) # ac246 print(str2[::-1]) # 654321cba print(str2[-3:-1]) # 45 # 检查字符串是否由数字构成 print(str2.isdigit()) # False # 检查字符串是否以字母构成 print(str2.isalpha()) # False # 检查字符串是否以数字和字母构成 print(str2.isalnum()) # True str3 = ' jackfrued@126.com ' print(str3) # 获得字符串修剪左右两侧空格的拷贝 print(str3.strip())if __name__ == '__main__': main()","link":"/2019/07/29/Python-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"title":"Python 使用 paramiko 模块实现 ssh 和 scp","text":"介绍 这篇文章简单地介绍了python的paramiko模块的用法，paramiko实现了SSH协议，能够方便地与远程计算机交互。简单的说，就是你在terminal下执行的如下语句，现在可以通过python的paramiko实现了。 12345# 执行shell语句ssh -i ~/.ssh/id_rsa -p 1098 rds@12.164.145.21 -e 'ls -al'# 拷贝数据到远程计算机scp -i ~/.ssh/id_rsa -P 1098 -r data rds@12.164.145.21:~/data 安装 1pip instal paramiko 建立SSH连接 使用密码连接： 123456import paramikossh = paramiko.SSHClient()#这行代码的作用是允许连接不在know_hosts文件中的主机。ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())ssh.connect(&quot;IP&quot;, port, &quot;username&quot;, &quot;password&quot;) 使用私钥连接： 12ssh = paramiko.SSHClient()ssh.connect('10.120.48.109', port, '用户名',key_filename='私钥') 连接以后可以执行shell命令： 12345In [8]: ssh.exec_command('ls')Out[8]:(&lt;paramiko.ChannelFile from &lt;paramiko.Channel 1 (open) window=2097152 -&gt; &lt;paramiko.Transport at 0x377c690L (cipher aes128-ctr, 128 bits) (active; 2 open channel(s))&gt;&gt;&gt;, &lt;paramiko.ChannelFile from &lt;paramiko.Channel 1 (open) window=2097152 -&gt; &lt;paramiko.Transport at 0x377c690L (cipher aes128-ctr, 128 bits) (active; 2 open channel(s))&gt;&gt;&gt;, &lt;paramiko.ChannelFile from &lt;paramiko.Channel 1 (open) window=2097152 -&gt; &lt;paramiko.Transport at 0x377c690L (cipher aes128-ctr, 128 bits) (active; 2 open channel(s))&gt;&gt;&gt;) 执行shell命令以后，并不会立即打印命令的执行结果，而是返回几个Channel, 只能像下面这样获取输出： 1234In [9]: stdin, stdout, stderr = ssh.exec_command('ls')In [10]: print stdout.readlines()['AgentBackkup_2015-06-11\\n', 'AgentBackup\\n', 'log\\n', 'mysql.sh\\n', 'rdsAgent\\n'] 注意： 命令执行出错并不会抛出异常，所以，对于命令出错需要根据自己的需求进行相应的处理： 12345678910In [54]: stdin, stdout, stderr = ssh.exec_command('cat file_not_found')In [55]: print stdout.readlines()[]In [56]: print stderr.readlines()[u'cat: file_not_found: No such file or directory\\n']In [57]: stdin, stdout, stderr = ssh.exec_command('ls')In [58]: print stderr.readlines()[] API文档 SCP vs SFTP 通过paramiko还可以传输文件，这是我写这篇博客的主要原因。搜了很多博客，都没有说明白如何通过paramiko在计算机之间传输文件，通过阅读官方文档，发现有如下两种方式： 12sftp = paramiko.SFTPClient.from_transport(ssh.get_transport())sftp = ssh.open_sftp() 即新建一个SFTPClient对象，该对象复用之前的SSH连接，因此，我们使用sftp传输文件时，不需要再次进行用户认证。 文件上传 12In [59]: sftp.put('memory.py', 'memory.py')Out[59]: &lt;SFTPAttributes: [ size=288 uid=1000 gid=1000 mode=0100644 atime=1435391914 mtime=1435391914 ]&gt; 文件下载 1In [60]: sftp.get('memory.py', 'backup.py') 执行命令 paramiko并没有提供一个叫做scp的子模块，如果我们希望在计算机之间传输数据，可以通过sftp(sftp实现了scp所有的功能，也就没有必再实现一个scp)传输文件，还可以通过sftp执行命令，如下所示： 12345678910111213141516171819In [44]: sftp.listdir()Out[44]:['.viminfo','.bash_logout','.bash_history','AgentBackkup_2015-06-10','AgentBackup','rdsAgent']In [45]: sftp.rename('AgentBackkup_2015-06-10', 'AgentBackkup_2015-06-11')In [46]: sftp.listdir()Out[46]:['AgentBackkup_2015-06-11','.viminfo','.bash_logout','.bash_history','AgentBackup','rdsAgent'] SFTP官方文档","link":"/2017/05/07/Python-%E4%BD%BF%E7%94%A8-paramiko-%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0-ssh-%E5%92%8C-scp/"},{"title":"Python 列出当前目录的文件和文件夹","text":"只获取当前目录的文件和文件夹 1234567list = os.listdir(rootdir)#列出目录下的所有文件和目录for line in list: filepath = os.path.join(rootdir,line) if os.path.isdir(filepath):#如果filepath是目录 print &quot;dir:&quot; + filepath else: print &quot;file:&quot; + filepath 如果需要遍历文件夹下的所以文件，可以使用os.walk()方法。 1234567os.walk()#返回一个三元素的tuple：当前路径、子文件夹名称、文件列表。import osfor root, dirs, files in os.walk(path): for filename in files: print filename for dirname in dirs: print dirname","link":"/2017/07/21/Python-%E5%88%97%E5%87%BA%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95%E7%9A%84%E6%96%87%E4%BB%B6%E5%92%8C%E6%96%87%E4%BB%B6%E5%A4%B9/"},{"title":"Python 字符编码","text":"字符串也是一种数据类型，但比较特殊的是字符串存在一个编码问题，也就是我们怎么用计算机来表示相应的字符并存储。在编程语言中，我们经常会处理文本编码之间的转化问题，因为文本可能存在不同的编码，比如 ASCII、GBK、UTF-8 等等。 如果希望正确的处理文本，就必须了解字符的抽象概念。我们可以认为字符表示的是文本中的单个符号。更重要的是，一个字符不是一个字节。比如，”中”在文本中是一个字符，但它存储在计算机中时却不是一个字节。一个字符有许多表示方法，不同的表示方法会使用不同的字节数，这就是所谓的编码。字符就是文本中最小的单元。 由于计算机是美国人发明的，因此，最早只有 127 个字母被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为 ASCII 编码。但是计算机被广泛应用之后，ASCII 编码已经不足以表示世界上的各种语言，于是后来便出现了 Unicode 编码。 Unicode 是一种编码规范， 用来统一表示世界上的各种语言。Unicode 只是规定如何编码，并没有规定如何传输和保存等等，因此 Unicode 编码有不同的实现方式，比如：UTF-8、UTF-16 。UTF-8 编码把一个 Unicode 字符根据不同的数字大小编码成 1-6 个字节，常用的英文字母被编码成 1 个字节，汉字通常是 3 个字节，只有很生僻的字符才会被编码成 4-6 个字节。Unicode 以大家都认可的方式定义了一系列的字符，可以将其理解成一个字符数据库，每个字符都与唯一的数字关联，称为 code point。这样，英文大写字母 A 的 codepoint 是 U+0041，而欧元符号的 codepoint 是 U+20A0。一个文本字符串就是一系列的 code point，表示字符串中每个字符元素。 Python 由荷兰人 Guido van Rossum 于 1989 年发明，第一个公开发行版发行于 1991 年。Guido 在设计之初并没有关心编码问题（当时他也不知道后来会出现编码问题）, 而且 Python 的诞生比 Unicode 标准发布的时间要早，因此 Python 默认编码在 Python3 之前是 ASCII。查看 Python 的默认编码: 123&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.getdefaultencoding()'ascii' 这么默认编码有什么用呢？如果你在 Python 中进行编码和解码的时候，不指定编码方式，那么 Python 就会使用 defaultencoding。 字符串在 Python 内部的表示是 Unicode 编码, 在 Python 内部使用两个字节来存储一个 Unicode。也就是 Python 在内存中统一使用 Unicode 编码存储字符数据，当需要保存到硬盘或者需要传输的时候，就转换为其他编码，比如 UTF-8。 在 Python2 中，字符串的类型有两种，即 str 和 unicode，他们都是 basestring 的子类。unicode 表示 Unicode 字符串（文本字符串），str 表示字节字符串（二进制数据），由 unicode 经过编码后的字节组成。也就是说： str 存储的是已经编码后的字节序列，输出时看到每个字节用 16 进制表示，以\\x开头。每个汉字会占用3个字节的长度。 unicode 是“字符”串，存储的是编码前的字符，输出是看到字符以\\u开头。每个汉字占用一个长度。定义一个 Unicode 对象时，以 u 开头。 在 Python 中 Unicode 被视为是一种中间码，如果要在不同的编码间进行转化，通常是先将字符串解码（decode）成 Unicode 编码，再从 Unicode 编码（encode）成另一种编码： decode: 的作用是将其他编码的字符串转换成 Unicode 编码，例如: name.decode(“GB2312”)，表示将 GB2312 编码的字符串 name 转换成 Unicode 编码 encode: 的作用是将 Unicode 编码转换成其他编码的字符串例如，例如: name.encode(”GB2312“)，表示 Unicode 编码的字符串 name 转换成 GB2312 编码 我们会在很多 Python 的源码文件的头部看到如下的声明： 1# coding:utf-8 这表示声明源代码中的文本编码为 UTF-8，也就是告诉 Python 解释器将文件中的文本视为 UTF-8 编码的字符串，因此声明的编码应该与文件的编码保持一致。在代码中我们通常会处理一些其他来源的文本，比如网络，它们的编码不一定也是 UTF-8 的，因此就要进行编码转换。 Python 试图在字节串和字符串之间以不为人所察觉的方式进行转化。在不同的转换中，在条件允许的情况下，Python 会试图在字节串和 unicode 字符串直接进行转换。例如将字节串和 unicode 字节串连接到一起时。但是不使用 encoding 就在不同类型之间进行转换是没有意义的。所以 Python 依赖一个 默认编码，该编码由 sys.setdefaultencoding() 指定。在大多数平台上，默认的是 ASCII 编码。但对于所有转换，使用这种编码几乎都是错误的。如果不手动指定编码就调用 str() 或 unicode() ，或是函数以字符串作为参数，但传递的是其他类型的参数时，都会使用这个默认编码。这就是很多时候出现 UnicodeEncodeError 和 UnicodeDecodeError 错误的原因，也就是字符串对象互相转化时没有指定字符编码。 例如，如果对 unicode 和 str 类型通过 + 拼接时，输出结果是 unicode 类型，相当于先将 str 类型的字符串通过 decode() 方法解码成 unicode 再拼接。此时如果解码时没有明确指明编码类型，可能会出现错误。 解决这个问题的一个办法是，调用 sys.setdefaultencoding() 将默认的编码设置为真正会用到的编码。但这样仅仅是将问题隐藏起来，虽然这样刚开始能解决一些文本处理问题。但缺乏实际可行性，因为许多应用，特别是网络应用，在不同的地方会使用不同的文本编码。 要注意的一点是，对 Unicode 进行编码和对 str 进行编码都是错误的。即不要对 str 使用 encode，不要对 unicode 使用 decode（事实上可以对 str 进行 encode 的，但不建议）。 下面是一些处理 Python 中字符编码的建议： 所有文本字符串都应该是 unicode 类型，而不是 str 类型。 若要将字节串解码成字符串，需要使用正确的解码，即 var.decode(encoding)，如： var.decode(‘utf-8’)；将文本字符串编码成字节，使用 var.encode(encoding)。 永远不要对 unicode 字符串使用 str() ，也不要在不指定编码的情况下就对字节串使用 unicode() 。 当应用从外部读取数据时，应将其视为字节串，即 str 类型的，接着调用 .decode() 将其解释成文本。同样，在将文本发送到外部时，总是对文本调用 .encode()。 对标准流进行操作时，可以改变环境变量 PYTHONIOENCODING 的值来设置标准流的默认编码， sys.stdin.encoding 和 sys.stdout.encoding 的值为期望的编码。 以上内容的讨论都仅限于 Python2，在 Python3 中已经修复了这些问题，可以正确的处理 unicode 和字符串。 来源： https://kuanghy.github.io/2016/10/14/python-encoding","link":"/2017/08/07/Python-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"title":"Python 格式化时间","text":"我们日常可能需要显示时间，在Python 中，一般可以使用自带的datetime模块。 基本语法如下： 12import datetimeprint(datetime.datetime.now()) 但是这个输出的是固定格式的微秒，在需要自定义的时候，还得格式化这个输出。 格式化参数：strftime 使用方法如下： 1datetime.datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) 剩下的其余参数如下： %y 两位数的年份表示 %Y 四位数的年份表示 %m 月份 %d 月内中的一天 %H 24小时制小时数 %I 12小时制小时数 %M 分钟数 %S 秒 %a 本地简化星期名称 %A 本地完整星期名称 %b 本地简化的月份名称 %B 本地完整的月份名称 %c 本地相应的日期表示和时间表示 %j 年内的一天 %p 本地A.M.或P.M.的等价符 %U 一年中的星期数星期天为星期的开始 %w 星期，星期天为星期的开始 %W 一年中的星期数星期一为星期的开始 %x 本地相应的日期表示 %X 本地相应的时间表示 %Z 当前时区的名称 %% %号本身","link":"/2020/03/11/Python-%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%B6%E9%97%B4/"},{"title":"Python 按行切割文件","text":"在遇到各种比较大的问题时候，行数过多导致打开处理会出问题，则需要切割，则可以用按行数切割的方法来处理。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#!/usr/bin/env python #--*-- coding:utf-8 --*-- import os class SplitFiles(): &quot;&quot;&quot;按行分割文件&quot;&quot;&quot; def __init__(self, file_name, line_count=200): &quot;&quot;&quot;初始化要分割的源文件名和分割后的文件行数&quot;&quot;&quot; self.file_name = file_name self.line_count = line_count def split_file(self): if self.file_name and os.path.exists(self.file_name): try: with open(self.file_name) as f : # 使用with读文件 temp_count = 0 temp_content = [] part_num = 1 for line in f: if temp_count &lt; self.line_count: temp_count += 1 else : self.write_file(part_num, temp_content) part_num += 1 temp_count = 1 temp_content = [] temp_content.append(line) else : # 正常结束循环后将剩余的内容写入新文件中 self.write_file(part_num, temp_content) except IOError as err: print(err) else: print(&quot;%s is not a validate file&quot; % self.file_name) def get_part_file_name(self, part_num): &quot;&quot;&quot;&quot;获取分割后的文件名称：在源文件相同目录下建立临时文件夹temp_part_file，然后将分割后的文件放到该路径下&quot;&quot;&quot; temp_path = os.path.dirname(self.file_name) # 获取文件的路径（不含文件名） part_file_name = temp_path + &quot;temp_part_file&quot; if not os.path.exists(temp_path) : # 如果临时目录不存在则创建 os.makedirs(temp_path) part_file_name += os.sep + &quot;temp_file_&quot; + str(part_num) + &quot;.part&quot; return part_file_name def write_file(self, part_num, *line_content): &quot;&quot;&quot;将按行分割后的内容写入相应的分割文件中&quot;&quot;&quot; part_file_name = self.get_part_file_name(part_num) print(line_content) try : with open(part_file_name, &quot;w&quot;) as part_file: part_file.writelines(line_content[0]) except IOError as err: print(err) if __name__ == &quot;__main__&quot;: sf = SplitFiles(r&quot;F:\\multiple_thread_read_file.txt&quot;) sf.split_file()","link":"/2017/03/13/Python-%E6%8C%89%E8%A1%8C%E5%88%87%E5%89%B2%E6%96%87%E4%BB%B6/"},{"title":"Python 读写CSV文档","text":"逗号分隔值（Comma-Separated Values，CSV，有时也称为字符分隔值，因为分隔字符也可以不是逗号），其文件以纯文本形式存储表格数据（数字和文本）。纯文本意味着该文件是一个字符序列，不含必须像二进制数字那样被解读的数据。CSV文件由任意数目的记录组成，记录间以某种换行符分隔；每条记录由字段组成，字段间的分隔符是其它字符或字符串，最常见的是逗号或制表符。通常，所有记录都有完全相同的字段序列。通常都是纯文本文件。建议使用WORDPAD或是记事本来开启，再则先另存新档后用EXCEL开启，也是方法之一。 直接创建CSV文件有两种通用的办法： 直接用Excel新建文件，保存为.csv格式的文件即可 用文本编辑器，例如Sublime Text新建文件，保存为.csv格式的文件即可 每一行的数据是由,分隔 Python 处理CSV文档读取CSV文档利用Python 的CSV 库来处理对应的文档 12345678910111213import csv# 读取文件至字典csv_file = open(&quot;test.csv&quot;, &quot;r&quot;)reader = csv.reader(csv_file)# 建立字典result = {}for item in reader: result[item[0]] = item[1]# 关闭文件csv_file.close()print(result) 每行数据会有一个属性：line_num表示行数 在遍历的时候，每一行就是一个list, 写入CSV文档要把数据写入CSV 的文件，可以直接把list格式的数据写入，但是需要注意的是要使用writerow，否者不会自动换行 12345678910111213141516171819import csv# 文件头，一般就是数据名fileHeader = [&quot;name&quot;, &quot;score&quot;]# 假设我们要写入的是以下两行数据d1 = [&quot;Wang&quot;, &quot;100&quot;]d2 = [&quot;Li&quot;, &quot;80&quot;]# 写入数据csv_file = open(&quot;test.csv&quot;, &quot;w&quot;)writer = csv.writer(csvFile)# 写入的内容都是以列表的形式传入函数writer.writerow(fileHeader)writer.writerow(d1)writer.writerow(d1)csv_file.close() 也可以直接使用writerows，一次性把数据放入一个list里面直接写入。 DictReader可以直接把数据读取为字典的形式，第一行一般是文件的内容描述，自动作为字典的key值。 1csv_file = csv.DictReader(csv_file) DictWriter以字典的形式把数据写入文本。 1csv_file = csv.DictWriter(csv_file, fileheader)","link":"/2019/10/25/Python-%E8%AF%BB%E5%86%99CSV%E6%96%87%E6%A1%A3/"},{"title":"Python 统计列表中重复项","text":"对一个列表，比如[1,2,2,2,2,3,3,3,4,4,4,4]，要统计这个列表里的重复项，以及相应的次数。 有三种方法，set,dict以及Counter 第一种： 1234L = [1,2,2,2,2,3,3,3,4,4,4,4]myset = set(L)for item in myset: print(&quot;the %d has found %d&quot; %(item,L.count(item))) 第二种： 123456L = [1,2,2,2,2,3,3,3,4,4,4,4]a = {}for i in List: if List.count(i)&gt;1: a[i] = List.count(i)print (a) 第三种： 123from collections import Counterprint Counter([1,2,2,2,2,3,3,3,4,4,4,4])# Counter({1: 5, 2: 3, 3: 2})","link":"/2017/04/13/Python-%E7%BB%9F%E8%AE%A1%E5%88%97%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E9%A1%B9/"},{"title":"Python两个字典的合并","text":"两个字典合并的，有几种方法 1234dict1={1:[1,11,111],2:[2,22,222]}dict2={3:[3,33,333],4:[4,44,444]}#得到如下的结果{1:[1,11,111],2:[2,22,222],3:[3,33,333],4:[4,44,444]} 两个方法： dictMerged=dict(dict1.items()+dict2.items()) dictMerged2=dict(dict1, **dict2) 其中方法2类似于： dictMerged=dict1.copy()dictMerged.update(dict2) 但是如果两个字典中有相同的key怎么办？ 如下： 12a = dict(a=1, b=None, c=3)b = dict(a=None, b=2, c=4) 要合并这两个字典该怎么办？ 1234for k, v in b.items(): if v: a[k] = vprint a","link":"/2017/01/17/Python%E4%B8%A4%E4%B8%AA%E5%AD%97%E5%85%B8%E7%9A%84%E5%90%88%E5%B9%B6/"},{"title":"Python中执行 Sehll 命令","text":"在日常的使用中，会经常遇到需要执行 Shell 命令的情况，但是很多时候，在 Python 下执行也是很方便的。下面介绍四种方法以供参考。 OS模块中的os.system() 12&gt;&gt;&gt;os.system('ls')123.txt popen() 得到一个字符串，需要处理下。 12345&gt;&gt;&gt; import os&gt;&gt;&gt; str = os.popen(&quot;ls&quot;).read()&gt;&gt;&gt; a = str.split(&quot;\\n&quot;)&gt;&gt;&gt; for b in a: print b ​ commands模块#可以很方便的取得命令的输出（包括标准和错误输出）和执行状态位 123456789101112import commandsa,b = commands.getstatusoutput('ls')a#是退出状态b#是输出的结果。&gt;&gt;&gt; import commands&gt;&gt;&gt; a,b = commands.getstatusoutput('ls')&gt;&gt;&gt; print a0&gt;&gt;&gt; print banaconda-ks.cfginstall.loginstall.log.syslog commands.getstatusoutput(cmd)返回 status,output commands.getoutput(cmd)只返回输出结果 subprocess模块 使用subprocess模块可以创建新的进程，可以与新建进程的输入/输出/错误管道连通，并可以获得新建进程执行的返回状态。 使用subprocess模块的目的是替代os.system()、os.popen*()、commands.*等旧的函数或模块。 subprocess.call(command, shell=True)直接打印结果 subprocess.Popen(command, shell=True) 也可以是 subprocess.Popen(command, stdout=subprocess.PIPE, shell=True) 这样就可以输出结果了。 如果command不是一个可执行文件，shell=True是不可省略的。 以上就是四种方法。","link":"/2017/06/13/Python%E4%B8%AD%E6%89%A7%E8%A1%8C-Sehll-%E5%91%BD%E4%BB%A4/"},{"title":"Python中把列表转换为字典","text":"有以下几个方法： 1、 现在有两个列表，list1 = ['key1','key2','key3']和list2 = ['1','2','3']，把他们转为这样的字典：{'key1':'1','key2':'2','key3':'3'} 1234list1 = ['key1','key2','key3']list2 = ['1','2','3']print dict(zip(list1, list2))# {'key3': 'value3', 'key2': 'value2', 'key1': 'value1'} 2、 将嵌套列表转为字典，有两种方法 123456new_list= [['key1','value1'],['key2','value2'],['key3','value3']]new_dict = {}for i in new_list: new_dict[i[0]] = i[1]print new_dict()#{'key3': 'value3', 'key2': 'value2', 'key1': 'value1'} 123new_list= [['key1','value1'],['key2','value2'],['key3','value3']]print dict(new_list)#{'key3': 'value3', 'key2': 'value2', 'key1': 'value1'} 3、 list1 = [k1 : {key1 : value1, key2 : value3}] 转变成 list2 = [k1: [ {key1 : value1}, {key2 : value2}] ] 1234567for k, v in list1.items: sm = {} sm[k] = v list2.append(sm)print list2# [k1: [ {key1 : value1}, {key2 : value2}] ]","link":"/2016/10/01/Python%E4%B8%AD%E6%8A%8A%E5%88%97%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E5%85%B8/"},{"title":"Python2.7的UnicodeEncodeError","text":"UnicodeEncodeError: ‘ascii’ codec can’t encode异常错误 ​ 这个错误是编码问题，Unicode编码与ASCII编码的不兼容，现在Python脚本文件是由utf-8编码的，但是 Python2的默认是ASCII的，Python默认环境编码通过下面的方法可以获取： 123import sysprint sys.getdefaultencoding()# 'ascii' ​ 基本上是ascii编码方式，由此Python自然调用ascii编码解码程序去处理字符流，当字符流不属于ascii范围内，就会抛出异常（ordinal not in range(128)）。 ​ 解决的方案很简单，修改默认的编码模式。 123import sysreload(sys)sys.setdefaultencoding('utf-8') ​ 还有一种更好的方法，在输出的时候，对文件制定特定的UTF-8编码即可。 ​ 就是在打开一个文件的时候，不是用open而是用codecs 123fp = codecs.open(‘output.txt’, ‘a+’, ‘utf-8’)fp.write(row[1])fp.close()","link":"/2017/03/22/Python2-7%E7%9A%84UnicodeEncodeError/"},{"title":"Python 创建XML文件","text":"​ 可扩展标记语言（英语：Extensible Markup Language，简称：XML）是一种标记语言。标记指计算机所能理解的信息符号，通过此种标记，计算机之间可以处理包含各种信息的文章等。如何定义这些标记，既可以选择国际通用的标记语言，比如HTML，也可以使用像XML这样由相关人士自由决定的标记语言，这就是语言的可扩展性。XML是从标准通用标记语言（SGML）中简化修改出来的。它主要用到的有可扩展标记语言、可扩展样式语言（XSL）、XBRL和XPath等。 ​ Python 也可以创建XML格式的文件，并且有以下集中方法。 创建的方法一： 1234567891011121314151617from xml.etree import ElementTree as ET# 创建根节点root = ET.Element(&quot;fm&quot;)# 创建第一个节点s1 = root.makeelement('s', {'name': 'g1'})# 创建第二个节点s2 = root.makeelement('s', {&quot;name&quot;: 'g2'})# 在第一个节点创建两个子节点ss1 = s1.makeelement('ss', {'name': 'g11'})ss2 = s1.makeelement('ss', {'name': 'g12'})s1.append(ss1)s1.append(ss2)# 把子节点添加到根节点中root.append(s1)root.append(s1)tree = ET.ElementTree(root)tree.write('oooo.xml', encoding='utf-8', short_empty_elements=False) 创建的方法二： 1234567891011121314from xml.etree import ElementTree as ET# 创建根节点root = ET.Element(&quot;fm&quot;)# 创建第一个节点s1 = ET.SubElement(root, &quot;s&quot;, attrib={'name': 'g1'})# 创建第二个节点s2 = ET.SubElement(root, &quot;s&quot;, attrib={&quot;name&quot;: &quot;g2&quot;})# 在第一个节点中创建两个子节点ss1 = ET.SubElement(s1, &quot;age&quot;, attrib={'name': 'g11'})ss1.text = 'txt'ss2 = ET.SubElement(s1, &quot;age&quot;, attrib={'name': 'g12'})ss2.text = 'sxs'et = ET.ElementTree(root) #生成文档对象et.write(&quot;test.xml&quot;, encoding=&quot;utf-8&quot;, xml_declaration=True, short_empty_elements=False)","link":"/2020/04/18/Python%E5%88%9B%E5%BB%BAXML%E6%96%87%E4%BB%B6/"},{"title":"Python列出目录下的所有文件夹和文件","text":"Python版本：2.7.x 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#!/usr/bin/python# -*- coding:utf8 -*-import osallFileNum = 0def printPath(level, path): global allFileNum ''' 打印一个目录下的所有文件夹和文件 ''' # 所有文件夹，第一个字段是次目录的级别 dirList = [] # 所有文件 fileList = [] # 返回一个列表 files = os.listdir(path) # 添加目录级别 dirList.append(str(level)) for f in files: if(os.path.isdir(path + '/' + f)): if(f[0] == &quot;.&quot;): pass else: # 添加非隐藏文件夹 dirList.append(f) if(os.path.isfile(path + '/' + f)): fileList.append(f) # 当一个标志使用，文件夹列表第一个级别不打印 i_dl = 0 for dl in dirList: if (i_dl == 0): i_dl += 1 else: # 打印至控制台，不是第一个的目录 print '-' * (int(dirList[0])), dl # 打印目录下的所有文件夹和文件，目录级别+1 printPath((int(dirList[0]) + 1), path + '/' + dl) for fl in fileList: print '-' * (int(dirList[0])), fl allFileNum = allFileNum + 1if __name__ == '__main__': printPath(1, 'D:\\python\\python_tool') print &quot;总文件数 = &quot;, allFileNum","link":"/2016/10/13/Python%E5%88%97%E5%87%BA%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E5%A4%B9%E5%92%8C%E6%96%87%E4%BB%B6/"},{"title":"Python创建目录","text":"流程如下： 判断目录是否存在os.path.exists(path) 创建多层目录os.path.makedirs(path) 创建目录os.mkdir(path) 1234567891011121314151617181920212223#! /bin/python# -*- coding:utf-8 -*-import osdef mkdir(path): path = path.strip() #去除首位空格 path = path.rstrip(&quot;\\\\&quot;) #去除尾部 \\ 符号 isExists = os.path.exists(path) if not isExists: os.makedirs(path) print path + '创建成功' return True else: print path + ' 目录已经存在' return Falsemkpath = 'c:\\\\test'mkdir(mkpath) 当父目录不存在的时候os.mkdir(path)不会创建，os.makedirs(path)则会创建父目录","link":"/2016/12/30/Python%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95/"},{"title":"Python去重列表的重复元素","text":"有一个List： l1 = ['b','c','d','b','c','a','a'] 要去除其中的重复部分 有两个方法，一个是 set一个是fromkeys 12345l1 = ['b','c','d','b','c','a','a']l2 = list(set(l1))print l2l3 = {}.fromkeys(l1).keys()print l3 但是上面的有个缺点，就是执行完，lsit 的顺序就跟之前不一样了。 如果想要保持他们原来的排序： 可以用list类的sort方法 123456l1 = ['b','c','d','b','c','a','a']l2 = list(set(l1))l2.sort(key=l1.index)print l2l3 = sorted(set(l1),key=l1.index)print l3 也可以用遍历的方法： 1234l1 = ['b','c','d','b','c','a','a']l2 = [][l2.append(i) for i in l1 if not i in l2]print l2 这样输出的列表的顺序就不会变了。","link":"/2017/03/20/Python%E5%8E%BB%E9%87%8D%E5%88%97%E8%A1%A8%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"},{"title":"Python删除文件和目录的方法","text":"Python删除文件和目录的方法os.remove(path) 删除文件 path. 如果path是一个目录， 抛出 OSError错误。如果要删除目录，请使用rmdir().remove() 同 unlink() 的功能是一样的在Windows系统中，删除一个正在使用的文件，将抛出异常。在Unix中，目录表中的记录被删除，但文件的存储还在。 os.removedirs(path)递归地删除目录。类似于rmdir(), 如果子目录被成功删除， removedirs() 将会删除父目录；但子目录没有成功删除，将抛出错误。举个例子， os.removedirs(“foo/bar/baz”) 将首先删除 “foo/bar/ba”目录，然后再删除foo/bar 和 foo, 如果他们是空的话如果子目录不能成功删除，将 抛出 OSError异常os.rmdir(path)删除目录 path，要求path必须是个空目录，否则抛出OSError错误 递归删除目录和文件（类似DOS命令DeleteTree）： 123456import osfor root, dirs, files in os.walk(top, topdown=False): for name in files: os.remove(os.path.join(root, name)) for name in dirs: os.rmdir(os.path.join(root, name)) 还有一个更简单的： 123import shutilshutil.rmtree()__import__('shutil').rmtree()","link":"/2016/08/11/Python%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%9A%84%E6%96%B9%E6%B3%95/"},{"title":"Python利用哈希值比较两个文件的一致性","text":"Python的内置函数hash(),深入发现通过python的哈希值可以做很多的事情 实现原理散列函数（英语：Hash function）又称散列算法、哈希函数，是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值（hash values，hash codes，hash sums，或hashes）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。好的散列函数在输入域中很少出现散列冲突。在散列表和数据处理中，不抑制冲突来区别数据，会使得数据库记录更难找到。 加密散列函数，是散列函数的一种。它被认为是一种单向函数，也就是说极其难以由散列函数输出的結果，回推输入的资料是什么。这样的单向函数被称为“现代密码学的驮马”。这种散列函数的输入资料，通常被称为讯息（message），而它的输出结果，经常被称为讯息摘要（message digest）或摘要（digest）。它的过程如下： 具体实现MD5MD5的全称是Message-Digest Algorithm 5（信息-摘要算法）。128位长度。目前MD5是一种不可逆算法。具有很高的安全性。它对应任何字符串都可以加密成一段唯一的固定长度的代码。 SHA1SHA1的全称是Secure Hash Algorithm(安全哈希算法) 。SHA1基于MD5，加密后的数据长度更长,它对长度小于264的输入，产生长度为160bit的散列值。比MD5多32位。 因此，比MD5更加安全，但SHA1的运算速度就比MD5要慢了。 我们将演示使用MD5散列算法来hash文件。 我们不会一次性提取全部文件数据，因为一些文件非常大，会很消耗内存甚至一次性放不下。将文件分割成小块读取将使处理过程高效地使用内存。 在Python中内置的 hashlib 模块就包括了 md5 和 sha1 算法。而且使用起来也极为方便，我们使用md5算法来实现我们比较文件一致性的功能，我们会使用update()方法来对这个对象填充任意的字符串。在任何时候你都可以使用digest()或hexdigest()方法问它要目前为止填充的字符串的摘要。我们需要了解以下几个函数： hash.update(arg) hash.digest() hash.hexdigest() 1234567891011121314151617181920212223242526272829303132# !/usr/bin/env python# -*- coding: utf-8 -*-import hashlibdef get_file_md5(f): m = hashlib.md5() while True: #如果不用二进制打开文件，则需要先编码 #data = f.read(1024).encode('utf-8') data = f.read(1024) #将文件分块读取 if not data: break m.update(data) return m.hexdigest()#将file2文件写入改动了一个位数的数据txt1 = '你好么?我可以用下面这段代码验证一下：'txt2 = '你好么?我可以用下面这段代码验证一下：1'with open('1.txt', 'w', encoding='utf-8') as f1, open('2.txt', 'w', encoding='utf-8') as f2: f1.write(txt1) f2.write(txt2)with open('1.txt', 'rb') as f1, open('2.txt', 'rb') as f2: file1_md5 = get_file_md5(f1) file2_md5 = get_file_md5(f2) print('file1_md5:',file1_md5) print('file2_md5:',file2_md5) if file1_md5 != file2_md5: print('file has changed') else: print('file not changed') 在代码中，我们通过将两段字符串txt1,txt2来模拟文件的改动，分别写入1.txt,2.txt,然后我们将两个文件分别读取，计算它们的MD5值，通过比较MD5值便可以知道它们是否一致。需要注意： 1.是文件打开方式一定要是二进制方式，既打开文件时使用b模式，否则Hash计算是基于文本的那将得到错误的文件Hash，如果不用’rb’去读的话，而用’r’去读的话，我们读取的是uncode的编码，然后我们将读取到的内容编码成’utf-8’，即encode(‘utf-8’),然后进行MD5计算也是可以的。 2.为了避免读入的文件过大，我们是分块读取的。 简书：楼上小宇：http://www.jianshu.com/u/1621b29625df","link":"/2018/09/09/Python%E5%88%A9%E7%94%A8%E5%93%88%E5%B8%8C%E5%80%BC%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7/"},{"title":"Python判断字符串是否是回文结构","text":"​ 回文（Palindrome），就是一个序列（如字符串）正着读反着读是一样的。生物信息学上最常见的就是转录因子在DNA上的结合位点通常都是回文结构。在 Python 应该如何判断字符串？ 递归 12345def isPalindrome(s): if len(s) &lt;= 1: return True else: return s[0] == s[-1] and isPalindrome(s[1:-1]) 循环 12345def isPalindrome1(s): for i in range(len(s))/2: if not s[i] == s[len(s)-i-1]: return False return True python的切片 12def isPalindrome2(s): return s == s[::-1] 以上的实现复杂度也是O(n)的。","link":"/2017/05/16/Python%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E6%98%AF%E5%9B%9E%E6%96%87%E7%BB%93%E6%9E%84/"},{"title":"Python字符串处理","text":"相关特性 属于Python基本数据类型和结构的一种。 本身是不可变的数据类型。 有很多内置的方法 字符串连接 join方法 1234a = ['a','b','c','d']content = ''content = ''.join(a)print content 用字符串的占位符替换 1234str = ['a','b','c','d']content = ''content = '%s%s%s%s' % tuple(str)print content 字符串截取 从左到右索引默认0开始的，最大范围是字符串长度少1 123str = 'Python'print str[0]# P 是从右到左索引默认-1开始的，最大范围是字符串开头 123str = 'Python'print str[-1]# n 字符串替换 replace 123str = 'hello word'b = str.replace('word','python')print b 用正则来替换 12345import restr = 'hello world'info = re.compile('word')b = info.sub('python', a)print b 字符串比较 cmp比较两个对象，并根据结果返回一个整数。cmp(x,y)如果X&lt; Y,返回值是负数 如果X&gt;Y 返回的值为正数。 1234sStr1 = 'strch'sStr2 = 'strchr'print cmp(sStr1,sStr2)#-1 字符串查找 find()方法 12345678info = 'abca'print info.find('a')##从下标0开始，查找在字符串里第一个出现的子串，返回结果：0info = 'abca'print info.find('a',1)##从下标1开始，查找在字符串里第一个出现的子串：返回结果3info = 'abca'print info.find('333')##返回-1,查找不到返回-1 index()方法 python 的index方法是在字符串里查找子串第一次出现的位置，类似字符串的find方法，不过比find方法更好的是，如果查找不到子串，会抛出异常，而不是返回-1。 123info = 'abca'print info.index('a')print info.index('33') 字符串分隔 split 123info = 'name:haha,age:20$name:python,age:30$name:fef,age:55'content = info.split('$')print content 字符串反转 通过步进反转[::-1] 123a = 'abcd'b = a[::-1]##[::-1]通过步进反转print b 字符串追加和拼接 元组拼接 123m = 'python'astr = 'i love %s' % mprint astr 字符串的format方法 123m = 'python'astr = &quot;i love {python}&quot;.format(python=m)print astr 字典格式化字符串 123m = 'python'astr = &quot;i love %(python)s &quot; % {'python':m}print astr 字符串大小写 1234567S = 'abc'S.upper()#S中的字母大写 S.lower() #S中的字母小写 S.capitalize() #首字母大写 S.istitle() #S是否是首字母大写的 S.isupper() #S中的字母是否便是大写 S.islower() #S中的字母是否全是小写 字符串去掉空格 通过strip(),lstrip(),rstrip()方法去除字符串的空格 123S.strip()#去掉字符串的左右空格S.lstrip()#去掉字符串的左边空格S.rstrip()#去掉字符串的右边空格 字符串其他方法 1234567891011S.center(width, [fillchar]) #中间对齐S.count(substr, [start, [end]]) #计算substr在S中出现的次数S.expandtabs([tabsize]) #把S中的tab字符替换没空格，每个tab替换为tabsize个空格，默认是8个 S.isalnum() #是否全是字母和数字，并至少有一个字符 S.isalpha() #是否全是字母，并至少有一个字符 S.isspace() #是否全是空白字符，并至少有一个字符S.join()#S中的join，把列表生成一个字符串对象S.ljust(width,[fillchar]) #输出width个字符，S左对齐，不足部分用fillchar填充，默认的为空格。S.rjust(width,[fillchar]) #右对齐 S.splitlines([keepends]) #把S按照行分割符分为一个list，keepends是一个bool值，如果为真每行后而会保留行分割符。S.swapcase() #大小写互换 ​ 案例 123456789101112131415161718192021222324252627282930313233343536373839404142str = &quot;Hello My friend&quot;#字符串是一个整体。如果你想直接修改字符串的某一部分，是不可能的。但我们能够读出字符串的某一部分。#子字符串的提取str[:6]#字符串包含判断操作符：in，not in&quot;He&quot; in str&quot;she&quot; not in str#string模块，还提供了很多方法，如S.find(substring, [start [,end]]) #可指范围查找子串，返回索引值，否则返回-1S.rfind(substring,[start [,end]]) #反向查找S.index(substring,[start [,end]]) #同find，只是找不到产生ValueError异常S.rindex(substring,[start [,end]])#同上反向查找S.count(substring,[start [,end]]) #返回找到子串的个数S.lowercase()S.capitalize() #首字母大写S.lower() #转小写S.upper() #转大写S.swapcase() #大小写互换S.split(str, ' ') #将string转list，以空格切分S.join(list, ' ') #将list转string，以空格连接#处理字符串的内置函数len(str) #串长度cmp(&quot;my friend&quot;, str) #字符串比较。第一个大，返回1max('abcxyz') #寻找字符串中最大的字符min('abcxyz') #寻找字符串中最小的字符#string的转换 float(str) #变成浮点数，float(&quot;1e-1&quot;) 结果为0.1int(str) #变成整型， int(&quot;12&quot;) 结果为12int(str,base) #变成base进制整型数，int(&quot;11&quot;,2) 结果为2long(str) #变成长整型，long(str,base) #变成base进制长整型，#字符串的格式化（注意其转义字符，大多如C语言的，略）str_format % (参数列表) #参数列表是以tuple的形式定义的，即不可运行中改变&gt;&gt;&gt;print &quot;&quot;%s's height is %dcm&quot; % (&quot;My brother&quot;, 180) #结果显示为 My brother's height is 180cm","link":"/2017/05/03/Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"},{"title":"Python学习笔记","text":"Python学习笔记 1、IndentationError: unexpected indent你就要知道python编译器是在告诉你“Hi，老兄，你的文件里格式不对了，可能是tab和空格没对齐的问题，你需要检查下tab和空格了”。2、Python 的stat 模块1234567891011121314151617181920212223242526272829303132#/usr/bin/env python#-- encoding:UTF-8 --import os,time,statfileStats = os.stat ( 'test.txt' ) #获取文件/目录的状态fileInfo = {'Size':fileStats [ stat.ST_SIZE ], #获取文件大小'LastModified':time.ctime( fileStats [ stat.ST_MTIME ] ), #获取文件最后修改时间'LastAccessed':time.ctime( fileStats [ stat.ST_ATIME ] ), #获取文件最后访问时间'CreationTime':time.ctime( fileStats [ stat.ST_CTIME ] ), #获取文件创建时间'Mode':fileStats [ stat.ST_MODE ] #获取文件的模式}#print fileInfofor field in fileInfo: #显示对象内容 print '%s:%s' % (field,fileInfo[field])for infoField,infoValue in fileInfo: print '%s:%s' % (infoField,infoValue)if stat.S_ISDIR ( fileStats [ stat.ST_MODE ] ): #判断是否路径 print 'Directory. 'else: print 'Non-directory.'if stat.S_ISREG( fileStats [ stat.ST_MODE ] ): #判断是否一般文件 print 'Regular file.'elif stat.S_ISLNK ( fileStats [ stat.ST_MODE ] ): #判断是否链接文件 print 'Shortcut.'elif stat.S_ISSOCK ( fileStats [ stat.ST_MODE ] ): #判断是否套接字文件 print 'Socket.'elif stat.S_ISFIFO ( fileStats [ stat.ST_MODE ] ): #判断是否命名管道 print 'Named pipe.'elif stat.S_ISBLK ( fileStats [ stat.ST_MODE ] ): #判断是否块设备 print 'Block special device.'elif stat.S_ISCHR ( fileStats [ stat.ST_MODE ] ): #判断是否字符设置 print 'Character special device.' stat模块描述了os.stat(filename)返回的文件属性列表中各值的意义.我们可方便地根据stat模块存取os.stat()中的值. os.stat(path)执行一个stat()系统调用在给定的path上，返回一个类元组对象(stat_result对象,包含10个元素),属性与stat结构成员相关:st_mode(权限模式),st_ino(inode number),st_dev(device),st_nlink(number of hard links),st_uid(所有用户的user id),st_gid(所有用户的group id),st_size(文件大小，以位为单位)，st_atime(最近访问的时间),st_mtime(最近修改的时间),st_ctime(创建的时间) 3、Python信号处理模块signalPython中对信号处理的模块主要是使用signal模块，但signal主要是针对Unix系统，所以在Windows平台上Python不能很好的发挥信号处理的功能。 要查看Python中的信号量，可以使用dir(signal)来查看。 在signal模块中，主要是使用signal.signal()函数来预设信号处理函数 singnal.signal(signalnum, handler) 其中第一个参数是信号量，第二个参数信号处理函数。 下面看个简单的例子，其中 定义了一个信号处理函数signal_handler()，用来处理程序接收到信号时执行的操作 一段循环等待发送信号12345678910111213141516#!/usr/bin/env python# -*- coding: utf-8 -*-import signalimport timedef signal_handler(signum, frame): print('Received signal: ', signum)while True: signal.signal(signal.SIGHUP, signal_handler) # 1 signal.signal(signal.SIGINT, signal_handler) # 2 signal.signal(signal.SIGQUIT, signal_handler) # 3 signal.signal(signal.SIGALRM, signal_handler) # 14 signal.signal(signal.SIGTERM, signal_handler) # 15 signal.signal(signal.SIGCONT, signal_handler) # 18 while True: print('waiting') time.sleep(1) 运行上面的程序 python test.py 然后另外开一个终端，找到对应的进程，并执行下面的kill操作 1234567kill -1 &lt;pid&gt;kill -2 &lt;pid&gt;kill -3 &lt;pid&gt;kill -14 &lt;pid&gt;kill -15 &lt;pid&gt;kill -18 &lt;pid&gt;kill -9 &lt;pid&gt; # 最后杀死进程 此时可以看到test.py的输出，打印的就是具体接收到的信号。 这里注意一点就是程序中注册了SIGINT信号，所以在运行程序后使用CTRL+C并不能结束进程，而是仍然打印进程接收到的信号。 signal.alarm() 另外，signal模块提供了一个很有用的函数signal.alarm()，它用于在一定时间后向进程自身发送SIGALRM信号，比如下面的例子设置5秒后向自己发送一个SIGALRM信号。 1234567891011121314#!/usr/bin/env python# -*- coding: utf-8 -*-import signalimport timedef signal_handler(signum, frame): print('Received signal: ', signum)while True: signal.signal(signal.SIGALRM, signal_handler) # 14 signal.alarm(5) while True: print('waiting') time.sleep(1) 4、python os.path模块123456789101112131415161718192021222324252627282930313233os.path.abspath(path) #返回绝对路径os.path.basename(path) #返回文件名os.path.commonprefix(list) #返回list(多个路径)中，所有path共有的最长的路径。os.path.dirname(path) #返回文件路径os.path.exists(path) #路径存在则返回True,路径损坏返回Falseos.path.lexists #路径存在则返回True,路径损坏也返回Trueos.path.expanduser(path) #把path中包含的&quot;~&quot;和&quot;~user&quot;转换成用户目录os.path.expandvars(path) #根据环境变量的值替换path中包含的”$name”和”${name}”os.path.getatime(path) #返回最后一次进入此path的时间。os.path.getmtime(path) #返回在此path下最后一次修改的时间。os.path.getctime(path) #返回path的大小os.path.getsize(path) #返回文件大小，如果文件不存在就返回错误os.path.isabs(path) #判断是否为绝对路径os.path.isfile(path) #判断路径是否为文件os.path.isdir(path) #判断路径是否为目录os.path.islink(path) #判断路径是否为链接os.path.ismount(path) #判断路径是否为挂载点（）os.path.join(path1[, path2[, ...]]) #把目录和文件名合成一个路径os.path.normcase(path) #转换path的大小写和斜杠os.path.normpath(path) #规范path字符串形式os.path.realpath(path) #返回path的真实路径os.path.relpath(path[, start]) #从start开始计算相对路径os.path.samefile(path1, path2) #判断目录或文件是否相同os.path.sameopenfile(fp1, fp2) #判断fp1和fp2是否指向同一文件os.path.samestat(stat1, stat2) #判断stat tuple stat1和stat2是否指向同一个文件os.path.split(path) #把路径分割成dirname和basename，返回一个元组os.path.splitdrive(path) #一般用在windows下，返回驱动器名和路径组成的元组os.path.splitext(path) #分割路径，返回路径名和文件扩展名的元组os.path.splitunc(path) #把路径分割为加载点与文件os.path.walk(path, visit, arg) #遍历path，进入每个目录都调用visit函数，visit函数必须有3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有文件名，args则为walk的第三个参数os.path.supports_unicode_filenames #设置是否支持unicode路径名 5、typeerror ‘builtin_function_or_method’ object has no attribute ‘getitem‘是因为把path.append(py)写成了path.append[py] 6、将列表写入文本1234567list = ['foo', 'bar']list.append(&quot;item&quot;)fl=open('list.txt', 'w')for i in list: fl.write(i) fl.write(&quot;\\n&quot;)fl.close() 7、判断文件或者文件夹是否u你在123import os os.path.isfile('test.txt') #如果不存在就返回False os.path.exists(directory) #如果目录不存在就返回False 8、在用json.load()判断文件格式是否错误的时候，出现ValueError: No JSON object could be decoded这个是由于json文件的闭合部分后面不能有,对于列表最后，添加上一个逗号，对于本身Python中的语法，是允许的,对于其他语言，比如C语言，是允许的,但是,在Python 2.7.3中的json库中，是不支持的。","link":"/2016/07/07/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"Python批量重命名","text":"使用Python2.7版本代码如下： 123456789101112131415# /user/bin/python# -*- coding=UTF-8 -*- import os #执行重命名 path = 'D:\\\\check\\\\Images' for file in os.listdir(path): if os.path.isfile(os.path.join(path,file))==True: newname = file.replace(&quot;test&quot;,&quot;a.xml&quot;) os.rename(os.path.join(path,file),os.path.join(path,newname)) #打印文件名列表 for file in os.listdir(path): if os.path.isfile(os.path.join(path,file))==True: print file&lt;/span&gt;","link":"/2016/09/14/Python%E6%89%B9%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D/"},{"title":"Python安装pywin32问题","text":"Python version 2.7 required, which was not found in the registry 新建一个register.py文件，把下列代码复制进去 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051## script to register Python 2.0 or later for use with win32all# and other extensions that require Python registry settings## written by Joakim Loew for Secret Labs AB / PythonWare## source:# http://www.pythonware.com/products/works/articles/regpy20.htm## modified by Valentine Gogichashvili as described in http://www.mail-archive.com/distutils-sig@python.org/msg10512.html import sys from _winreg import * # tweak as necessaryversion = sys.version[:3]installpath = sys.prefix regpath = &quot;SOFTWARE\\\\Python\\\\Pythoncore\\\\%s\\\\&quot; % (version)installkey = &quot;InstallPath&quot;pythonkey = &quot;PythonPath&quot;pythonpath = &quot;%s;%s\\\\Lib\\\\;%s\\\\DLLs\\\\&quot; % ( installpath, installpath, installpath) def RegisterPy(): try: reg = OpenKey(HKEY_CURRENT_USER, regpath) except EnvironmentError as e: try: reg = CreateKey(HKEY_CURRENT_USER, regpath) SetValue(reg, installkey, REG_SZ, installpath) SetValue(reg, pythonkey, REG_SZ, pythonpath) CloseKey(reg) except: print &quot;*** Unable to register!&quot; return print &quot;--- Python&quot;, version, &quot;is now registered!&quot; return if (QueryValue(reg, installkey) == installpath and QueryValue(reg, pythonkey) == pythonpath): CloseKey(reg) print &quot;=== Python&quot;, version, &quot;is already registered!&quot; return CloseKey(reg) print &quot;*** Unable to register!&quot; print &quot;*** You probably have another Python installation!&quot; if __name__ == &quot;__main__&quot;: RegisterPy() 输入如下的命令 显示“python 2.7 is already registered” 再安装setuptools的时候，就能自动识别出来python2.7了。 win7是64位的原因，在安装python（32位）时，如果选择只为当前用户，以上问题是不会出现的，如果选择所有用户，那就用上面的方法解决。","link":"/2016/01/13/Python%E5%AE%89%E8%A3%85pywin32%E9%97%AE%E9%A2%98/"},{"title":"Python批量删除特定后缀名的文件和目录","text":"利用 Python 在日常工作中，删除指定目录已经子目录下的特定后缀的文件名。 Python Version: 2.7 123456789101112131415161718192021222324252627282930313233343536373839# coding:utf-8import osimport sysimport osimport shutil#获取当前路径def fileDir() : path = sys.path[ 0 ] print(path) #判断为脚本文件还是编译后文件，如果是脚本文件则返回脚本目录，否则返回编件译后的文件路径 if os.path.isdir( path ) : return path elif os.path.isfile( path ) : return os.path.dirname( path ) #获取文件后缀名def suffix(fileName, *suffixName) : array = map(fileName.endswith, suffixName) if True in array : return True else : return False #删除目录下扩展名为.exe,.bak的文件def deleteFile() : target_dir = fileDir() for root, dir_names, file_names in os.walk(target_dir): for file in file_names: target_file = os.path.join(root, file) if suffix(file, '.doc', '.xls'): os.remove(target_file) # 文件夹名字 if file == 'a': shutil.rmtree(os.path.join(root, dir_names)) if __name__ == '__main__' : deleteFile()","link":"/2018/01/19/Python%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4%E7%89%B9%E5%AE%9A%E5%90%8E%E7%BC%80%E5%90%8D%E7%9A%84%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/"},{"title":"Python学习记录","text":"Python学习记录 用，表示一个空格 当你输入name = raw_input()并按下回车后，Python交互式命令行就在等待你的输入了。这时，你可以输入任意字符，然后按回车后完成输入。再次输入name则可以直接显示刚才输入的内容 以#开头的语句是注释，注释是给人看的，可以是任意内容，解释器会忽略掉注释。其他每一行都是一个语句，当语句以冒号“:”结尾时，缩进的语句视为代码块 数据类型：int， float， string 如果字符串内部既包含’又包含”怎么办？可以用转义字符\\来标识 转义字符\\可以转义很多字符，比如\\n表示换行，\\t表示制表符，字符\\本身也要转义，所以\\\\表示的字符就是\\ 如果字符串里面有很多字符都需要转义，就需要加很多\\，为了简化，Python还允许用r''表示''内部的字符串默认不转义 如果字符串内部有很多换行，用\\n写在一行里不好阅读，为了简化，Python允许用'''...'''的格式表示多行内容 字符串 1234&gt;&gt;&gt; ord('A')65&gt;&gt;&gt; chr(65)'A' len()函数可以返回字符串的长度 由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行： 12#!/usr/bin/env python# -*- coding: utf-8 -*- %运算符就是用来格式化字符串的。在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。常见的占位符有：%d 整数%f 浮点数%s 字符串%x 十六进制整数 1234&gt;&gt;&gt; 'Hello, %s' % 'world''Hello, world'&gt;&gt;&gt; 'Hi, %s, you have $%d.' % ('Michael', 1000000)'Hi, Michael, you have $1000000.' 列出班里所有同学的名字，就可以用一个list表示： 12345678910111213&gt;&gt;&gt; classmates = ['Michael', 'Bob', 'Tracy']&gt;&gt;&gt; classmates['Michael', 'Bob', 'Tracy']#显示某一个&gt;&gt;&gt; classmates[1]'Bob'#显示最后一个&gt;&gt;&gt; classmates[-1]'Tracy'#添加&gt;&gt;&gt; classmates.append('Adam')#插入&gt;&gt;&gt; classmates.insert(1, 'Jack') 要删除指定位置的元素，用pop(i)方法，其中i是索引位置 一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改 Python的缩进规则，如果if语句判断是True，就把缩进的两行print语句执行了，否则，什么也不做。 1234567age = 3if age &gt;= 18: print 'adult'elif age &gt;= 6: print 'teenager'else: print 'kid' elif是else if的缩写if语句执行有个特点，它是从上往下判断，如果在某个判断上是True，把该判断对应的语句执行后，就忽略掉剩下的elif和else. 求和for求和 1234sum = 0for x in range(101): sum = sum + xprint sum while求和 123456sum = 0n = 99while n &gt; 0: sum = sum + n n = n - 2print sum 从raw_input()读取的内容永远以字符串的形式返回 Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。 123&gt;&gt;&gt; d = {'Michael': 95, 'Bob': 75, 'Tracy': 85}&gt;&gt;&gt; d['Michael']95 要删除一个key，用pop(key)方法，对应的value也会从dict中删除： 1234&gt;&gt;&gt; d.pop('Bob')75&gt;&gt;&gt; d{'Michael': 95, 'Tracy': 85} set和dict类似，也是一组key的集合，但不存储value。要创建一个set，需要提供一个list作为输入集合： 123&gt;&gt;&gt; s = set([1, 2, 3])&gt;&gt;&gt; sset([1, 2, 3]) 传入的参数[1, 2, 3]是一个list，而显示的set([1, 2, 3])只是告诉你这个set内部有1，2，3这3个元素，显示的[]不表示这是一个list。通过add(key)方法可以添加元素到set中,通过remove(key)方法可以添加元素到set中。set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。 Python的函数 比较函数cmp(x, y)就需要两个参数，如果x&lt;y，返回-1，如果x==y，返回0，如果x&gt;y，返回1 Python内置的常用函数还包括数据类型转换函数，比如int()函数可以把其他数据类型转换为整数： 1234567891011121314&gt;&gt;&gt; int('123')123&gt;&gt;&gt; int(12.34)12&gt;&gt;&gt; float('12.34')12.34&gt;&gt;&gt; str(1.23)'1.23'&gt;&gt;&gt; unicode(100)u'100'&gt;&gt;&gt; bool(1)True&gt;&gt;&gt; bool('')False 在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。 12345def my_abs(x): if x &gt;= 0: return x else: return -x 如果想定义一个什么事也不做的空函数，可以用pass语句 12def nop(): pass 对参数类型做检查，只允许整数和浮点数类型的参数。数据类型检查可以用内置函数isinstance实现： 1234567def my_abs(x): if not isinstance(x, (int, float)): raise TypeError('bad operand type') if x &gt;= 0: return x else: return -x 定义可变参数和定义list或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数 12345def calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sum 在Python中定义函数，可以用必选参数、默认参数、可变参数和关键字参数，这4种参数都可以一起使用，或者只用其中某些，但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数和关键字参数。 12def func(a, b, c=0, *args, **kw): print 'a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw 在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。 12345678&gt;&gt;&gt; func(1, 2)a = 1 b = 2 c = 0 args = () kw = {}&gt;&gt;&gt; func(1, 2, c=3)a = 1 b = 2 c = 3 args = () kw = {}&gt;&gt;&gt; func(1, 2, 3, 'a', 'b')a = 1 b = 2 c = 3 args = ('a', 'b') kw = {}&gt;&gt;&gt; func(1, 2, 3, 'a', 'b', x=99)a = 1 b = 2 c = 3 args = ('a', 'b') kw = {'x': 99} 最神奇的是通过一个tuple和dict，你也可以调用该函数 1234&gt;&gt;&gt; args = (1, 2, 3, 4)&gt;&gt;&gt; kw = {'x': 99}&gt;&gt;&gt; func(*args, **kw)a = 1 b = 2 c = 3 args = (4,) kw = {'x': 99} &gt;&gt;&gt; L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']取前三个 1234567&gt;&gt;&gt; r = []&gt;&gt;&gt; n = 3&gt;&gt;&gt; for i in range(n):... r.append(L[i])... &gt;&gt;&gt; r['Michael', 'Sarah', 'Tracy'] 默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.itervalues()，如果要同时迭代key和value，可以用for k, v in d.iteritems()。如何判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断： 1234567&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance('abc', Iterable) # str是否可迭代True&gt;&gt;&gt; isinstance([1,2,3], Iterable) # list是否可迭代True&gt;&gt;&gt; isinstance(123, Iterable) # 整数是否可迭代False 列表生成式 12&gt;&gt;&gt; [x * x for x in range(1, 11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100] map()函数接收两个参数，一个是函数，一个是序列，·map将传入的函数依次作用到序列的每个元素，并把结果作为新的list返回 12345&gt;&gt;&gt; def f(x):... return x * x...&gt;&gt;&gt; map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])[1, 4, 9, 16, 25, 36, 49, 64, 81]","link":"/2016/01/11/Python%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"title":"Python格式化xml文件","text":"在使用Python构建XML文件的时候，默认是没有缩减的。 发现BeautifulSoup自带自动缩减 方法如下： 123456from bs4 import BeautifulSoupbs = BeautifulSoup(open(tmp_file), 'xml')with open(filename, 'w', encoding='utf-8') as f: f.write(bs.prettify())","link":"/2020/03/15/Python%E6%A0%BC%E5%BC%8F%E5%8C%96xml%E6%96%87%E4%BB%B6/"},{"title":"Python的最大递归深度错误","text":"今天在用 Python 的爬虫的时候，遇到一个错误maximum recursion depth exceeded while calling a Python object，意思是：当调用该对象超过最大递归深度。 报错如下: File “/usr/lib/python3.5/enum.py”, line 241, in call return cls.new(cls, value) File “/usr/lib/python3.5/enum.py”, line 463, in new if type(value) is cls:RecursionError: maximum recursion depth exceeded while calling a Python object 原因是在Python里的递归调用是有限制的，可以使用sys模块里的getrecursionlimit方法查看的到，打破递归栈的深度限制: 解析一种Python尾递归优化的方法 打开终端运行Python，可以看到默认限制值为1000. 解决方法： sys.setrecursionlimit(2000)","link":"/2017/11/13/Python%E7%9A%84%E6%9C%80%E5%A4%A7%E9%80%92%E5%BD%92%E6%B7%B1%E5%BA%A6%E9%94%99%E8%AF%AF/"},{"title":"Python编码问题","text":"Python编码的一点小问题 unicode是一个字符集，它包含了（理论上）所有可能出现的文字和符号，每个符号都有一个对应的unicode值，叫做码点，对特定字符来说，这个码点是唯一，固定的utf-xx（比如utf-8，utf-16，utf-32等）是unicode码点的一种特定的编码方式，因为码点最终要以某种形式存在于内存或者文件中，所以必须指定一种编码方式来表示某个码点同一个码点，用不同的编码方式，得到的结果是不同的ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。而utf-16跟utf-8是平级的概念——都是Unicode的某种编码方式gbk，规定了（理论上）每个汉字在内存或者文件中的编码方式而Unicode可以认为只是字符集，不限定编码规则只是gbk和utf-8的前256个字符，都保持跟ASCII兼容 Python 2.x里 string decode –&gt; unicode string (utf16) unicode string encode –&gt; string Python 3.x里 string (utf8) encode –&gt; byte string byte string decode –&gt; string","link":"/2016/01/13/Python%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/"},{"title":"Python第三方库unrar","text":"unrar模块介绍 ​ unrar第三方python库是解压rar压缩文件的扩展包，可实现对rar压缩文件的读取、解压等处理。也可以使用unrar这个模块来进行编写rar压缩文件暴力破解。 安装 直接利用 pip 安装 1pip install unrar 官网下载源文件安装 unrar 源文件 在官网下载文件，利用python setup.py install进行安装 文档地址 案例 12345678910111213141516171819&gt;&gt;&gt; from unrar import rarfile #导入rarfile，处理rar文件&gt;&gt;&gt; rar = rarfile.RarFile('sample.rar') #读取rar文件&gt;&gt;&gt; rar.namelist() #列出rar压缩文件中的文件列表[u'test_file.txt']&gt;&gt;&gt; rar.printdir() #打印rar压缩文件中的文件列表File Name Modified Sizetest_file.txt 2013-04-14 08:20:28 17&gt;&gt;&gt; rar.testrar()&gt;&gt;&gt; info = rar.infolist()[0] #通过索引获取压缩文件中的文件&gt;&gt;&gt; info.filename #获取压缩文件名u'test_file.txt'&gt;&gt;&gt; info.file_size #获取压缩文件大小17L&gt;&gt;&gt; info.date_time #获取压缩文件创建日期(2013L, 4L, 14L, 8L, 20L, 28L)&gt;&gt;&gt; rar.read('test_file.txt') #读取压缩文件的内容'This is for test.'&gt;&gt;&gt; rar.extractall() #解压rar压缩文件&gt;&gt;&gt; rar.close() #关闭rar文件","link":"/2017/05/10/Python%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93unrar/"},{"title":"Python读写json","text":"读写中文的json数据，可以用Python中的json库来进行操作。读取可以使用json.load 12f = file(path)data = json.load(f) json是被载入到一个dict类型的object对象中。 使用json.dump可以输出json。不过输出的文本不是中文而是转换为utf-8的格式。 1output = json.dump(jsonData,targetFile,ensure_ascii=False,indent=4) 输出中文的json。通过使用 ensure_ascii=False，输出原有的语言文字。indent参数是缩进数量。 如果把上文的String直接写入文件可能会出错，一般是在Python2.7的版本出现： 1UnicodeEncodeError: 'ascii' codec can't encode characters in position 1-9: ordinal not in range(128) 解决的办法是在输出的时候进行编码： 123import codecswith codecs.open(path,'w','utf-8') as w: #write to w","link":"/2016/08/11/Python%E8%AF%BB%E5%86%99json/"},{"title":"RxJava开发精要","text":"####RxJava开发精要系列 RxJava开发精要1-从.NET到RxJavaRxJava开发精要2-为什么是Observables?RxJava开发精要3-向响应式世界问好RxJava开发精要4 – Observables过滤RxJava开发精要5 – Observables变换RxJava开发精要6 – Observables组合RxJava开发精要7 – Schedulers-解决Android主线程问题RxJava开发精要8 – 与REST无缝结合-RxJava和Retrofit 给 Android 开发者的 RxJava 详解作者：抛物线给 Android 开发者的 RxJava 详解 Architecting Android with RxJava坐着：小鄧子Architecting Android with RxJava","link":"/2016/01/09/RxJava%E5%BC%80%E5%8F%91%E7%B2%BE%E8%A6%81/"},{"title":"Python进行URL解码","text":"Python进行URL解码所用模块：urllib 所用函数：urllib.unquote() 1234import urllibrawurl = &quot;%E8%A7%A3%E7%A0%81&quot;url = urllib.unquote(rawurl)print url 输出： 1解码 与上述函数对应的是编码函数:urllib.quote() 12import urlliburllib.quote(&quot;解码&quot;) 输出： 1%E8%A7%A3%E7%A0%81","link":"/2016/09/18/Python%E8%BF%9B%E8%A1%8CURL%E8%A7%A3%E7%A0%81/"},{"title":"Python递归实现字典中的Unicode转换成str","text":"由于josn库的loads方法会把类型全部转换成 Unicode。如果想要变成str对象的话，就要自己去encode。 试试如下代码： 123456789def byteify(input): if isinstance(input, dict): return {byteify(key): byteify(value) for key, value in input.iteritems()} elif isinstance(input, list): return [byteify(element) for element in input] elif isinstance(input, unicode): return input.encode('utf-8') else: return input","link":"/2017/07/21/Python%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E5%AD%97%E5%85%B8%E4%B8%AD%E7%9A%84Unicode%E8%BD%AC%E6%8D%A2%E6%88%90str/"},{"title":"SSH 连接服务器报错：ssh_exchange_identification: Connection closed by remote host","text":"今天尝试连接自己服务器的时候，SSH无法连接上去，并且提示： ssh_exchange_identification: Connection closed by remote host 经过查询得知是因为SSH连接数量的问题。 通过服务商的VNC管理程序，进入服务器 编辑sshd_config的文件 1234vi /etc/ssh/sshd_config# 然后把MaxSessions启用，并且后面的数字改成50# 保存systemctl restart sshd 重连即可。 PS：如果发现还是无法连接，检查一下是否Surge开启了增强模式。关闭该模式即可。","link":"/2020/02/27/SSH-%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8A%A5%E9%94%99%EF%BC%9Assh-exchange-identification-Connection-closed-by-remote-host/"},{"title":"SSH文件上传错误","text":"SSH 文件上传错误：encountered 1 errors during the transfer解决方法​ 这个错误Google一下会发现有很多，基本的解决情况如下四种： 在SSH Secure File Transfer，打开“Operation”菜单，打开“File Transfer Mode”子菜单，再选择“Binary” 把服务器上同名文件删掉再传 如果文件在中文路径下，将要上传的文件复制到其它英文路径下，再上传！ 到winsco下载 WInSCP，再传！","link":"/2016/09/05/SSH%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E9%94%99%E8%AF%AF/"},{"title":"Red Hat Linux卸载旧版本的JDK安装新版本的JDK","text":"做一个安装和记录的流程: 查看内核 uname -a来判断是32 位还是64 位还是其余什么的机器 查看java 版本 rpm -qa | grep gcj 卸载java yum -y remove javaname 给新的java 程序分配权限 chmod +x newjavaname 执行安装程序 ./newjavaname 设置path与classpath 1234export JAVA_HOME=/usr/java/newjavanameexport path=$path:$JAVA_HOME/bin;export path=$path:$JAVA_HOME/jre/binexport classpath=.:/usr/java/newjavaname/lib:/usr/java/newjavaname/jre/lib:$CLASSPATH","link":"/2018/06/14/Red-Hat-Linux%E5%8D%B8%E8%BD%BD%E6%97%A7%E7%89%88%E6%9C%AC%E7%9A%84JDK%E5%AE%89%E8%A3%85%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84JDK/"},{"title":"Soft","text":"Some Soft（SQL Server &amp; Visual Studio）1、MS SQL Server 2008 简体中文正式版下载地址(附序列号) Microsoft® SQL Server® 2008 Enterprise Evaluation：开发人员试用体验http://www.microsoft.com/downloads/details.aspx?FamilyId=6B10C7C1-4F97-42C4-9362-58D4D088CD38&amp;displaylang=zh-cn Microsoft® SQL Server® 2008 Enterprise Evaluation：IT 专业人员试用体验http://www.microsoft.com/downloads/details.aspx?familyid=265F08BC-1874-4C81-83D8-0D48DBCE6297&amp;displaylang=zh-cn SQL Server 2008 发行说明http://www.microsoft.com/downloads/info.aspx?na=90&amp;p=&amp;SrcDisplayLang=zh-cn&amp;SrcCategoryId=&amp;SrcFamilyId=daf00920-7214-418a-a4b0-727f4ce08f81&amp;u=http%3a%2f%2fdownload.microsoft.com%2fdownload%2f9%2ff%2fe%2f9fe7971b-cea6-4f67-ac49-d7fc82a75119%2fReleaseNotesSQLServer2008_CHS.htm Microsoft SQL Server 2008 联机丛书http://www.microsoft.com/downloads/info.aspx?na=90&amp;p=&amp;SrcDisplayLang=zh-cn&amp;SrcCategoryId=&amp;SrcFamilyId=765433f7-0983-4d7a-b628-0a98145bcb97&amp;u=http%3a%2f%2fdownload.microsoft.com%2fdownload%2f1%2f3%2f2%2f1321c45a-aab0-4033-9d82-f0862edc8418%2fSQLServer2008_BOL_CHS.msi 推荐：http://sqlserver.dlservice.microsoft.com/dl/download/B/8/0/B808AF59-7619-4A71-A447-F597DE74AC44/SQLFULL_CHS.iso SQL Server 2008 序列号：Developer: PTTFM-X467G-P7RH2-3Q6CG-4DMYBEnterprise: JD8Y6-HQG69-P9H84-XDTPG-34MBB Microsoft SQL Server 2008 Feature Pack，2008 年 8 月 http://www.microsoft.com/downloads/details.aspx?familyid=C6C3E9EF-BA29-4A43-8D69-A2BED18FE73C&amp;displaylang=zh-tw http://sqlserver.dlservice.microsoft.com/download/0/1/6/0160907E-E9CB-4BA4-99C1-B7FE7C7D2DF9/SQLFULL_CHT.iso http://download.microsoft.com/download/9/f/c/9fc5e859-8762-40b9-927f-ca1d569dcfda/SQLServer2008_BOL_August2008_CHT.msi http://sqlserver.dlservice.microsoft.com/download/B/8/0/B808AF59-7619-4A71-A447-F597DE74AC44/SQLFULL_CHS.iso http://download.microsoft.com/download/1/3/2/1321c45a-aab0-4033-9d82-f0862edc8418/SQLServer2008_BOL_August2008_CHS.msi SQL Server 2008 简体中文正式版 提供下载SQL Server 2008是一个重大的产品版本，它推出了许多新的特性和关键的改进，使得它成为至今为止的最强大和最全面的SQL Server版本。 在现今数据的世界里，公司要获得成功和不断发展，他们需要定位主要的数据趋势的愿景。微软的这个数据平台愿景帮助公司满足这些数据爆炸和下一代数据驱动应用程序的需求。微软将继续投入和发展以下的关键领域来支持他们的数据平台愿景：关键任务企业数据平台、动态开发、关系数据和商业智能。 本DVD包含了x86 x64 ia64 三种CPU模式的安装程序。版本号为： 10.0.1600.22 序列号：开发版(Developer): PTTFM-X467G-P7RH2-3Q6CG-4DMYB企业版(Enterprise): JD8Y6-HQG69-P9H84-XDTPG-34MBB http://www.cnblogs.com/shunyao8210/archive/2008/10/24/1318447.htmlhttp://www.cnblogs.com/SGSoft/archive/2008/10/20/1314952.html 2、Visual Studio 2013 官方免费社区版/简体中文旗舰版下载 (VS2013 MSDN原版ISO镜像) http://www.iplaysoft.com/vs2013.html","link":"/2016/04/03/Soft/"},{"title":"SSL证书的配置过程","text":"Apache 2配置SSL证书本文描述在 Apache 2.x HTTP 服务器上安装并配置 SSL 证书。 确保Apache SSL模块的开启1sudo a2enmod ssl 配置SSL证书完整的SSL证书分为四个部分： CA 根证书 (root CA) 中级证书 (Intermediate Certificate) 域名证书 证书密钥 (仅本人持有) 以 COMODO PositiveSSL 证书为例，将收到四份文件： 根证书 - AddTrustExternalCARoot.crt 中级证书 - COMODORSAAddTrustCA.crt 中级证书 - COMODORSADomainValidationSecureServerCA.crt 您的域名证书 - example_com.crt 要依照 中间证书 -&gt; 根证书 的顺序串联为证书链，才能被绝大多数浏览器信任。使用 cat 命令串联证书： 1cat COMODORSADomainValidationSecureServerCA.crt COMODORSAAddTrustCA.crt AddTrustExternalCARoot.crt &gt; ca-bundle.crt 得到 ca-bundle.crt 后，和证书文件 example_com.crt，密钥文件 example_com.key 一同上传至服务器并保存在安全的位置，例如 /etc/ssl/private 目录下 (没有此目录请创建)。 修改Apache站点配置下面是一份针对 Apache 2.4 的 SSL 部分配置 1234SSLEngine onSSLCertificateFile /etc/ssl/private/example_com.crtSSLCertificateKeyFile /etc/ssl/private/example_com.keySSLCertificateChainFile /etc/ssl/private/ca-bundle.crt 以下为 的详细配置 1234567&lt;VirtualHost *:443&gt;DocumentRoot /var/www/SSLEngine onSSLCertificateFile /etc/ssl/private/example_com.crtSSLCertificateKeyFile /etc/ssl/private/example_com.keySSLCertificateChainFile /etc/ssl/private/ca-bundle.crt&lt;/VirtualHost&gt; 请注意如果你的 Apache2 版本大于 2.4.8，您可以将所有证书串联为一个文件作为 SSLCertificateFile 的值，而不必写 SSLCertificateChainFile 强制定向到HTTPS首先，我们需要确认 Apache 开启 mod_rewrite 模块，如果没有开启，请使用 sudo a2enmod rewrite 命令开启。 其次，你需要在站点配置文件中开启 AllowOverride，这样 .htaccess 文件才会起作用。 开启并重启 Apache 后，复制一下代码到你目录的 .htaccess 文件 123RewriteEngine OnRewriteCond %{HTTPS} offRewriteRule (.*) https://%{HTTP_HOST}%{REQUEST_URI} SSL安全配置禁用压缩1SSLCompression off 禁用 SSLv2 和 SSLv31SSLProtocol All -SSLv2 -SSLv3 抵御 Poodle 和 SSL Downgrade 攻击您需要支持 TLS-FALLBACK-SCSV 以自动开启此功能。下列 OpenSSL 版本包含对 TLS-FALLBACK-SCSV 的支持，Lighttpd 会自动启用此特性。 OpenSSL 1.0.1 在 1.0.1j 及之后的版本中支持 OpenSSL 1.0.0 在 1.0.0o 及之后的版本中支持 OpenSSL 0.9.8 在 0.9.8zc 及之后的版本中支持 加密和交换算法一份推荐的配置： 1SSLCipherSuite EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH 如果您需要兼容老式系统和浏览器 (Windows XP, IE6)，请使用下面的： 1SSLCipherSuite EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:ECDHE-RSA-AES128-SHA:DHE-RSA-AES128-GCM-SHA256:AES256+EDH:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES128-SHA256:DHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES256-GCM-SHA384:AES128-GCM-SHA256:AES256-SHA256:AES128-SHA256:AES256-SHA:AES128-SHA:DES-CBC3-SHA:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!MD5:!PSK:!RC4 Forward Secrecy 和 DHE 参数12cd /etc/ssl/certsopenssl dhparam -out dhparam.pem 4096 建议您使用性能强劲的平台生成此文件，例如最新版的至强物理机。如果您只有一台小型 VPS，请使用 openssl dhparam -out dhparam.pem 2048 命令生成 2048bit 的参数文件。 添加到配置文件： 1SSLOpenSSLConfCmd DHParameters &quot;/etc/ssl/certs/dhparam.pem&quot; 启用 HSTS添加到配置文件： 123456# Optionally load the headers module:LoadModule headers_module modules/mod_headers.so&lt;VirtualHost 67.89.123.45:443&gt; Header always set Strict-Transport-Security &quot;max-age=63072000; includeSubdomains; preload&quot;&lt;/VirtualHost&gt; 重启 Apache1sudo service apache2 restart","link":"/2016/10/27/SSL%E8%AF%81%E4%B9%A6%E7%9A%84%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/"},{"title":"Sublime Text3","text":"####Sublime Text3 快捷键 Ctrl+D 选词 （反复按快捷键，即可继续向下同时选中下一个相同的文本进行同时编辑） Ctrl+G 跳转到相应的行 Ctrl+J 合并行（已选择需要合并的多行时） Ctrl+L 选择整行（按住-继续选择下行） Ctrl+M 光标移动至括号内开始或结束的位置 Ctrl+T 词互换 Ctrl+U 软撤销 Ctrl+P 查找当前项目中的文件和快速搜索；输入 @ 查找文件主标题/函数；或者输入 : 跳转到文件某行； Ctrl+R 快速列出/跳转到某个函数 Ctrl+K Backspace 从光标处删除至行首 Ctrl+K+B 开启/关闭侧边栏 Ctrl+KK 从光标处删除至行尾 Ctrl+K+T 折叠属性 Ctrl+K+U 改为大写 Ctrl+K+L 改为小写 Ctrl+K+0 展开所有 Ctrl+Enter 插入行后（快速换行） Ctrl+Tab 当前窗口中的标签页切换 Ctrl+Shift+A 选择光标位置父标签对儿 Ctrl+Shift+D 复制光标所在整行，插入在该行之前 ctrl+shift+F 在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找 Ctrl+Shift+K 删除整行 Ctrl+Shift+L 鼠标选中多行（按下快捷键），即可同时编辑这些行 Ctrl+Shift+M 选择括号内的内容（按住-继续选择父括号） Ctrl+Shift+P 打开命令面板 Ctrl+Shift+/ 注释已选择内容 Ctrl+Shift+↑可以移动此行代码，与上行互换 Ctrl+Shift+↓可以移动此行代码，与下行互换 Ctrl+Shift+[ 折叠代码 Ctrl+Shift+] 展开代码 Ctrl+Shift+Enter 光标前插入行 Ctrl+PageDown 、Ctrl+PageUp 文件按开启的前后顺序切换 Ctrl+Z 撤销 Ctrl+Y 恢复撤销 Ctrl+F2 设置/取消书签 Ctrl+/ 注释整行（如已选择内容，同“Ctrl+Shift+/”效果） Ctrl+鼠标左键 可以同时选择要编辑的多处文本 Shift+鼠标右键（或使用鼠标中键）可以用鼠标进行竖向多行选择 Shift+F2 上一个书签 Shift+Tab 去除缩进 Alt+Shift+1（非小键盘）窗口分屏，恢复默认1屏 Alt+Shift+2 左右分屏-2列 Alt+Shift+3 左右分屏-3列 Alt+Shift+4 左右分屏-4列 Alt+Shift+5 等分4屏 Alt+Shift+8 垂直分屏-2屏 Alt+Shift+9 垂直分屏-3屏 Ctrl+Shift+分屏序号 将当前焦点页分配到分屏序号页 Alt+. 闭合当前标签 Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑 Tab 缩进 自动完成 F2 下一个书签 F6 检测语法错误 F9 行排序(按a-z) ####sublime text修改TAB缩进为空格 在sublime text中将TAB缩进直接转化为4个空格，可以按照如下方式操作： 菜单栏: Preferences -&gt; Settings – More -&gt; Syntax Specific – User 然后添加设置代码就可以了，文件保存在$Packages/User下 12345{ &quot;tab_size&quot;: 4, &quot;translate_tabs_to_spaces&quot;: true}","link":"/2015/11/09/Sublime-Text3/"},{"title":"Ubuntu 16.04LTS 搭建 Shadowsocks","text":"只针对Ubuntu16以上的版本。 执行很简单，首先是三条命令 123apt updateapt install python-pippip install shadowsocks pip 是 Python 下方便的包管理工具 之后在/etc/shadowsocks编写配置文件： 12345678910{ &quot;server&quot;:&quot;my_server_ip&quot;, &quot;server_port&quot;:8388, &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;mypassword&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;: false} 上面一些数值，替换成自己相应的就好，method建议128的就好。 接下来运行如下命令： 1ssserver -c /etc/shadowsocks.json -d start 为了能够开机自启，把上面的命令加入到/etc/rc.loacl里面，在 exit之前就行。 最后下载客户端：SS客户端 可能在 VPS 会遇到以下的一个错误：Python locale error: unsupported locale setting 只要执行以下几行命令就可以了: 123export LC_ALL=&quot;en_US.UTF-8&quot;export LC_CTYPE=&quot;en_US.UTF-8&quot;sudo dpkg-reconfigure locales","link":"/2017/02/28/Ubuntu-16-04LTS-%E6%90%AD%E5%BB%BA-Shadowsocks/"},{"title":"Ubuntu 18 设置静态IP","text":"Ubuntu 18 的网络管理程序变成了netplan，所以配置方式也跟16不一样了。 现在的网卡配置文件是： /etc/netplan/50-cloud-init.yaml 采用了YAML的文件格式，设置静态IP的格式如下： 12345678910network: ethernets: enp0s3: addresses: [192.168.1.100/24] dhcp4: no dhcp6: no gateway4: 192.168.1.1 nameservers: addresses: [8.8.8.8, 9.9.9.9] version: 2 保存之后，利用netplan apply生效 ifconfig查看是否是新的IP地址 PS： 基于YAML的格式要求，每一行的:要有空格，否则在重启的时候会报错。","link":"/2019/10/12/Ubuntu18-%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81IP/"},{"title":"Ubuntu中vi使用方向键与退格键乱码问题","text":"在Ubuntu中 使用方向键与退格键会出现ABCD等字母。 主要有两个解决方法。 方案一： 可以安装vim full版本，在full版本下键盘正常，安装好后同样使用vi命令。 安装vim： ubuntu预装的是vim tiny版本，而需要的是vim full版本。执行下面的语句安装vim full版本： 12$sudo apt-get remove vim-common$sudo apt-get install vim 这样就行了，vim是一款优秀的软件，可以在运用中体会到。 方案二： 在vi命令行使用命令“：set nocompatible”，就是设置vi不使用兼容模式。 Ubuntu中的vi命令： vi 有三种模式，输入模式，编辑模式，“：”命令模式 vi 进入以后默认是编辑模式 vi 编辑模式默认的快捷键 上下左右分别是 J K H L vi 在编辑模式使用 i 可以进入输入模式 vi 输入模式只能输入英文，默认不能使用上下左右箭头 vi 输入模式用Esc可以返回到编辑模式 vi 编辑模式 Shift + ; 可以进入命令模式 vi 命令模式w保存，q退出 1）对所有用户都有效,解决系统中所用用户的vi中文乱码问题 sudo gedit /etc/vim/vimrc.tiny 加入如下内容： #该文件的内容显示如下： “ Encoding related set encoding=UTF-8 set langmenu=zh_CN.UTF-8 language message zh_CN.UTF-8 set fileencodings=ucs-bom,utf-8,cp936,gb18030,big5,euc-jp,euc-kr,latin1 set fileencoding=utf-8 2)只对当前用户有效的解决方法 ubuntu默认在当前用户的家目录下，没有.vimrc文件，这个时候可以自己touch一个.vimrc文件，且在其中加入 #该文件的内容显示如下： “ Encoding related set encoding=UTF-8 set langmenu=zh_CN.UTF-8 language message zh_CN.UTF-8 set fileencodings=ucs-bom,utf-8,cp936,gb18030,big5,euc-jp,euc-kr,latin1 set fileencoding=utf-8","link":"/2017/09/28/Ubuntu%E4%B8%ADvi%E4%BD%BF%E7%94%A8%E6%96%B9%E5%90%91%E9%94%AE%E4%B8%8E%E9%80%80%E6%A0%BC%E9%94%AE%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"},{"title":"Ubuntu安装 redis，并后台运行","text":"Ubuntu16.04 上安装运行 redis过程。 安装：apt install reids 设置redis.conf vi /etc/redis/redis.conf 默认情况下Redis不作为后台服务运行，这里设置为yes，即可作为后台服务运行 123# By default Redis does not run as a daemon. Use 'yes' if you need it.# Note that Redis will write a pid file in /var/run/redis.pid when daemonized.daemonize yes 启动redis 服务 redis-server /etc/redis/redis.conf 检测服务是否已经启动 1ps -ef |grep redis 检测6379端口是否监听 1netstat -lntp | grep 6379 检测客户端连接是否正常 使用客户端redis-cli 1234567redis-cli127.0.0.1:6379&gt; keys *#(empty list or set)127.0.0.1:6379&gt; set key &quot;hello world&quot;#OK127.0.0.1:6379&gt; get key#&quot;hello world&quot; 停止redis服务 1redis-cli shutdown","link":"/2017/11/12/Ubuntu%E5%AE%89%E8%A3%85-redis%EF%BC%8C%E5%B9%B6%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C/"},{"title":"VMware无法打开","text":"vmware安装无法打开内核设备 \\.\\Global\\vmx86: 系统找不到指定的文件按照以下步骤开启相应的服务就好 123456789101112net start vmcinet start vmx86net start VMnetuserifsc config vmci=autosc config vmx86=autosc config VMnetuserif=auto","link":"/2016/06/24/VMware%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80/"},{"title":"VPS 安全措施","text":"一个部署在公网的VPS, 面临不断的网络扫描和攻击, 可以参考如下步骤. 1. 配置SSH安全访问密钥，关闭密码登录a.参考SecureCRT密钥连接Linux，使用SecureCRT在本机生成公私密钥b.在VPS对应的用户目录下，新建.ssh文件夹，并上传公钥，然后更名为authorized_keys，并修改权限，如下 123456mkdir ~/.ssh #如果当前用户目录下没有 .ssh 目录，就先创建目录chmod 700 ~/.sshmv id_rsa.pub ~/.sshcd .sshmv id_rsa.pub authorized_keyschmod 600 authorized_keys c.关闭ssh密码登录 12vim /etc/ssh/sshd_configPasswordAuthentication no #此处改为no d.【可选】添加普通用户 12useradd roubinpasswd roubin e.【可选】禁止root登陆 12vim /etc/ssh/sshd_configPermitRootLogin no #此处改为no f.重启ssh服务 1service sshd restart 2.更改SSH端口及设置1234567vim /etc/ssh/sshd_configPort 22222 #更改默认端口号MaxAuthTries 5PermitEmptyPasswords no #不允许空密码service sshd reloadiptables -I INPUT -p tcp --dport 22222 -j ACCEPT #CentOS 6 中防火墙开启对应端口firewall-cmd --zone=public --add-port=22222/tcp --permanent #CentOS 7 中防火墙开启对应端口 3.锁定口令文件1234[root@localhost /]# chattr +i /etc/passwd[root@localhost /]# chattr +i /etc/shadow[root@localhost /]# chattr +i /etc/group[root@localhost /]# chattr +i /etc/gshadow 4.安装fail2ban防止暴力破解123456789101112apt install -y fail2bancp -pf /etc/fail2ban/jail.conf /etc/fail2ban/jail.localvim /etc/fail2ban/jail.local [sshd]enabled = trueport = 22222logpath = %(sshd_log)sbackend = %(sshd_backend)sfilter = sshdaction = iptables[name=SSH, port=22222, protocol=tcp] sendmail-whois[name=SSH, dest=root, sender=fail2ban@example.com]logpath = /var/log/securemaxretry = 3 5.启用iptables12345678910111213141516171819202122# 清除已有iptables规则iptables -F# 允许本地回环接口(即运行本机访问本机)iptables -A INPUT -i lo -j ACCEPT# 允许已建立的或相关连的通行iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT#允许所有本机向外的访问iptables -A OUTPUT -j ACCEPT# 允许访问22222(SSH)端口，以下几条相同，分别是22222,80,443端口的访问iptables -A INPUT -p tcp --dport 22222 -j ACCEPTiptables -A INPUT -p tcp --dport 80 -j ACCEPTiptables -A INPUT -p tcp --dport 443 -j ACCEPT#如果有其他端口的话，规则也类似，稍微修改上述语句就行#允许pingiptables -A INPUT -p icmp -m icmp --icmp-type 8 -j ACCEPT#禁止其他未允许的规则访问（注意：如果22端口未加入允许规则，SSH链接会直接断开。）iptables -A INPUT -j REJECT iptables -A FORWARD -j REJECT#保存防火墙规则service iptables save#设置防火墙开机启动chkconfig --level 345 iptables on 6.禁用ipv61234567891011121314#编辑/etc/sysconfig/network添加行：NETWORKING_IPV6=no#修改/etc/hosts,把ipv6本地主机名解析的注释掉（可选）：#::1 localhost localhost6 localhost6.localdomain6#禁止系统加载ipv6相关模块，创建modprobe关于禁用ipv6的设定文件/etc/modprobe.d/disable_ipv6.conf(名字随便起)（RHEL6.0之后没有/etc/modprobe.conf这个文件），内容如下，三选其一（本次使用的第一种）：alias net-pf-10 offoptions ipv6 disable=1#禁止开机启动chkconfig ip6tables off#查看ipv6是否被禁用lsmod | grep -i ipv6ifconfig | grep -i inet6 7.阻止百度收录真实位置恩，免得上门查水表 1234567891011121314151617vim /etc/hosts0.0.0.0 api.map.baidu.com0.0.0.0 ps.map.baidu.com0.0.0.0 sv.map.baidu.com0.0.0.0 offnavi.map.baidu.com0.0.0.0 newvector.map.baidu.com0.0.0.0 ulog.imap.baidu.com0.0.0.0 newloc.map.n.shifen.com:: api.map.baidu.com:: ps.map.baidu.com:: sv.map.baidu.com:: offnavi.map.baidu.com:: newvector.map.baidu.com:: ulog.imap.baidu.com:: newloc.map.n.shifen.com","link":"/2018/04/15/VPS-%E5%AE%89%E5%85%A8%E6%8E%AA%E6%96%BD/"},{"title":"Windows手动添加开机启动项","text":"有时安装了绿色的应用, 想要自启动. 有以下三种方式. 方法1.添加程序完整路径到注册表HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run下或者添加到HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run下 方法2.将一个.lnk文件添加到C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Startup目录下 方法3. 使用命令行命令如以下格式（此例为添加TTPlayer.exe为开机启动项）： 1REG ADD HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run /v TTplayerLaunch /t REG_EXPAND_SZ /d &quot;D:\\Program Files\\TTPlayer\\TTPlayer.exe&quot;","link":"/2018/12/12/Windows%E6%89%8B%E5%8A%A8%E6%B7%BB%E5%8A%A0%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E9%A1%B9/"},{"title":"XML的有效性的检测","text":"XML文档的结构良好性验证，结构良好的xml文档，需要遵守下面这些规则： 所有开始标签必须有对应的结束标签 元素可以嵌套，但是不可以重叠 有且只能有一个根元素 属性值必须使用引号 一个元素不能有两个同样属性名字的属性 注释不能出现在标签内部 没有转义的” &lt;” 或者” $”不能出现在元素和属性的字符中 如何检查XML文档良构? 方法一以ElementTree模块为例，直接使用parse方法。如果不报错，这表示该XML是良构的 1234567from xml.etree import ElementTree as ET try: ET.parse('test.xml') print '这是一个良构的XML文档' except Exception,e: print '这不是一个良构的XML文档' print '可能原因：',e 方法二如果希望获取更加详细信息，可使用lxml模块： 1234567import lxml.etree as ET try: ET.parse('test.xml') print '这是一个良构的XML文档' except Exception,e: print '这不是一个良构的XML文档' print '可能原因：',e","link":"/2018/01/31/XML%E7%9A%84%E6%9C%89%E6%95%88%E6%80%A7%E7%9A%84%E6%A3%80%E6%B5%8B/"},{"title":"Xposed is installed but not actived","text":"Xposed framework version 78 is installed, but not active这个现象本人是发生在4C上，系统是CM13,Xposed是V85版本。解决方案如下： 打开Root Explorer 进入到root/data/data/de.robv.android.xposed.installer/conf这个目录下 把名字为disable的文件删除 重启","link":"/2016/08/25/Xposed-is-installed-but-not-actived/"},{"title":"Xshell连接Ubuntu","text":"Windows环境下，在用Xshell连接VM里安装的Ubuntu16的时候连接不上。解决方法如下： Xshell连接VM内的Ubuntu16 Xshell 是一个强大的安全终端模拟软件，它支持SSH1, SSH2, 以及Microsoft Windows 平台的TELNET 协议。Xshell 通过互联网到远程主机的安全连接以及它创新性的设计和特色帮助用户在复杂的网络环境中享受他们的工作。 但是在用SSH连接的时候会发现连接不上，其实这是由于Ubuntu默认不安装openssh服务导致的， 所以若要使用ssh远程登录Ubuntu主机，首先需要安装ssh服务器。 首先，判断Ubuntu是否安装了ssh服务： 首先，判断Ubuntu是否安装了ssh服务：1、输入：#ps -e | grep ssh 如果服务已经启动，则可以看到“sshd”，否则表示没有安装服务，或没有开机启动2、安装ssh服务，输入命令：#sudo apt-get install openssh-server 3、启动服务:#/etc/init.d/ssh start 4、本机测试是否能够成功登录：#ssh -l 用户名 本机ip5、用远程工具进行远程连接，若拒接访问，则关闭防火墙或允许22端口，参考如下。 桥接模式可以使路由器使用DHCP的方式分配IP，如果你的电脑所处的网络拓扑中没有路由器的话也是ping不通的。如果有路由器，因为防火墙导致无法连接，可以使用 sudo ufw disable 命令禁用防火墙。或者在防火墙开启的情况下开放22端口命令是 sudo ufw allow 22","link":"/2016/08/01/Xshell%E8%BF%9E%E6%8E%A5Ubuntu/"},{"title":"Xshell配色方案","text":"Xshell是Windows下很好用的一款SSH软件，但是性冷淡的配色终究还是有点枯燥，分享两个还可以的配色方案。 第一个isayme.xcs 1234567891011121314151617181920212223[isayme]text(bold)=eaeaeamagenta(bold)=ff00fftext=ffffffwhite(bold)=eaeaeagreen=00c000red(bold)=d20000green(bold)=00ff00black(bold)=808080red=c00000blue=113fccblack=000000blue(bold)=0080ffyellow(bold)=ffff00cyan(bold)=00ffffyellow=c0c000magenta=c000c0background=222222white=c0c0c0cyan=00c0c0[Names]count=1name0=isayme 第二个ubuntu.xcs 1234567891011121314151617181920212223[ubuntu]text(bold)=ffffffmagenta(bold)=ad7fa8text=ffffffwhite(bold)=eeeeecgreen=4e9a06red(bold)=ef2929green(bold)=8ae234black(bold)=555753red=cc0000blue=3465a4black=000000blue(bold)=729fcfyellow(bold)=fce94fcyan(bold)=34e2e2yellow=c4a000magenta=75507bbackground=300a24white=d3d7cfcyan=06989a[Names]count=1name0=ubuntu 保存为xcs格式文件就好，然后导入到Xshell 工具——&gt;配色方案——&gt;导入","link":"/2017/01/20/Xshell%E9%85%8D%E8%89%B2%E6%96%B9%E6%A1%88/"},{"title":"adb shell 错误","text":"使用adb shell提示adb server is out of date. killing...? #####是ADB端口被占用了 先执行adb nodaemon server ，查看adb server的端口是多少 12C:\\Users\\xxxx&gt;adb nodaemon server cannot bind 'tcp:5037' 再执行下netstat -ano | findstr &quot;5037&quot; 12345C:\\Users\\xxxxxx&gt;netstat -ano | findstr &quot;5037&quot; TCP 127.0.0.1:5037 0.0.0.0:0 LISTENING 4236 TCP 127.0.0.1:5037 127.0.0.1:49422 ESTABLISHED 搜索4236 TCP 127.0.0.1:49422 127.0.0.1:5037 ESTABLISHED 3840 最后执行tskill 4236即可。","link":"/2015/05/16/adb-shell-%E9%94%99%E8%AF%AF/"},{"title":"fail2ban 简介","text":"fail2ban 可以监视你的系统日志，然后匹配日志的错误信息（正则式匹配）执行相应的屏蔽动作（一般情况下是调用防火墙屏蔽），比如:当有人在试探你的SSH、SMTP、FTP密码，只要达到你预设的次数，fail2ban就会调用防火墙屏蔽这个IP，而且可以发送e-mail通知系统管理员，是一款很实用、很强大的软件。 ####功能和特性1、支持大量服务。如sshd,apache,qmail,proftpd,sasl等等2、支持多种动作。如iptables,tcp-wrapper,shorewall(iptables第三方工具),mail notifications(邮件通知)等等。3、在logpath选项中支持通配符4、需要Gamin支持(注：Gamin是用于监视文件和目录是否更改的服务工具)5、需要安装python,iptables,tcp-wrapper,shorewall,Gamin。如果想要发邮件，那必需安装postfix/sendmail ####安装和配置如果是 CentOS，可以直接yum install fail2ban如果是 Ubuntu，可以直接apt install fail2ban 功能: 12345/etc/fail2ban/action.d #动作文件夹，内含默认文件。iptables以及mail等动作配置/etc/fail2ban/fail2ban.conf #定义了fai2ban日志级别、日志位置及sock文件位置/etc/fail2ban/filter.d #条件文件夹，内含默认文件。过滤日志关键内容设置/etc/fail2ban/jail.conf #主要配置文件，模块化。主要设置启用ban动作的服务及动作阀值/etc/rc.d/init.d/fail2ban #启动脚本文件 主要配置:vi /etc/fail2ban/fail2ban.conf 1234[Definition] loglevel =3 logtarget = SYSLOG #我们需要做的就是把这行改成/var/log/fail2ban.log，方便用来记录日志信息 socket =/var/run/fail2ban/fail2ban.sock vi /etc/fail2ban/jail.conf 123456789101112131415[DEFAULT] #全局设置ignoreip = 127.0.0.1 #忽略的IP列表,不受设置限制bantime = 600 #屏蔽时间，单位：秒findtime = 600 #这个时间段内超过规定次数会被ban掉maxretry = 3 #最大尝试次数backend = auto #日志修改检测机制（gamin、polling和auto这三种） [sshd] #单个服务检查设置，如设置bantime、findtime、maxretry和全局冲突，服务优先级大于全局设置。enabled = true #是否激活此项（true/false）filter = sshd #过滤规则filter的名字，对应filter.d目录下的sshd.confaction = iptables[name=SSH, port=ssh, protocol=tcp]#动作的相关参数，对应action.d/iptables.conf文件logpath = /var/log/secure #检测的日志文件pathbantime = 3600findtime = 300 maxretry = 3 #最大尝试次数 启动 fail2banservice fail2ban start 解除fail2ban绑定的IP 查询限制列表 12345678# iptables -L --line-numbersChain fail2ban-SSH (1references)num target prot opt source destination1 DROP all -- 118.152.158.61.ha.cnc anywhere2 RETURN all -- anywhere anywhere解除限制# iptables -D fail2ban-SSH 1 vi /etc/fail2ban.confSSH防攻击规则: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206ssh-iptables]enabled = truefilter = sshdaction = iptables[name=SSH, port=ssh, protocol=tcp] sendmail-whois[name=SSH, dest=root, sender=fail2ban@example.com, sendername=&quot;Fail2Ban&quot;]logpath = /var/log/securemaxretry = 5[ssh-ddos]enabled = truefilter = sshd-ddosaction = iptables[name=ssh-ddos, port=ssh,sftp protocol=tcp,udp]logpath = /var/log/messagesmaxretry = 2[osx-ssh-ipfw]enabled = truefilter = sshdaction = osx-ipfwlogpath = /var/log/secure.logmaxretry = 5[ssh-apf]enabled = truefilter = sshdaction = apf[name=SSH]logpath = /var/log/securemaxretry = 5[osx-ssh-afctl]enabled = truefilter = sshdaction = osx-afctl[bantime=600]logpath = /var/log/secure.logmaxretry = 5[selinux-ssh]enabled = truefilter = selinux-sshaction = iptables[name=SELINUX-SSH, port=ssh, protocol=tcp]logpath = /var/log/audit/audit.logmaxretry = 5proftp防攻击规则 [proftpd-iptables]enabled = truefilter = proftpdaction = iptables[name=ProFTPD, port=ftp, protocol=tcp] sendmail-whois[name=ProFTPD, dest=you@example.com]logpath = /var/log/proftpd/proftpd.logmaxretry = 6 邮件防攻击规则 [sasl-iptables]enabled = truefilter = postfix-saslbackend = pollingaction = iptables[name=sasl, port=smtp, protocol=tcp] sendmail-whois[name=sasl, dest=you@example.com]logpath = /var/log/mail.log[dovecot]enabled = truefilter = dovecotaction = iptables-multiport[name=dovecot, port=&quot;pop3,pop3s,imap,imaps,submission,smtps,sieve&quot;, protocol=tcp]logpath = /var/log/mail.log[dovecot-auth]enabled = truefilter = dovecotaction = iptables-multiport[name=dovecot-auth, port=&quot;pop3,pop3s,imap,imaps,submission,smtps,sieve&quot;, protocol=tcp]logpath = /var/log/secure[perdition]enabled = truefilter = perditionaction = iptables-multiport[name=perdition,port=&quot;110,143,993,995&quot;]logpath = /var/log/maillog [uwimap-auth]enabled = truefilter = uwimap-authaction = iptables-multiport[name=uwimap-auth,port=&quot;110,143,993,995&quot;]logpath = /var/log/maillog apache防攻击规则 [apache-tcpwrapper]enabled = truefilter = apache-authaction = hostsdenylogpath = /var/log/httpd/error_logmaxretry = 6[apache-badbots]enabled = truefilter = apache-badbotsaction = iptables-multiport[name=BadBots, port=&quot;http,https&quot;] sendmail-buffered[name=BadBots, lines=5, dest=you@example.com]logpath = /var/log/httpd/access_logbantime = 172800maxretry = 1[apache-shorewall]enabled = truefilter = apache-noscriptaction = shorewall sendmail[name=Postfix, dest=you@example.com]logpath = /var/log/httpd/error_log nginx防攻击规则 [nginx-http-auth]enabled = truefilter = nginx-http-authaction = iptables-multiport[name=nginx-http-auth,port=&quot;80,443&quot;]logpath = /var/log/nginx/error.log lighttpd防规击规则 [suhosin]enabled = truefilter = suhosinaction = iptables-multiport[name=suhosin, port=&quot;http,https&quot;]# adapt the following two items as neededlogpath = /var/log/lighttpd/error.logmaxretry = 2[lighttpd-auth]enabled = truefilter = lighttpd-authaction = iptables-multiport[name=lighttpd-auth, port=&quot;http,https&quot;]# adapt the following two items as neededlogpath = /var/log/lighttpd/error.logmaxretry = 2 vsftpd防攻击规则 [vsftpd-notification]enabled = truefilter = vsftpdaction = sendmail-whois[name=VSFTPD, dest=you@example.com]logpath = /var/log/vsftpd.logmaxretry = 5bantime = 1800[vsftpd-iptables]enabled = truefilter = vsftpdaction = iptables[name=VSFTPD, port=ftp, protocol=tcp] sendmail-whois[name=VSFTPD, dest=you@example.com]logpath = /var/log/vsftpd.logmaxretry = 5bantime = 1800 pure-ftpd防攻击规则 [pure-ftpd]enabled = truefilter = pure-ftpdaction = iptables[name=pure-ftpd, port=ftp, protocol=tcp]logpath = /var/log/pureftpd.logmaxretry = 2bantime = 86400 mysql防攻击规则 [mysqld-iptables]enabled = truefilter = mysqld-authaction = iptables[name=mysql, port=3306, protocol=tcp] sendmail-whois[name=MySQL, dest=root, sender=fail2ban@example.com]logpath = /var/log/mysqld.logmaxretry = 5 apache phpmyadmin 防攻击规则 [apache-phpmyadmin]enabled = truefilter = apache-phpmyadminaction = iptables[name=phpmyadmin, port=http,https protocol=tcp]logpath = /var/log/httpd/error_logmaxretry = 3# /etc/fail2ban/filter.d/apache-phpmyadmin.conf将以下内容粘贴到apache-phpmyadmin.conf里保存即可以创建一个apache-phpmyadmin.conf文件.# Fail2Ban configuration file## Bans bots scanning for non-existing phpMyAdmin installations on your webhost.## Author: Gina Haeussge# [Definition] docroot = /var/wwwbadadmin = PMA|phpmyadmin|myadmin|mysql|mysqladmin|sqladmin|mypma|admin|xampp|mysqldb|mydb|db|pmadb|phpmyadmin1|phpmyadmin2 # Option: failregex# Notes.: Regexp to match often probed and not available phpmyadmin paths.# Values: TEXT#failregex = [[]client []] File does not exist: %(docroot)s/(?:%(badadmin)s) # Option: ignoreregex# Notes.: regex to ignore. If this regex matches, the line is ignored.# Values: TEXT#ignoreregex = 重启 fail2ban 服务：service fail2ban restart PS：写在最后，在安装完fail2ban后请立即重启一下fail2ban,看是不是能正常启动，因为在后边我们配置完规则后如果发生无法启动的问题我们可以进行排查.如果安装完后以默认规则能够正常启动，而配置完规则后却不能够正常启动，请先检查一下你 /var/log/ 目录下有没有规则里的 logpath= 后边的文件，或者这个文件的路径与规则里的是不是一致. 如果不一致请在 logpath 项那里修改你的路径， 如果你的缓存目录里没有这个文件，那么请你将该配置项的 enabled 项目的值设置为 false. 然后再进行重启fail2ban，这样一般不会有什么错误了 fail2ban的介绍","link":"/2017/08/27/fail2ban-%E7%AE%80%E4%BB%8B/"},{"title":"fail2ban阻止SSH暴力破解","text":"引用:fail2ban阻止SSH暴力破解 ​ fail2ban是由Python语言开发监控软件，通过监控系统日志的登录信息来调用iptables屏蔽相应登录IP，以阻止某个IP（fail2ban读对应日志文件，Debian/Ubuntu:/var/log/auth.log、CentOS/Redhat:/var/log/secure）不停尝试密码。fail2ban在防御对SSH服务器的暴力密码破解上非常有用。经过网友强烈要求，已经集成到《OneinStack》 安装配置Fail2ban使用《OneinStack》，内置fail2ban，一键安装并设置好即可 123wget mirrors.linuxeye.com/oneinstack.tar.gzpushd oneinstack./addons.sh #选择11，安装fail2ban Fail2ban配置文件说明1234567891011[root@OneinStack ~]# cat /etc/fail2ban/jail.local[DEFAULT]ignoreip = 127.0.0.1/8 #指定哪些地址可以忽略 fail2ban 防御bantime = 86400 #客户端主机被禁止的时长（秒）findtime = 600 #查找失败次数的时长（秒）maxretry = 5 #客户端主机被禁止前允许失败的次数[ssh-iptables]enabled = truefilter = sshdaction = iptables[name=SSH, port=22, protocol=tcp]logpath = /var/log/secure fail2ban会自动禁止在最近10分钟内有超过5次访问尝试失败的任意IP地址。这个IP地址将会在24小时内一直被禁止访问SSH服务。安装设置启用后，Fail2ban会在iptables添加相关规则，如下： fail2ban测试ssh 你的服务器IP，输错密码5次以上，查看日志/var/log/fail2ban.log [ssh-iptables] Ban 91.195.103.166即被禁用 fail2ban状态/usr/local/python/bin/fail2ban-client status ssh-iptables 显示出被禁止IP地址列表 fail2ban解锁IP为了解锁特定的IP地址命令： /usr/local/python/bin/fail2ban-client set ssh-iptables unbanip 91.195.103.166","link":"/2018/02/06/fail2ban%E9%98%BB%E6%AD%A2SSH%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/"},{"title":"hexo 教程1：hexo简介","text":"#####什么是hexo? Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 #####为什么要用hexo? 不可思议的快速 ─ 只要一眨眼静态文件即生成完成支持 Markdown仅需一道指令即可部署到 GitHub Pages 和 Heroku已移植 Octopress 插件高扩展性、自订性兼容于 Windows, Mac &amp; Linux 个人感觉：1.轻。文件不多，方便理解（虽然我折腾了好久，没办法，笨），容易自定义。2.易用。如果平时就写点文章，差不多就用到，hexo new “” hexo g -d。3.使用的用户还是蛮多的，大部分问题都能直接google解决。4.有中文文档。虽然做的潦草，但是还是能解决不少问题的。 hexo官网 ###如何搭建一个hexo博客呢？下篇介绍。","link":"/2015/04/24/hexo-%E6%95%99%E7%A8%8B1%EF%BC%9Ahexo%E7%AE%80%E4%BB%8B/"},{"title":"hexo 添加多说教程","text":"**在hexo中添加多说的使用模块，使用步骤如下：**在_config.yml中添加多说的配置： duoshuo_shortname: 你站点的short_name修改themes\\landscape\\layout\\_partial\\article.ejs模板 把 1234567&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname){ %&gt;&lt;section id=&quot;comments&quot;&gt; &lt;div id=&quot;disqus_thread&quot;&gt; &lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;//disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt; &lt;/div&gt;&lt;/section&gt;&lt;% } %&gt; 改为 1234567891011121314151617181920&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.duoshuo_shortname){ %&gt; &lt;section id=&quot;comments&quot;&gt; &lt;!-- 多说评论框 start --&gt; &lt;div class=&quot;ds-thread&quot; data-thread-key=&quot;&lt;%= post.layout %&gt;-&lt;%= post.slug %&gt;&quot; data-title=&quot;&lt;%= post.title %&gt;&quot; data-url=&quot;&lt;%= page.permalink %&gt;&quot;&gt;&lt;/div&gt; &lt;!-- 多说评论框 end --&gt; &lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt; &lt;script type=&quot;text/javascript&quot;&gt; var duoshuoQuery = {short_name:'&lt;%= config.duoshuo_shortname %&gt;'}; (function() { var ds = document.createElement('script'); ds.type = 'text/javascript';ds.async = true; ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js'; ds.charset = 'UTF-8'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds); })(); &lt;/script&gt; &lt;!-- 多说公共JS代码 end --&gt; &lt;/section&gt; &lt;% } %&gt;","link":"/2015/04/24/hexo-%E6%B7%BB%E5%8A%A0%E5%A4%9A%E8%AF%B4%E6%95%99%E7%A8%8B/"},{"title":"hexo 教程4:添加评论代码等优化","text":"#####添加多说评论hexo默认使用国外比较流行的disqus，不过，按照“因地制宜”的原则，我们修改为国内用的多又好用的“多说”评论系统。步骤非常简单：1.在 多说进行注册，获得通用代码。2.将通用代码粘贴到themes\\light\\layout\\_partial\\comment.ejs里面，如下： 12345&lt;% if ( page.comments){ %&gt;&lt;section id=&quot;comment&quot;&gt;通用代码&lt;/section&gt;&lt;% } %&gt; #####添加&lt;页面导航&gt;在刚才添加「多说」评论的文件中，加入一段代码，如下： 123456789101112&lt;% if ( page.comments){ %&gt; &lt;nav id=&quot;pagination&quot; &gt; &lt;% if (page.prev) { %&gt; &lt;a href=&quot;&lt;%- config.root %&gt;&lt;%- page.prev.path %&gt;&quot; class=&quot;alignleft prev&quot; &gt;&lt;%= __('prev') %&gt;&lt;/a&gt; &lt;% } %&gt; &lt;% if (page.next) { %&gt; &lt;a href=&quot;&lt;%- config.root %&gt;&lt;%- page.next.path %&gt;&quot; class=&quot;alignright next&quot; &gt;&lt;%= __('next') %&gt;&lt;/a&gt; &lt;% } %&gt; &lt;div class=&quot;clearfix&quot;&gt;&lt;/div&gt;&lt;/nav&gt;&lt;section id=&quot;comment&quot;&gt; #####添加小图标在themes/light/layout/_partial/head.ejs里将&lt;link href=&quot;&lt;%- config.root %&gt;favicon.png&quot; rel=&quot;icon&quot;&gt;替换为&lt;link href=&quot;&lt;%- config.root %&gt;favicon.ico&quot; rel=&quot;icon&quot; type=&quot;image/x-ico&quot;&gt;。将favicon.ico图标文件放在source目录下。 #####导航栏添加”关于”1.hexo new page &quot;about&quot;2.到source/about/index.md编辑内容。3.在themes/light/_config.yml中，添加如下： 12menu: 关于: /about","link":"/2015/05/04/hexo-%E6%95%99%E7%A8%8B4%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E4%BB%A3%E7%A0%81%E7%AD%89%E4%BC%98%E5%8C%96/"},{"title":"Hexo教程 error","text":"​ MacBook在安装好 hexo 和 node 之后，还是会出现如下的错误。 12345678910全局已经安装hexo，当前项目下也装了blog git:(master) ✗ hexo{ [Error: Cannot find module './build/Release/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' }{ [Error: Cannot find module './build/default/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' }{ [Error: Cannot find module './build/Debug/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' }{ [Error: Cannot find module './build/Release/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' }{ [Error: Cannot find module './build/default/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' }{ [Error: Cannot find module './build/Debug/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' }ERROR Local hexo not found in ~/Documents/DATA/github/blogERROR Try running: 'npm install hexo --save' 可以尝试如下的方式，我已经解决。 12345$ npm install hexo --no-optionalif it doesn't worktry$ npm uninstall hexo-cli -g$ npm install hexo-cli -g","link":"/2017/02/12/hexo%E6%95%99%E7%A8%8B-error/"},{"title":"hexo 教程2：搭建hexo博客","text":"注意:本教程都是在Windows环境下操作的。 安装 Gitgit下载 安装Node.js在Windows下安装Node.js非常方便，只要下载安装执行文件就行。Node.js的安装文件根据系统版本进行选择下载。 安装hexo利用 npm 命令即可安装。注意：在你想要的位置新建一个文件夹，然后右击选择Git Bash然后输入：npm install -g hexo之后初始化hexo:hexo init 安装依赖包npm installHexo 3.0把服务器独立成了个别模块，必须先安装hexo-server才能使用npm install hexo-server --save 本地查看现在已经搭建起本地的hexo博客了，执行以下命令，然后到浏览器输入localhost:4000就可以看到博客了。hexo generatehexo server 至此，本地的hexo博客就搭建起来了。下面部署到github或者gitcafe上。注册一个github或者gitcafe的账户，然后新建一个repository，名字应该是username.github.io 部署编辑_config.yml(在博客文件夹下)。部署时，要把下面的username都换成本人的账号名。 1234deploy: type: git repository: https://github.com/username/username.github.io.git branch: master 然后部署 12hexo generatehexo deploy **PS:**每次修改任何文件都要hexo generate来保存在浏览器输入username.githu.io就能看到博客了。 如何配置博客，如何撰写和发表文章。下篇介绍。","link":"/2015/04/25/hexo%E6%95%99%E7%A8%8B2%EF%BC%9A%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/"},{"title":"iTerm2保持 SSH 连接","text":"使用 iTerm2的时候，在 SSH 连接 VPS 过程中，要是有段时间不操作就会断开连接。其中要是有写了一半的数据，那就呵呵呵了。有两种方法暂时可以解决该问题。 第一种方法： iTerm2 中有一个选项： When idle, send ASCII code 0 every 10 seconds，其中，ASCII code 和时间可指定。 这样定时操作一下保持SSH 连接，但是有副作用： 一些命令行输出中会有不期待出现的字符； Vi 中会插入一些不想要的内容 第二种方法： 正确的做法是，通过配置 ServerAliveInterval 来实现，在 ~/.ssh/config 中加入： 1ServerAliveInterval=30 如果没有config文件，那就新建一个。要修改该文件的权限，否则配置将不起作用： 1chmod 600 ~/.ssh/config 当然，各个服务器的配置不一样，也可以做差异化的配置，以减少不必要的发包： 12Host *hostname.com ServerAliveInterval 60 以上就能解决了。","link":"/2017/04/20/iTerm2%E4%BF%9D%E6%8C%81-SSH-%E8%BF%9E%E6%8E%A5/"},{"title":"hexo 教程3:博客的配置、使用","text":"本地和github搭建起了自己的hexo博客站点，但是还未发表过文章，站点的配置还是原来的默认值。在本节，来进行个性化的设置，将站点打造成自己的个性化站点，并发表文章。 站点配置用到两个文件，一个是对整站的配置\\hexo\\_config.yml，另一个是对主题的配置\\hexo\\themes\\light_config.yml，分别介绍。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485# Hexo Configuration## Docs: http://zespia.tw/hexo/docs/configure.html## Source: https://github.com/tommy351/hexo/# Sitetitle: Zippera's blog #站点名，站点左上角subtitle: Walk steps step by step #副标题，站点左上角description: Walk steps step by step #给搜索引擎看的，对站点的描述，可以自定义author: zippera #在站点左下角可以看到email: #你的联系邮箱language: zh-CN #中文# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://zipperary.comroot: /permalink: :year/:month/:day/:title/tag_dir: tagsarchive_dir: archivescategory_dir: categories# Writing 文章布局、写作格式的定义，不修改new_post_name: :title.md # File name of new postsdefault_layout: postauto_spacing: false # Add spaces between asian characters and western characterstitlecase: false # Transform title into titlecasemax_open_file: 100filename_case: 0highlight: enable: true backtick_code_block: true line_number: true tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Archives 默认值为2，这里都修改为1，相应页面就只会列出标题，而非全文## 2: Enable pagination## 1: Disable pagination## 0: Fully Disablearchive: 1category: 1tag: 1# Server 不修改## Hexo uses Connect as a server## You can customize the logger format as defined in## http://www.senchalabs.org/connect/logger.htmlport: 4000logger: falselogger_format:# Date / Time format 日期格式，不修改## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: MMM D YYYYtime_format: H:mm:ss# Pagination 每页显示文章数，可以自定义，将10改成了5## Set per_page to 0 to disable paginationper_page: 5pagination_dir: page# Disqus Disqus插件，会替换成“多说”，不修改disqus_shortname:# Extensions 这里配置站点所用主题和插件，暂默认## Plugins: https://github.com/tommy351/hexo/wiki/Plugins## Themes: https://github.com/tommy351/hexo/wiki/Themestheme: lightexclude_generator:plugins:- hexo-generator-feed- hexo-generator-sitemap# Deployment 站点部署到github要配置## Docs: http://zespia.tw/hexo/docs/deploy.htmldeploy: type: github repository: https://github.com/zippera/zippera.github.io.git branch: master 可以hexo generate，hexo server，打开localhost:4000查看效果了。 1234567891011121314151617181920212223242526272829303132333435363738menu: #站点右上角导航栏，暂时默认，后面介绍修改 首页: / 存档: /archives 关于: /about ToDo: /todolist widgets: #站点右边栏，暂时默认，后面介绍修改和添加- search- category- tagcloud- weibo- blogrollexcerpt_link: 阅读全文 #替换为中文plugins: twitter: #右边栏要显示twitter展示的话，需要在此设置 username: moxie198 show_replies: false tweet_count: 5 addthis: #SNS分享，身在天朝，当然用“百度分享”，暂时默认，后面会介绍 enable: true pubid: facebook: true twitter: true google: true pinterest: truefancybox: true #图片效果，默认google_analytics: #要使用google_analytics进行统计的话，这里需要配置ID，暂时默认，后面介绍rss: #生成RSS，需要配置路径，暂时默认，后面介绍 好了，站点配置好了，我想发表一篇文章，怎么做呢？ hexo new “my new post” 在\\hexo\\source\\_posts中打开这个文件（打开方式用“记事本”即可），配置开头。 12345title: my new post #可以改成中文的，如“新文章”date: 2013-05-29 07:56:29 #发表日期，一般不改动categories: blog #文章文类tags: [博客，文章] #文章标签，多于一项时用这种格式--- #####下一节介绍优化","link":"/2015/04/28/hexo%E6%95%99%E7%A8%8B3%EF%BC%9A%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%85%8D%E7%BD%AE%E3%80%81%E4%BD%BF%E7%94%A8/"},{"title":"iTunes无法连接iPhone","text":"iPhone连接电脑后可以查看照片但iTunes无反应 右键点击 计算机（或者 我的电脑）－管理－设备管理器，直接到 设备管理器－便携设备 或 图像处理设备 下面，找到带有Apple 或 iPhone 字样的设备，右键点击，更新驱动程序－浏览以查找－从计算机的列表中选择－从磁盘安装－浏览至C:\\Program Files\\Common Files\\Apple\\Mobile Device Support\\Drivers，找到usbaapl.inf，确定。 如何解决iTunes 提示“发生未知错误-50”","link":"/2016/02/16/iTunes%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5iPhone/"},{"title":"Install PyQt5 for Macbook","text":"一份关于在 Macbook 上安装 PyQt5 的介绍和汇总。主要 1、 首先安装基础软件 这个基本是使用 MacBook 的必备软件套件。Xcode下载 安装 Homebrew，这样后续可以节省不少时候，安装管理也会很方便。 1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; Homebrew 会将软件包安装到独立目录，并将其文件软链接至 /usr/local 。 12345678$ cd /usr/local$ find CellarCellar/wget/1.16.1Cellar/wget/1.16.1/bin/wgetCellar/wget/1.16.1/share/man/man1/wget.1$ ls -l binbin/wget -&gt; ../Cellar/wget/1.16.1/bin/wget 用上面安装好的 Homebrew 来安装 PyQt5 和 Python 不推荐用 Xcode 自带的 Python，因为模块管理每次都需要输入密码比较麻烦 12$ brew install python3$ brew install sip 用上面安装好的 Python3 的 pip3 模块来安装所需模块 1$ pip3 install pyqt5 安装 Qt 这个我直接选择的是去官网下载免费的开源版本。需要回答几个问题，注册个账号。 Qt 下载页面选择对的系统版本。 以上：基础软件到此基本就安装好了。Qt 也自带Qt Creater 这个 IDE。 但是，最好的 IDE除了神级的 VS，就是JetBrain 家族的了。写 Python 当然最好是 PyCharm了。所以还想继续折腾的，参考以下链接。 参考链接： Python - Mac下PyCharm&amp;PyQt5环境搭建 Guide to install PyQt5 on Mac OS X with python 3.4 virtualenv","link":"/2017/06/20/install-PyQt5-for-Macbook/"},{"title":"iTunes 搜索 API","text":"这个搜索API允许你通过关键词在你的网站上搜索iTunes Store，App Store, iBooks Store and Mac App Store。你可以搜索各种内容；包括应用、图书、电影、广播、音乐、视频、有声读物以及TV节目。你也可以调用一个实名查询请求来创建内容库之间的映射和数字目录。开发者可以使用API里的推广的内容，包括歌曲预览，音乐录像，专辑封面和APP图标只用在推广的店面，不用于娱乐用途。从API里使用音乐样本及其他必须和店面徽章相似。条款和条件适用。 这项计划允许当你的网站或者app获得点击后获得一些佣金。该项计划更多信息请查看：http://www.apple.com/itunes/affiliates。 通过web去查找并且显示结果在web网站上。你必须创建一个搜索区域，通过完全限定的URL请求iTunes Store，并从返回的结果中解析JSON。然后将结果显示在web上。 完整的网址必须有以下格式： https://itunes.apple.com/search?parameterkeyvalue 在参数里有一个或多个键值对，来详细说明你返回的结果。 构造一个参数键值对，你必须将每个参数的key等于（=）一个字符串value。例如：key1 =value1。创建一个字符串键值对，你必须将每对键值对用与（&amp;）符号链接。例如:key1=value1&amp;key2=value2&amp;key3=value3 注：当您为网站创建搜索域和脚本时，你应该使用动态脚本标签你的XMLHTTP脚本调用请求。例如: key1=value1 您可以使用下表定义的参数的key和value来搜索iTunes Store，App Store，iBooks商店和Mac App Store里面的内容： Parameter Key Description Required Values term The URL-encoded text string you want to search for. For example: jack+johnson. Y Any URL-encoded text string. Note: URL encoding replaces spaces with the plus (+) character and all characters except the following are encoded: letters, numbers, periods (.), dashes (-), underscores (_), and asterisks (*). country The two-letter country code for the store you want to search. The search uses the default store front for the specified country. For example: US. The default is US. Y See http://en.wikipedia.org/wiki/ ISO_3166-1_alpha-2 for a list of ISO Country Codes. media The media type you want to search for. For example: movie. The default is all. N movie, podcast, music, musicVideo, audiobook, shortFilm, tvShow, software, ebook, all entity The type of results you want returned, relative to the specified media type. For example: movieArtist for a movie media type search. The default is the track entity associated with the specified media type. N The following entities are available for each media type:moviemovieArtist, moviepodcastpodcastAuthor, podcastmusicmusicArtist, musicTrack, album, musicVideo, mix, song Please note that “musicTrack” can include both songs and music videos in the resultsmusicVideomusicArtist, musicVideoaudiobookaudiobookAuthor, audiobookshortFilmshortFilmArtist, shortFilmtvShowtvEpisode, tvSeasonsoftwaresoftware, iPadSoftware, macSoftwareebookebookallmovie, album, allArtist, podcast, musicVideo, mix, audiobook, tvSeason, allTrack attribute The attribute you want to search for in the stores, relative to the specified media type. For example, if you want to search for an artist by name specify entity=allArtist&amp;attribute=allArtistTerm. In this example, if you search for term=maroon, iTunes returns “Maroon 5” in the search results, instead of all artists who have ever recorded a song with the word “maroon” in the title.The default is all attributes associated with the specified media type. N The following attributes are available for each media type:movieactorTerm, genreIndex, artistTerm, shortFilmTerm, producerTerm, ratingTerm, directorTerm, releaseYearTerm, featureFilmTerm, movieArtistTerm, movieTerm, ratingIndex, descriptionTermpodcasttitleTerm, languageTerm, authorTerm, genreIndex, artistTerm, ratingIndex, keywordsTerm, descriptionTermmusicmixTerm, genreIndex, artistTerm, composerTerm, albumTerm, ratingIndex, songTermmusicVideogenreIndex, artistTerm, albumTerm, ratingIndex, songTermaudiobooktitleTerm, authorTerm, genreIndex, ratingIndexshortFilmgenreIndex, artistTerm, shortFilmTerm, ratingIndex, descriptionTermsoftwaresoftwareDevelopertvShowgenreIndex, tvEpisodeTerm, showTerm, tvSeasonTerm, ratingIndex, descriptionTermallactorTerm, languageTerm, allArtistTerm, tvEpisodeTerm, shortFilmTerm, directorTerm, releaseYearTerm, titleTerm, featureFilmTerm, ratingIndex, keywordsTerm, descriptionTerm, authorTerm, genreIndex, mixTerm, allTrackTerm, artistTerm, composerTerm, tvSeasonTerm, producerTerm, ratingTerm, songTerm, movieArtistTerm, showTerm, movieTerm, albumTerm callback The name of the Javascript callback function you want to use when returning search results to your website. For example: wsSearchCB. Y, for cross-site searches wsSearchCB limit The number of search results you want the iTunes Store to return. For example: 25.The default is 50. N 1 to 200 lang The language, English or Japanese, you want to use when returning search results. Specify the language using the five-letter codename. For example: en_us.The default is en_us (English). N en_us, ja_jp version The search result key version you want to receive back from your search.The default is 2. N 1, 2 explicit A flag indicating whether or not you want to include explicit content in your search results.The default is Yes. N Yes, No 关键是要正确编码你的URL才能被委托会员链接。在编码原始链接附属票据可以在Advanced Affiliate Linking的文档中找到。 为了提高请求时间，通过指定适当的limit参数，在检索api的时候返回极少数的结果。 大型网站应该建立缓存逻辑，检索查找api的请求。为了说明这一点，请稍后查看本篇文章的Caching Architecture。 以下是具体的搜索请求完全合格的URL的例子： 要搜索所有杰克·约翰逊的音频和视频内容（电影，播客，音乐，音乐视频，有声读物，电影短片和电视节目），您的网址将如下所示： https://itunes.apple.com/search?term=jack+johnson 要搜索所有杰克·约翰逊的音频和视频内容（电影，播客，音乐，音乐视频，有声读物，电影短片和电视节目），并且只返回前25条。您的网址将如下所示： https://itunes.apple.com/search?term=jack+johnson&amp;limit=25 要检索杰克·约翰逊的音频，您的网址将如下所示： https://itunes.apple.com/search?term=jack+johnson&amp;entity=musicVideo 要搜索所有吉姆·琼斯音频和视频内容，并返回只从加拿大iTunes商店的结果，您的网址将如下所示： https://itunes.apple.com/search?term=jim+jones&amp;country=ca 要搜索名为“Yelp的”应用程序和来自美国的iTunes商店只返回的结果，您的网址将如下所示： https://itunes.apple.com/search?term=yelp&amp;country=us&amp;entity=software 你也可以创建一个基于iTunes IDs, UPCs/ EANs的搜索请求去商店里面搜索内容。和所有音乐指南（AMG）标识的存储内容。基于ID的查找速度更快，而且含有较少的假阳性结果。 以下是具体的查找请求完全合格的URL的例子： 通过iTunes艺术家ID查找杰克·约翰逊： https://itunes.apple.com/lookup?id=909253 通过iTunes ID查找Yelp的软件应用程序： https://itunes.apple.com/lookup?id=284910350 通过AMG艺术家ID查找杰克·约翰逊： https://itunes.apple.com/lookup?amgArtistId=468749 通过AMG艺术家的ID查找多个艺术家： https://itunes.apple.com/lookup?amgArtistId=468749,5723 查找的杰克·约翰逊的所有专辑： https://itunes.apple.com/lookup?id=909253&amp;entity=album 其AMG艺术家的ID查找多个艺术家和获得每个艺术家的前5张专辑： https://itunes.apple.com/lookup?amgArtistId=468749,5723&amp;entity=album&amp;limit=5 通过AMG艺术家的ID查找多个艺术家和获得每个艺术家的5最新歌曲： https://itunes.apple.com/lookup?amgArtistId=468749,5723&amp;entity=song&amp;limit=5&amp;sort=recent 通过UPC查找一个专辑或视频： https://itunes.apple.com/lookup?upc=720642462928 通过UPC查找专辑，包括这张专辑的曲目： https://itunes.apple.com/lookup?upc=720642462928&amp;entity=song 通过专辑ID来查找一个专辑： https://itunes.apple.com/lookup?amgAlbumId=15175,15176,15177,15178,15183,15184,15187,1519,15191,15195,15197,15198 通过AMG视频ID查找一部电影： https://itunes.apple.com/lookup?amgVideoId=17120 通过13位ISBN查找一本书： https://itunes.apple.com/lookup?isbn=9780316069359 了解搜索结果你搜索的结果用JSON格式返回，JSON有两种结构： 一种key/value的集合。也可以称之为一种对象，这个概念类似于Java Map对象，一个Javascript字典，或Pearl/ Ruby的哈希值。对象是一个无序的名称/值对，用左括号开始（{）和一个右括号结束（}）。每个名称由双引号包围，后跟一个冒号（:)）;名称/值对用逗号（，）隔开。 值的有序列表，也称为阵列。数组是值的有序集合，用左括号开头（[），并以右括号结束（]）。值用逗号（，）分隔。 所有的JSON结果被编码为UTF-8。有关JSON的更多信息，请参阅http://www.json.org。 下面的示例显示在iTunes Store的歌曲JSON的结果 1234567891011121314151617181920212223242526272829{&quot;wrapperType&quot;:&quot;track&quot;, &quot;kind&quot;:&quot;song&quot;, &quot;artistId&quot;:909253, &quot;collectionId&quot;:120954021, &quot;trackId&quot;:120954025, &quot;artistName&quot;:&quot;Jack Johnson&quot;, &quot;collectionName&quot;:&quot;Sing-a-Longs and Lullabies for the Film Curious George&quot;, &quot;trackName&quot;:&quot;Upside Down&quot;, &quot;collectionCensoredName&quot;:&quot;Sing-a-Longs and Lullabies for the Film Curious George&quot;, &quot;trackCensoredName&quot;:&quot;Upside Down&quot;, &quot;artistViewUrl&quot;:&quot;https://itunes.apple.com/WebObjects/MZStore.woa/wa/viewArtist?id=909253&quot;, &quot;collectionViewUrl&quot;:&quot;https://itunes.apple.com/WebObjects/MZStore.woa/wa/viewAlbum?i=120954025&amp;id=120954021&amp;s=143441&quot;, &quot;trackViewUrl&quot;:&quot;https://itunes.apple.com/WebObjects/MZStore.woa/wa/viewAlbum?i=120954025&amp;id=120954021&amp;s=143441&quot;, &quot;previewUrl&quot;:&quot;http://a1099.itunes.apple.com/r10/Music/f9/54/43/mzi.gqvqlvcq.aac.p.m4p&quot;, &quot;artworkUrl60&quot;:&quot;http://a1.itunes.apple.com/r10/Music/3b/6a/33/mzi.qzdqwsel.60x60-50.jpg&quot;, &quot;artworkUrl100&quot;:&quot;http://a1.itunes.apple.com/r10/Music/3b/6a/33/mzi.qzdqwsel.100x100-75.jpg&quot;, &quot;collectionPrice&quot;:10.99, &quot;trackPrice&quot;:0.99, &quot;collectionExplicitness&quot;:&quot;notExplicit&quot;, &quot;trackExplicitness&quot;:&quot;notExplicit&quot;, &quot;discCount&quot;:1, &quot;discNumber&quot;:1, &quot;trackCount&quot;:14, &quot;trackNumber&quot;:1, &quot;trackTimeMillis&quot;:210743, &quot;country&quot;:&quot;USA&quot;, &quot;currency&quot;:&quot;USD&quot;, &quot;primaryGenreName&quot;:&quot;Rock&quot;} 下表定义了JSON格式返回结果的键和值： Result Key Description Returned Return Values and Examples wrapperType The name of the object returned by the search request. Y track, collection, artistFor example: track. *explicitness The Recording Industry Association of America (RIAA) parental advisory for the content returned by the search request.For more information, see http://itunes.apple.com/WebObjects/MZStore.woa/wa/parentalAdvisory. Y explicit (explicit lyrics, possibly explicit album cover), cleaned (explicit lyrics “bleeped out”), notExplicit (no explicit lyrics)For example: “trackExplicitness”:”notExplicit”. kind The kind of content returned by the search request. Y book, album, coached-audio, feature-movie, interactive- booklet, music-video, pdf podcast, podcast-episode, software-package, song, tv- episode, artistFor example: song. trackName The name of the track, song, video, TV episode, and so on returned by the search request. Y For example: “Banana Pancakes”. artistName The name of the artist returned by the search request. Y For example: Jack Johnson. collectionName The name of the album, TV season, audiobook, and so on returned by the search request. Y For example: “In Between Dreams”. *censoredName The name of the album, TV season, audiobook, and so on returned by the search request, with objectionable words *’d out.Note: Artist names are never censored. Y For example: “S**t Happens”. artworkUrl100, artworkUrl60 A URL for the artwork associated with the returned media type, sized to 100×100 pixels or 60×60 pixels. Only returned when artwork is available For example: “http:// a1.itunes.apple.com/jp/r10/Music/ y2005/m06/d03/h05/ s05.oazjtxkw.100×100-75.jpg”. *viewURL A URL for the content associated with the returned media type. You can click the URL to view the content in the iTunes Store. Y For example: “http:// itunes.apple.com/WebObjects/ MZStore.woa/wa/viewAlbum? i=68615807&amp;id=68615813&amp;s=1434 62”. previewUrl A URL referencing the 30-second preview file for the content associated with the returned media type. . Only returned when media type is track For example: “http:// a392.itunes.apple.com/jp/r10/ Music/y2005/m06/d03/h05/s05.zdzqlufu.p.m4p”. trackTimeMillis The returned track’s time in milliseconds. Only returned when media type is track 缓存框架 法律声明 开发人员可以使用某些促销内容，可以通过苹果公司提供，包括歌曲预览和音乐视频，专辑封面，和App图标（“促销内容”），促进了促销内容的主题的目的;提供了这种促销内容： （一）被放置仅在促进该促销内容是基于内容页面; （二）是接近了“iTunes下载”，“下载的应用程序商店”或“下载的iBooks商店”标志（如批准苹果公司）充当直接链接到iTunes中或App Store页面，消费者可以购买该宣传内容; （三）包括归属指示促销内容是“提供了iTunes的礼遇”如果这样的促销内容包括歌曲或音乐视频预览; （四）仅流，而不是下载，保存，缓存，或者与视频同步，如果这样的促销内容包括歌曲或音乐视频预览; （五）不用于除了其促销目的独立娱乐价值 （六）不用于促进任何其他商品或服务。开发商承认，苹果提供的促销内容的“原样”，并拒绝任何和所有陈述或担保，包括但不限于非侵权。开发者应将与促销内容到苹果在收到立即连接收到任何索赔，并将根据要求苹果公司立刻删除任何促销内容。 本协议和您的宣传内容使用受加利福尼亚州法律管辖。","link":"/2018/08/15/iTunes-%E6%90%9C%E7%B4%A2-API/"},{"title":"macOS 备份提速","text":"macOS的Time Machine是 Mac 上最方便的备份工具了，免费和无缝备份。 然而使用Time Machine备份系统资料时，发现备份速度非常慢，跟本地的网络也不匹配，甚至有时花费超过 48 小时都无法完成，即便接了网线、关掉所有 APP 后，备份速度都没有明显提升。 macOS 本身对其进行了限流的措施，对硬盘读写的频率和内存使用都做了一定的限制，主要是为了防止在备份期间影响了用户正常使用电脑工作。 macOS 的Time Machine备份加速命令 1sudo sysctl debug.lowpri_throttle_enabled=0 如果觉得影响了资源，可以使用以下命令进行恢复限制 1sudo sysctl debug.lowpri_throttle_enabled=1","link":"/2021/04/26/mac-OS-%E5%A4%87%E4%BB%BD%E6%8F%90%E9%80%9F/"},{"title":"macOS 虚拟桌面黑屏","text":"有几次出现如图的情况，以为是iTerm的问题，但是在关闭软件，重启之后，依旧无效。 后面经过网友告知，才知道是虚拟桌面的问题。 为了清理这个问题，有以下两种方法 在终端输入以下命令 12sudo rm ~/Library/Preferences/com.apple.spaces.plistsudo restart 重置Dock初始状态 123sudo rm ~/Library/Preferences/com.apple.spaces.plistsudo rm ~/Library/Preferences/com.apple.dock.plistsudo restart","link":"/2021/02/19/macOS-%E8%99%9A%E6%8B%9F%E6%A1%8C%E9%9D%A2%E9%BB%91%E5%B1%8F/"},{"title":"macOS 升级JDK至1.8","text":"Macbook Pro原生自带的Java JDK版本是1.6，而有的时候需要高一点的版本，这时候就需要升级JDK的版本。 通过java -version可以查看当前的版本: 123Java version &quot;1.6.0_65&quot;Java(TM) SE Runtime Environment (build 1.6.0_65-b14-468-11M4833)Java HotSpot(TM) 64-Bit Server VM (build 20.65-b04-468, mixed mode) 首先去下载Java SE Developent Kit，下载完成后安装上，安装好的jdk在这个位置:/Library/Java/JavaVirtualMachines/jdk1.8.0_92.jdk/Contents 然后去苹果的官网下载最新的java版本 Java From Apple,下载完成安装上以后可以在 系统偏好设置–&gt;Java–&gt;Java控制面板 中查看Java相关的信息。 去JavaFramework索引目录下修改当前的jdk引用路径:cd /System/Library/Frameworks/JavaVM.framework/Versions 移除旧的引用:sudo rm CurrentJDK，如果你的系统是新的10.13的话，会有提示：rm: CurrentJDK: Operation not permitted。 这是因为EI Capitan加入了Rootless机制，不再能够随心所欲的读写很多路径下得内容了，即使是设置了root权限也不行。 苹果这样做也是为了用户的安全考虑，避免用户误删文件，当然也能够在一定程度下减小恶意软件对用户造成危害的几率。 但是这是我们自己需要这样的操作怎么办呢 ？苹果也考虑到了大家的需求，可以这么做： 1). 重启电脑，在将要启动的时候按住 Command + R键，进入恢复模式； 2). 选择菜单栏中得使用工具，在其中打开终端； 3). 输入 csrutil disable，暂时关闭Rootless； 4). 重启即可继续操作。 5). 如果想要恢复，可以再次重启并进入终端，输入 csrutil enable 即可。 删除 CurrentJDK 后，不要离开当前目录，添加新的jdk引用路径：sudo ln -s /Library/Java/JavaVirtualMachines/jdk1.8.0_92.jdk/Contents CurrentJDK","link":"/2018/08/02/macOS-%E5%8D%87%E7%BA%A7JDK%E8%87%B31-8/"},{"title":"macOS下预览webp格式的图片","text":"webp格式的图片本来可以使用Chrome 查看，但是macOS自带的无法预览。 可以使用如下方法可以预览webp格式的图片。 下载安装webp-quicklook 下载webp-quicklook 解压得到WebP.qlgenerator 复制到/Library/QuickLook目录 option+右击，点击relaunch，等待Finder线程 可以使用空格点击webp格式的图片预览","link":"/2020/01/24/macOS%E4%B8%8B%E9%A2%84%E8%A7%88webp%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%9B%BE%E7%89%87/"},{"title":"npm升级所有可更新包","text":"使用npm管理node的包，可以使用npm update &lt;name&gt;对单个包升级，对于npm的版本大于 2.6.1,可以使用命令: 1npm install -g 这样升级全部的包 如果上述不太方便, 还可以使用shell脚本和npm-ckeck shell 脚本1234567#!/bin/shset -e#set -xfor package in $(npm -g outdated --parseable --depth=0 | cut -d: -f2)do npm -g install &quot;$package&quot;done npm-checknpm-check是用来检查npm依赖包是否有更新，错误以及不在使用的，我们也可以使用npm-check进行包的更新。 安装npm-check： 1npm install -g npm-check 检查npm包的状态: 1npm-check -u -g 通过上下键可以移动光标，使用空格键可以选择需要处理的包，回车直接进行处理。","link":"/2018/08/07/npm%E5%8D%87%E7%BA%A7%E6%89%80%E6%9C%89%E5%8F%AF%E6%9B%B4%E6%96%B0%E5%8C%85/"},{"title":"pyinstaller教程","text":"简介:PyInstaller可以用来打包python应用程序，打包完的程序就可以在没有安装Python解释器的机器上运行了。PyInstaller支持Python 2.7和Python 3.3+。可以在Windows、Mac OS X和Linux上使用，但是并不是跨平台的，而是说你要是希望打包成.exe文件，需要在Windows系统上运行PyInstaller进行打包工作；打包成mac app，需要在Mac OS上使用。 安装Linux or Mac 可以直接用pip 安装 1pip install pyinstaller 版本更新 1pip install --upgrade pyinstaller Window Windows上运行PyInstaller还需要PyWin32或者pypiwin32，其中pypiwin32在你安装PyInstaller的时候会自动安装。 使用PyInstallerPyInstaller分析你的python程序，找到所有的依赖项。然后将依赖文件和python解释器放到一个文件夹下或者一个可执行文件中。 打包成一个文件夹当使用PyInstaller打包的时候，默认生成一个文件夹，文件夹中包含所有依赖项，以及可执行文件。打包成文件夹的好处就是debug的时候可以清楚的看到依赖项有没有包含。另一个好处是更新的时候，只需要更新可执行文件就可以了。当然缺点也很明显，不方便，不易管理。 1pyinstaller script.py 那么它是如何工作的呢？PyInstaller的引导程序是一个二进制可执行程序。当用户启动你的程序的时候，PyInstaller的引导程序开始运行，首先创建一个临时的Python环境，然后通过Python解释器导入程序的依赖，当然他们都在同一个文件夹下。 打包成一个文件我们可以用onefile参数将所有文件打包到一个可执行文件中。 1pyinstaller --onefile script.py 打包成一个文件相对于文件夹更容易管理。坏处运行相对比较慢。这个文件中包含了压缩的依赖文件拷贝（.so文件）。 当程序运行时，PyInstaller的引导程序会新建一个临时文件夹。然后解压程序的第三方依赖文件到临时文件夹中。这也是为什么一个可执行文件比文件夹中执行的时间要长的原因。剩下的就和上面的一样了。 spec 文件当你执行下面命令 1pyinstaller options..script.py PyInstaller首先建一个sepc(specification)文件：script.spec。这个文件的存放地址可以使用参数–specpath= 来定义，默认放在当前文件夹下。 spec文件的作用是什么呢？它会告诉PyInstaller如何处理你的py文件，它会将你的py文件名字和输入的大部分参数进行编码。PyInstaller通过执行spec文件中的内容来生成app，有点像makefile。正常使用中我们是不需要管spec文件的，但是下面几种情况需要修改spec文件： 需要打包资源文件 需要include一些PyInstaller不知道的run-time库 为可执行文件添加run-time 选项 多程序打包 可以通过下面命令生成spec文件 1pyi-makespec options script.py [other scripts ...] 修改完spec文件，就可以通过下面命令来生成app文件了 1pyinstaller options script.spec 当通过spec文件来生成app文件的时候只有下面几个参数是有用的： –upx-dir= –distpath= –noconfirm= –ascii spec 文件解析下面是一个spec文件的例子。 1234567891011121314block_cipher = Nonea = Analysis(['minimal.py'], pathex=['/Developer/PItests/minimal'], binaries=None, datas=None, hiddenimports=[], hookspath=None, runtime_hooks=None, excludes=None, ciper=block_cipher)pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)exe = EXE(pyz, ...)coll = COLLECT(...) spec文件中主要包含4个class: Analysis, PYZ, EXE和COLLECT. Analysis以py文件为输入，它会分析py文件的依赖模块，并生成相应的信息 PYZ是一个.pyz的压缩包，包含程序运行需要的所有依赖 EXE根据上面两项生成 COLLECT生成其他部分的输出文件夹，COLLECT也可以没有 123456a = Analysis( ... datas = [('you/source/file/path','file_name_in_project'), ('source/file2', 'file_name2')] ... ) 可以认为datas是一个List,每个元素是一个二元组。元组的第一个元素是你本地文件索引，第二个元素是拷贝到项目中之后的文件名字。除了上面那种写法，也可以将其提出来。 123456added_files = [...]a = Analysis( ... datas = added_files, ... ) 其他的二进制文件添加方法类似。 总结最后简单来说，我们要通过PyInstaller生成可执行的文件主要下面两步。 1pyinstaller [option] mypython.py option为空生成文件夹，选择onefile，生成一个文件。如果项目有一些依赖的数据文件，上面生成的二进制文件是无法运行的，这个时候可以通过修改spec文件，让后再用pyinstaller运行spec文件。 1pyinstaller [option] mypython.spec 当然也按上文那样先生成spec文件。 pyinstaller简洁教程","link":"/2018/01/01/pyinstaller%E6%95%99%E7%A8%8B/"},{"title":"Python 利用paramiko模块监控服务器","text":"在需要对远程服务器进行监控或者一些文件操作的时候, 可以使用paramiko 模块来操作. 安装: 1pip install paramiko Linux 下还得安装python-devel, 不然会报错 下面是示例代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#!/usr/bin/python# encoding=utf-8import datetimeimport threadingimport paramikodef sshCmd(ip, username, passwd, cmds): try: client = paramiko.SSHClient() client.load_system_host_keys() client.set_missing_host_key_policy(paramiko.AutoAddPolicy) client.connect(ip, 22, username, passwd, timeout=5) for cmd in cmds: stdin, stdout, stderr = client.exec_command(cmd) lines = stdout.readlines() # print out for line in lines: print line, print '%s\\t 运行完毕\\r\\n' % (ip) except Exception, e: print '%s\\t 运行失败,失败原因\\r\\n%s' % (ip, e) finally: client.close()#上传文件 def uploadFile(ip,username,passwd): try: t=paramiko.Transport((ip,22)) t.connect(username=username,password=passwd) sftp=paramiko.SFTPClient.from_transport(t) remotepath='/root/main.py' localpath='/home/data/javawork/pythontest/src/main.py' sftp.put(localpath,remotepath) print '上传文件成功' except Exception, e: print '%s\\t 运行失败,失败原因\\r\\n%s' % (ip, e) finally: t.close()#下载文件 def downloadFile(ip,username,passwd): try: t=paramiko.Transport((ip,22)) t.connect(username=username,password=passwd) sftp=paramiko.SFTPClient.from_transport(t) remotepath='/root/storm-0.9.0.1.zip' localpath='/home/data/javawork/pythontest/storm.zip' sftp.get(remotepath,localpath) print '下载文件成功' except Exception, e: print '%s\\t 运行失败,失败原因\\r\\n%s' % (ip, e) finally: t.close() if __name__ == '__main__': # 需要执行的命令列表 cmds = ['ls /root', 'ifconfig'] # 需要进行远程监控的服务器列表 servers = ['xxx.xxx.xxx.xxx'] username = &quot;root&quot; passwd = &quot;xxxxxx&quot; threads = [] print &quot;程序开始运行%s&quot; % datetime.datetime.now() # 每一台服务器创建一个线程处理 for server in servers: th = threading.Thread(target=sshCmd, args=(server, username, passwd, cmds)) th.start() threads.append(th) # 等待线程运行完毕 for th in threads: th.join() print &quot;程序结束运行%s&quot; % datetime.datetime.now() #测试文件的上传与下载 uploadFile(servers[0],username,passwd) downloadFile(servers[0],username,passwd)","link":"/2018/08/17/python-%E5%88%A9%E7%94%A8paramiko%E6%A8%A1%E5%9D%97%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"title":"sshpass 的使用","text":"​ ssh远程连接时，每次都提示需要输入密码。需要ssh到多台机器时很不方便。sshpass可以解决这个问题。sshpass可以实现ssh的自动的登录。直接在命令里输入密码，但是安全性的问题需要自己判断。 安装 Installing on Ubuntu apt-get install sshpass Installing on OS X 开始之前需要安装install xcode and command line tools. 之后安装Installing with Homebrew 由于安全问题，brew 官方默认不允许安装，可以尝试如下方法： brew install https://raw.githubusercontent.com/kadwanev/bigboybrew/master/Library/Formula/sshpass.rb 源码安装 Download the Source Code Extract it and cd into the directory ./configure sudo make install 用法介绍1234567891011[root@zhu ~]# sshpass --helpsshpass: invalid option -- '-'Usage: sshpass [-f|-d|-p|-e] [-hV] command parameters -f filename Take password to use from file -d number Use number as file descriptor for getting password -p password Provide password as argument (security unwise) -e Password is passed as env-var &quot;SSHPASS&quot; With no parameters - password will be taken from stdin -h Show help (this screen) -V Print version informationAt most one of -f, -d, -p or -e should be used 123456789101112131415161718192021-p password #后跟密码[root@zhu ~]# sshpass -p 123456 ssh root@192.168.56.102Last login: Wed Apr 16 15:35:22 2014 from 192.168.56.1[root@jiang ~]# exitlogoutConnection to 192.168.56.102 closed.-f filename #后跟保存密码的文件名，密码是文件内容的第一行。[root@zhu ~]# cat 1.txt123456[root@zhu ~]# sshpass -f 1.txt ssh root@192.168.56.102Last login: Fri Apr 18 13:48:20 2014 from 192.168.56.101[root@jiang ~]# exitlogoutConnection to 192.168.56.102 closed.-e #将环境变量SSHPASS作为密码[root@zhu ~]# export SSHPASS=123456[root@zhu ~]# sshpass -e ssh root@192.168.56.102Last login: Fri Apr 18 13:51:45 2014 from 192.168.56.101[root@jiang ~]# exitlogoutConnection to 192.168.56.102 closed. 如果在多台主机执行命令： 1234567[root@zhu ~]# cat a.sh#!/bin/bashfor i in $(cat /root/1.txt)do echo $i sshpass -p123456 ssh root@$i 'ls -l'done","link":"/2017/05/20/sshpass-%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"为Android Studio快速安装Gradle","text":"####如何为Android Studio 快速安装Gradle 1、从Gradle官网下载相应的包。 2、打开C:\\Android Studio\\gradle目录，具体看个人的安装情况 3、把下载下来的Gradle包解压到2所提到的目录下 4、打开Android Studio的File/setting/Gradle按图设置相应的目录","link":"/2015/08/06/%E4%B8%BAAndroid-Studio%E5%BF%AB%E9%80%9F%E5%AE%89%E8%A3%85Gradle/"},{"title":"使用 Runfus 为 Windows10 创建 USB 启动盘","text":"Rufus 是一个可以帮助格式化和创建可引导USB闪存盘的工具，比如 USB 随身碟，记忆棒等等。 在如下场景中会非常有用： 你需要把一些可引导的ISO格式的镜像（Windows，Linux，UEFI等）创建成USB安装盘的时候 你需要使用一个还没有安装操作系统的设备的时候 你需要从DOS系统刷写BIOS或者其他固件的时候 你需要运行一个非常底层的工具的时候 前期准备 Windows ISO镜像（Windows 10） Rufus U盘（最少4GB） 关于 Rufus 支持的语言:Bahasa Indonesia , Bahasa Malaysia , Български , Čeština , Dansk , Deutsch , Ελληνικά , English ,Español , Français , Hrvatski , Italiano , Latviešu , Lietuvių , Magyar , Nederlands , Norsk , Polski ,Português , Português do Brasil , Русский , Română , Slovensky , Slovenščina , Suomi , Svenska ,Tiếng Việt , Türkçe , Українська , العربية , 简体中文 , 正體中文 , 日本語 , 한국어 . 系统需求需要Windows XP以上的操作系统，无所谓32位还是64位，下载后开箱即用。 Rufus 目前已知（但不限于）的支持的ISO镜像如下：Arch Linux ,CentOS , Debian , Fedora , Gentoo, Kubuntu ,Linux Mint , OpenSUSE ,Slackware , Ubuntu ,,Windows XP (SP2+) , Windows Server 2003 R2 , Windows Vista , Windows 7 ,Windows 8 , Windows 8.1 , Windows 10 , …","link":"/2017/06/04/%E4%BD%BF%E7%94%A8-Runfus-%E4%B8%BA-Windows10-%E5%88%9B%E5%BB%BA-USB-%E5%90%AF%E5%8A%A8%E7%9B%98/"},{"title":"使用Python的paramiko模块","text":"介绍使用paramiko模块， 在Python的环境下实现 SSH 下的一些操作. 安装直接使用pip安装即可. 1pip install paramiko 使用123456789import paramikossh = paramiko.SSHClient()#允许连接不在know_hosts文件中的主机。ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())ssh.connect(ip, port, username, password)# 执行shell命令ssh.exec_command('ls') API文档:https://paramiko-docs.readthedocs.io/en/2.4/api/client.html SFTP通过paramiko模块可以实现SCP的功能 123456789101112#在新建好ssh链接对象之后, 新建一个链接对象.sftp = ssh.open_sftp()#上传文件sftp.put(local_file, remote_file)#下载文件sftp.get(remote_file, local_file)#列出目录sftp.listdir()#默认当前目录","link":"/2018/11/26/%E4%BD%BF%E7%94%A8Python%E7%9A%84paramiko%E6%A8%A1%E5%9D%97/"},{"title":"关于Anroid的","text":"浅析 Android 的窗口浅析 Android 的窗口","link":"/2016/02/02/%E5%85%B3%E4%BA%8EAnroid%E7%9A%84/"},{"title":"关于GIT的一些错误","text":"刚创建的github版本库，在push代码时出错： $ git push -u origin master提示如下错误 123456! [rejected] master -&gt; master (non-fast-forward)error: failed to push some refs to 'git@github.com:******/Demo.git'hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Merge the remote changes (e.g. 'git pull')hint: before pushing again.hint: See the 'Note about fast-forwards' in 'git push --help' for details. 因为远程repository和本地的repository冲突导致的，而我在创建版本库后，在github的版本库页面点击了创建README.md文件的按钮创建了说明文档，但是却没有pull到本地。这样就产生了版本冲突的问题。 解决方案：1.使用强制push的方法：$ git push -u origin master -f 这样会使远程修改丢失，一般是不可取的，尤其是多人协作开发的时候。 2.push前先将远程repository修改pull下来 $ git pull origin master再进行push$ git push -u origin master 3.若不想merge远程和本地修改，可以先创建新的分支：$ git branch [name]然后push$ git push -u origin [name]","link":"/2015/05/23/%E5%85%B3%E4%BA%8EGIT%E7%9A%84%E4%B8%80%E4%BA%9B%E9%94%99%E8%AF%AF/"},{"title":"关于VM虚拟机的一些问题","text":"在升级系统之后，VM虚拟机提示是否移动了虚拟机，然后网络不能连接上，应该是网络适配器没有正常工作。可以在移除之后重新添加一个。","link":"/2015/07/30/%E5%85%B3%E4%BA%8EVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"},{"title":"快速升级 Python 的模块","text":"pip 当前内建命令并不支持升级所有已安装的Python模块，所有使用命令行来查询和升级 Python 的模块 列出当前安装的包：1pip list 列出可升级的包：1pip list --outdate 升级一个包：1pip install --upgrade requests // mac,linux,unix 在命令前加 sudo -H 升级所有可升级的包：12345# python3的平台$ pip3 freeze --local | grep -v '^-e' | cut -d = -f 1 | xargs -n1 pip3 install -U# python2的平台$ pip freeze --local | grep -v '^-e' | cut -d = -f 1 | xargs -n1 pip2 install -U$ for i in `pip list -o --format legacy|awk '{print $1}'` ; do pip install --upgrade $i; done 也可以是用requirements来执行更新先导出全局依赖 1pip3 freeze &gt; requirements.txt 然后再倒入回去，但是会进行更新 1pip3 install -r requirements.txt --upgrade","link":"/2017/08/21/%E5%8D%87%E7%BA%A7-Python-%E7%9A%84%E6%A8%A1%E5%9D%97/"},{"title":"南京租房补贴申请流程","text":"南京申请大学生租房补贴的具体流程更新于2020.02.01 个人的办理经历，仅供参考，目前可以领取三年。 以下是旧的流程，可以不看 准备材料。 房屋租赁合同（合同应包括，甲乙方姓名、联系方式、身份证号码，这三个是必须的） 毕业证 学位证 房租租赁发票（如何办理？） 办理地址如下 准备材料 房产证全部复印件（这里的全部指的是，所有产权人，每个人都有房产证，每个人手上的都要全部复印，一般一本是6页） 产权人身份证全部复印件，承租人身份证复印件 租赁合同原件及复印件 如产权人为多人，未到场者需出示委托书及委托人。注意：如果租赁合同只写了一个出租方的名字，那么必须持有其余产权人的「共有权人同意出租房产声明」，如下事例： 缴税的金额是按一年算，租金的3.5%。是租赁合同上的。自己体会。 居住证 凭办理房屋租赁备案的证明、租赁合同、本人身份证复印件以及2寸白底照片，去社区警务室办理。 下载安装「我的南京」这款App，并进行激活，可以支付宝，这个是最简单的。 打开租房申请说明这个链接，拉到最下面，点击继续申请。 用我的南京左上角扫描然后进入这个登录确认的界面 之后见到如下界面，确认你要填写哪些信息和材料 最重要的是如下图 可以看到的是，我是需要提交四份材料，但是有些人的界面会是六个材料，多了居住证。所以可以先进去看看到底要不要。 如实填写，然后提交等待审核。不过看新闻，整个流程差不多要年底才能发放补贴。补贴是发放到市民卡里面，需要去银行激活才能使用。","link":"/2016/08/19/%E5%8D%97%E4%BA%AC%E7%A7%9F%E6%88%BF%E8%A1%A5%E8%B4%B4%E7%94%B3%E8%AF%B7%E6%B5%81%E7%A8%8B/"},{"title":"卸载 JDK for Mac","text":"由于 Unifi 事件，根据官网提供的文档，怀疑是 JDK 版本过高导致。那么就需要卸载新版本 Java。Oracle 官方提供的了解决方案。 本文适用于: **平台: ** macOS **Java 版本: ** 7.0, 8.0 使用终端卸载 Oracle Java注：要卸载 Java，必须具有管理员权限，并且必须以 root 用户身份或者使用 sudo 工具来执行删除命令。按照下面所示，删除一个目录和一个文件（符号链接）：单击位于停靠栏中的 Finder 图标单击实用程序文件夹双击终端图标在“终端”窗口中，复制和粘贴命令： 123sudo rm -fr /Library/Internet\\ Plug-Ins/JavaAppletPlugin.pluginsudo rm -fr /Library/PreferencesPanes/JavaControlPanel.prefPanesudo rm -fr ~/Library/Application\\ Support/Java 请勿尝试通过从 /usr/bin 删除 Java 工具来卸载 Java。此目录是系统软件的一部分，下次对操作系统执行更新时，Apple 会重置所有更改。","link":"/2017/08/18/%E5%8D%B8%E8%BD%BD-JDK-for-Mac/"},{"title":"原生Android 去除叉号","text":"Android 5.0 引入的一种检测网络是否正常连接的机制，通过 HTTP 返回的状态码是否是 204 来判断是否成功，如果访问得到了 200，那你就可能处在一个需要登录验证才能上网的环境里，比如说校园网，再比如说一些酒店提供的客户才能免费使用的 Wi-Fi（其实是通过 DNS 劫持实现的），如果连接超时（根本就连接不上）就在 Wi-Fi 图标和信号图标上加一个标志，Android 5 和 Android 6 是叹号，Android 7 改成一个叉了。只不过默认访问的是谷歌自家的验证服务器，然而 Google 是被墙掉了，导致 Android 没有办法正确评估网络。所以，系统每隔一定时间都会重新尝试连接，就在不知不觉中消耗了数据流量。更恐怖的就是 Android 认为在 Wi-Fi 下无法连接互联网，就让联网的程序通通走流量… 解决办法利用ADB直接修改命令，前提是手机开启开发者选项 Android 5.0 - 6.0123456# 删除地址就可以恢复默认的谷歌服务器adb shell settings delete global captive_portal_server# 设置一个可用地址adb shell settings put global captive_portal_server http://developers.google.cn/generate_204# 查询当前地址adb shell settings get global captive_portal_server Android 7.0 - Android 10.0123456# 删除（删除默认用HTTPS）adb shell settings delete global captive_portal_https_urladb shell settings delete global captive_portal_http_url# 设置一个可用地址adb shell settings put global captive_portal_http_url http://developers.google.cn/generate_204adb shell settings put global captive_portal_https_url https://developers.google.cn/generate_204 以上执行完成之后，都需要开启一下飞机模式","link":"/2020/08/10/%E5%8E%9F%E7%94%9FAndroid-%E5%8E%BB%E9%99%A4%E5%8F%89%E5%8F%B7/"},{"title":"国内外主流android第三方服务","text":"统计分析 国内：Talking Data, 可惜友盟现在启动就带上阿里全家桶。 国外: Flurry, 国外统计分析系统的标杆，免费的。 Crash分析 国内: 腾讯Bugly, 号称全球唯一自带ANR收集，其实原理很简单，不知别家为何不做。 国外: Crashlytics, 已经收归Twitter Fabric开发者工具集，免费好用。 推送 国内: LeanCloud，这个没实际用过，身边朋友反馈很好。 国外: Parse, 正如覃超所说,FB也在用，30qps免费限制，一般中小应用够用。 分享 国内: ShareSDK，专业做社交分享。 国外: 各社交平台自家SDK, 注意不同国家主流社交平台不同。 评论 国内：畅言, 基本抄的Disqus, 免费，算是良心产品了。 国外：Disqus, 基本不用考虑其他家的，虽然确实有竞品。 广告变现 国内：百度 or 广点通，两个效果差不多。 国外：FB or Google，做native广告，效果最佳。 支付 国内: 支付宝, 微信 国外: payssion, 专业做海外跨境收款的，能省很多事。 短信验证 国内：没用过，Google找一家最便宜的就行。 国外：Fabric Digits, twitter出品，居然不要钱。 灰度测试 国内：AppAdhoc，移动AB测试国内最专业的一家。 国外：optimizely, 支持Android, iOS, 直接在线改UI做AB测试, 三观都要颠覆了。 云测 国内：百度云测试。 国外：test in, 其实百度的也跑，国内的Android设备都卖到国外去了。 客服 国内：微客服, 有免费额度，中小应用够用。 国外：helpshift，国外最专业的客服平台。 推广 国内：这个真不了解。 国外：Appsflyer, 海外推广为数不多的选择之一。 可视化分析 国内：growingio, 还在内测中，linkedin数据分析大牛回国创业，据说黑科技，可以直接在app上实时查看各种转化率数据。 国外：appsee, 绝对黑科技，PM最爱。 网络优化 国外：TwinPrime, 颇具特色的网络优化服务。 国内：暂时还没发现同类产品，不过TwinPrime理论上是支持全球的。","link":"/2018/08/01/%E5%9B%BD%E5%86%85%E5%A4%96%E4%B8%BB%E6%B5%81android%E7%AC%AC%E4%B8%89%E6%96%B9%E6%9C%8D%E5%8A%A1/"},{"title":"在Android Pie中安装Xposed","text":"如今重新命名的Android 10都已经发布了，但是针对Android Pie的Xpsoed官方版还是没有发布，据说作者去Apple工作去了？但是开源社区的好处就是有人能够实现同样的效果。 这个是Elder Driver开发的非官方端口，Xposed for Android Pie。它被命名为EDXposed， 还需要额外安装Riru Core，具体步骤如下。 下载 Riru Core压缩包，放入手机 下载 EdXposed压缩包，可以选择YAHFA，放入手机 下载 EdXposedManager的apk，并且安装 打开Magisk manager， 打开多功能菜单，选择模块，然后点击添加按钮，分别刷入上文下载的两个压缩包。 重启手机激活以上两个模块，然后打开EdXposed Manager，看到已经激活了。 如果没有，请卸载，重新尝试以上步骤。","link":"/2019/09/10/%E5%9C%A8Android-Pie%E4%B8%AD%E5%AE%89%E8%A3%85Xposed/"},{"title":"在Debian上使用UFW","text":"UFW全程Uncomplicated Firewall，是Ubuntu系统上默认的防火墙组件。UFW是为轻量化配置iptables而开发的一款工具。UFW 提供一个非常友好的界面用于创建基于IPV4，IPV6的防火墙规则。UFW 在 Ubuntu 8.04 LTS 后的所有发行版中默认可用。无论是桌面版还是服务器版，UFW 的命令行用法是一样的。 在服务器上使用UFW的时候需要具备sudo权限 安装Debian 默认不安装UFW，使用如下命令安装 1sudo apt install -y UFW 将IPv6与UFW一起使用(可选)默认是不启用IPv6，如果需要开启，则需要用vi编辑UFW的配置。 1sudo vi /etc/default/ufw 然后把no改成yes 1IPV6=yes 设置默认策略刚开始使用的时候，需要设置默认策略，这些规则控制如何处理未明确匹配任何其他规则的流量。UFW设置为拒绝所有传入连接并允许所有传出连接。 1sudo ufw allow ssh 这将创建防火墙规则，允许端口22上的所有连接，这是SSH守护程序默认侦听的端口。UFW知道端口allow ssh的含义，因为它在/etc/services文件中被列为服务。 但是，实际上可以通过指定端口而不是服务名来编写等效规则。例如，此命令与上面的命令相同： 1sudo ufw allow 22 如果将SSH守护程序配置为使用其他端口，则必须指定相应的端口。例如，如果SSH服务器正在侦听端口2222，则可以使用此命令允许该端口上的连接： 1sudo ufw allow 2222 现在您的防火墙已配置为允许传入SSH连接，我们可以启用它。 启用UFW要启用UFW，请使用以下命令： 1sudo ufw enable 您将收到一条警告，指出该命令可能会破坏现有的SSH连接。我们已经设置了允许SSH连接的防火墙规则，因此可以继续。用y来响应提示然后点击ENTER。 防火墙现在处于活动状态。运行该sudo ufw status verbose命令以查看已设置的规则。 设置其他规则此时也可以这样做： 端口80上的HTTP，这是未加密的Web服务器使用的，使用sudo ufw allow http或sudo ufw allow 80 端口443上的HTTPS，这是加密的Web服务器使用的，使用sudo ufw allow https或sudo ufw allow 443 除了指定端口或已知服务之外，还有其他几种允许其他连接的方法。 特定端口范围可以使用UFW指定端口范围。某些应用程序使用多个端口，而不是单个端口。 例如，为了允许X11连接，它使用的是端口6000- 6007，使用这些命令： 12sudo ufw allow 6000:6007/tcpsudo ufw allow 6000:6007/udp 使用UFW指定端口范围时，必须指定规则应适用的协议（tcp或udp）。否则就是默认自动启用两种协议。 特定IP地址使用UFW时，还可以指定IP地址。例如，如果要允许来自特定IP地址的连接（例如工作或家庭IP地址为203.0.113.5），则需要指定from，然后才是IP地址： 1sudo ufw allow from 203.0.113.5 同样，也可以指定允许子网203.0.113.0/24连接的目标端口。使用端口22（SSH）作为示例： 1sudo ufw allow from 203.0.113.0/24 to any port 22 与特定网络接口的连接如果要创建仅适用于特定网络接口的防火墙规则，可以通过指定“允许接通”，然后指定网络接口的名称来执行此操作。 在继续之前查找网络接口。为此，请使用以下命令： 12345ip addr2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state. . .3: eth1: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN group default. . . 突出显示的输出表示网络接口名称。它们通常被命名为eth0或者enp3s2。 因此，如果服务器有一个名叫eth0的公共网络接口，则可以使用以下命令允许HTTP流量（端口80）： 1sudo ufw allow in on eth0 to any port 80 这样做将允许服务器从公共互联网接收HTTP请求。 或者，如果希望MySQL数据库服务器（端口3306）侦听专用网络接口eth1上的连接，例如，可以使用此命令： 1sudo ufw allow in on eth1 to any port 3306 这将允许专用网络上的其他服务器连接到MySQL数据库。 拒绝连接如果尚未更改传入连接的默认策略，则UFW配置为拒绝所有传入连接。 但是，有时希望根据源IP地址或子网拒绝特定连接，可能是因为您知道您的服务器正在受到攻击。此外，如果要将默认传入策略更改为允许（不建议这样做），则需要为不希望允许连接的任何服务或IP地址创建拒绝规则。 要编写拒绝规则，可以使用上述命令，将allow替换为deny。 例如，要拒绝HTTP连接，可以使用以下命令： 1sudo ufw deny http 或者，如果要拒绝来自203.0.113.5上的所有连接，可以使用以下命令： 1sudo ufw deny from 203.0.113.5 删除规则了解如何删除防火墙规则与了解如何创建防火墙规则同样重要。有两种不同的方法可以指定要删除的规则：按规则编号或实际规则（类似于创建规则时的规则）。 按规则编号如果使用规则编号删除防火墙规则，那么要做的第一件事就是获取防火墙规则列表。UFW status命令可以选择显示每个规则旁边的数字，如下所示： 1234567sudo ufw status numberedStatus: active To Action From -- ------ ----[ 1] 22 ALLOW IN 15.15.15.0/24[ 2] 80 ALLOW IN Anywhere 如果决定要删除允许端口80（HTTP）连接的规则2，可以在UFW删除命令中指定它，如下所示： 1sudo ufw delete 2 这将显示确认提示，然后删除规则2，允许HTTP连接。请注意，如果启用了IPv6，则还需要删除相应的IPv6规则。 按实际规则规则编号的替代方法是指定要删除的实际规则。例如，如果要删除allow http规则，可以这样写： 1sudo ufw delete allow http 还可以通过allow 80而不是按服务名称来指定规则： 1sudo ufw delete allow 80 此方法将删除IPv4和IPv6规则（如果存在）。 检查UFW状态和规则可以随时使用以下命令检查UFW的状态： 1sudo ufw status verbose 如果UFW被禁用，默认情况下，会看到如下内容： 1Status: inactive 如果UFW处于活动状态，如果您按照步骤进行操作，输出将表明它处于活动状态，并且它将列出所有已设置的规则。例如，如果防火墙设置为允许来自任何位置的SSH（端口22）连接，则输出可能如下所示： 12345678Status: activeLogging: on (low)Default: deny (incoming), allow (outgoing), disabled (routed)New profiles: skipTo Action From-- ------ ----22/tcp ALLOW IN Anywhere 如果要检查UFW如何配置防火墙，请使用此status命令。 禁用或重置UFW如果决定不想使用UFW，可以使用以下命令禁用它： 1sudo ufw disable 使用UFW创建的任何规则将不再处于活动状态。如果以后需要激活，可以随时运行sudo ufw enable。 如果已经配置了UFW规则但是决定要重新开始，则可以使用reset命令： 1sudo ufw reset 这将禁用UFW并删除先前定义的任何规则。请注意，如果在任何时候修改了默认策略，默认策略都不会更改为原始设置。","link":"/2020/12/16/%E5%9C%A8Debian%E4%B8%8A%E4%BD%BF%E7%94%A8UFW/"},{"title":"夜深写算法系列","text":"夜深写算法系列蛮有意思的几个算法 搜索入门 动态规划 树状数组 差分约束 初等数论 最近公共祖先","link":"/2016/01/23/%E5%A4%9C%E6%B7%B1%E5%86%99%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97/"},{"title":"在浏览器中看其他国家&#x2F;地区的Google Play排名","text":"更新：该接口已经被Google封了。 在Google Play的网页版中，我们能看到当前国家或者地区的，不同分类的应用排名，但是想看其他地区的就有问题了。以下是解决办法，直接在URL中使用固定参数 https://play.google.com/store/apps/category/BUSINESS/collection/topselling_free?gl=ru 其中，BUSINESS是分类，gl=ru是国家的代号 只要按照这个规则，直接在浏览器中访问特定的URL就那个看到对应的应用排名 举例国家代码： https://play.google.com/?gl=al Albania https://play.google.com/?gl=dz Algeria https://play.google.com/?gl=ao Angola https://play.google.com/?gl=ag Antigua and Barbuda https://play.google.com/?gl=ar Argentina https://play.google.com/?gl=am Armenia https://play.google.com/?gl=aw Aruba https://play.google.com/?gl=au Australia https://play.google.com/?gl=at Austria https://play.google.com/?gl=az Azerbaijan https://play.google.com/?gl=bs Bahamas https://play.google.com/?gl=bh Bahrain https://play.google.com/?gl=bd Bangladesh https://play.google.com/?gl=by Belarus https://play.google.com/?gl=be Belgium https://play.google.com/?gl=bz Belize https://play.google.com/?gl=bj Benin https://play.google.com/?gl=bo Bolivia https://play.google.com/?gl=ba Bosnia and Herzegovina https://play.google.com/?gl=bw Botswana https://play.google.com/?gl=br Brazil https://play.google.com/?gl=bg Bulgaria https://play.google.com/?gl=bf Burkina https://play.google.com/?gl=kh Cambodia https://play.google.com/?gl=cm Cameroon https://play.google.com/?gl=ca Canada https://play.google.com/?gl=cv Cape Verde https://play.google.com/?gl=cl Chile https://play.google.com/?gl=co Colombia https://play.google.com/?gl=cr Costa Rica https://play.google.com/?gl=ci Cote d’ Ivore https://play.google.com/?gl=hr Croatia https://play.google.com/?gl=cy Cyprus https://play.google.com/?gl=cz Czech Republic https://play.google.com/?gl=dk Denmark https://play.google.com/?gl=do Dominican Republic https://play.google.com/?gl=ec Ecuador https://play.google.com/?gl=eg Egypt https://play.google.com/?gl=sv El Salvador https://play.google.com/?gl=ee Estonia https://play.google.com/?gl=fj Fiji https://play.google.com/?gl=fi Finland https://play.google.com/?gl=fr France https://play.google.com/?gl=ga Gabon https://play.google.com/?gl=de Germany https://play.google.com/?gl=gh Ghana https://play.google.com/?gl=gr Greece https://play.google.com/?gl=gt Guatemala https://play.google.com/?gl=gw Guinea-Bissau https://play.google.com/?gl=ht Haiti https://play.google.com/?gl=hn Honduras https://play.google.com/?gl=hk Hong Kong https://play.google.com/?gl=hu Hungary https://play.google.com/?gl=is Iceland https://play.google.com/?gl=in India https://play.google.com/?gl=id Indonesia https://play.google.com/?gl=ie Ireland https://play.google.com/?gl=il Israel https://play.google.com/?gl=it Italy https://play.google.com/?gl=jm Jamaica https://play.google.com/?gl=jp Japan https://play.google.com/?gl=jo Jordan https://play.google.com/?gl=kz Kazakhstan https://play.google.com/?gl=ke Kenya https://play.google.com/?gl=kw Kuwait https://play.google.com/?gl=kg Kyrgyzstan https://play.google.com/?gl=la Laos https://play.google.com/?gl=lv Latvia https://play.google.com/?gl=lb Lebanon https://play.google.com/?gl=li Liechtenstein https://play.google.com/?gl=lt Lithuania https://play.google.com/?gl=lu Luxembourg https://play.google.com/?gl=mk Macedonia https://play.google.com/?gl=my Malaysia https://play.google.com/?gl=ml Mali https://play.google.com/?gl=mt Malta https://play.google.com/?gl=mu Mauritius https://play.google.com/?gl=mx Mexico https://play.google.com/?gl=md Moldova https://play.google.com/?gl=ma Morocco https://play.google.com/?gl=mz Mozambique https://play.google.com/?gl=na Namibia https://play.google.com/?gl=np Nepal https://play.google.com/?gl=nl Netherlands https://play.google.com/?gl=an Netherlands Antilles https://play.google.com/?gl=nz New Zealand https://play.google.com/?gl=ni Nicaragua https://play.google.com/?gl=ne Niger https://play.google.com/?gl=ng Nigeria https://play.google.com/?gl=no Norway https://play.google.com/?gl=om Oman https://play.google.com/?gl=pk Pakistan https://play.google.com/?gl=pa Panama https://play.google.com/?gl=pg Papua New Guinea https://play.google.com/?gl=py Paraguay https://play.google.com/?gl=pe Peru https://play.google.com/?gl=ph Philippines https://play.google.com/?gl=pl Poland https://play.google.com/?gl=pt Portugal https://play.google.com/?gl=qa Qatar https://play.google.com/?gl=ro Romania https://play.google.com/?gl=ru Russia https://play.google.com/?gl=rw Rwanda https://play.google.com/?gl=sa Saudi Arabia https://play.google.com/?gl=sn Senegal https://play.google.com/?gl=rs Serbia https://play.google.com/?gl=sg Singapore https://play.google.com/?gl=sk Slovakia https://play.google.com/?gl=si Slovenia https://play.google.com/?gl=za South Africa https://play.google.com/?gl=kr South Korea https://play.google.com/?gl=es Spain https://play.google.com/?gl=lk Sri Lanka https://play.google.com/?gl=se Sweden https://play.google.com/?gl=ch Switzerland https://play.google.com/?gl=tw Taiwan https://play.google.com/?gl=tj Tajikistan https://play.google.com/?gl=tz Tanzania https://play.google.com/?gl=th Thailand https://play.google.com/?gl=tg Togo https://play.google.com/?gl=tt Trinidad and Tobago https://play.google.com/?gl=tn Tunisia https://play.google.com/?gl=tr Turkey https://play.google.com/?gl=tm Turkmenistan https://play.google.com/?gl=ug Uganda https://play.google.com/?gl=ua Ukraine https://play.google.com/?gl=ae United Arab Emirates https://play.google.com/?gl=gb United Kingdom https://play.google.com/?gl=us United States (including Puerto Rico, American Samoa, Guam, Marshall Islands, Northern Mariana Islands, Palau and US Virgin Islands) https://play.google.com/?gl=uy Uruguay https://play.google.com/?gl=uz Uzbekistan https://play.google.com/?gl=ve Venezuela https://play.google.com/?gl=vn Vietnam https://play.google.com/?gl=ye Yemen https://play.google.com/?gl=zm Zambia https://play.google.com/?gl=zw Zimbabwe","link":"/2019/08/22/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9C%8B%E5%85%B6%E4%BB%96%E5%9B%BD%E5%AE%B6-%E5%9C%B0%E5%8C%BA%E7%9A%84Google-Play%E6%8E%92%E5%90%8D/"},{"title":"如何在Linux 中优先使用IPV 4","text":"使用VPS 的时候，很多厂商默认网络链接使用IPV 6，而不是IPV 4。在实际使用中会出现下载数据问错的情况，所以可以更改设置，让它优先使用IPV 4，而不是禁用IPV 6。 两种情况 Debian系：123vi /etc/gai.conf#把precedence ::ffff:0:0/96 100 取消注释 Red系：12345678910111213vi /etc/gai.conf# 添加如下内容label ::1/128 0label ::/0 1label 2002::/16 2label ::/96 3label ::ffff:0:0/96 4precedence ::1/128 50precedence ::/0 40precedence 2002::/16 30precedence ::/96 20precedence ::ffff:0:0/96 100","link":"/2020/03/05/%E5%A6%82%E4%BD%95%E5%9C%A8Linux-%E4%B8%AD%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8IPV-4/"},{"title":"如何自学Android","text":"如何自学Android如何自学Android编程？","link":"/2016/01/23/%E5%A6%82%E4%BD%95%E8%87%AA%E5%AD%A6Android/"},{"title":"macOS 设置单个应用语言方法","text":"​ 最近使用 Office 时候发现了一个问题，由于电脑设置默认语言为英文。Office也会自动切换为英文语言。想单独改Office为中文版。找了一圈没找到方法，搜索了半天，发现很多人无法解决，要么就是修改电脑默认语言，还好最后在Office官网找到了一个答案。 关于office 语言修改 更新可以使用macOS自带的方式 打开系统设置，选择语言和地区—&gt;App 点击左下角的添加，选择应用和语言 等待应用重启即可 可以使用以下命令修改: 123defaults write com.microsoft.Word AppleLanguages '(&quot;zh-cn&quot;)'defaults write com.microsoft.Excel AppleLanguages '(&quot;zh-cn&quot;)'defaults write com.microsoft.Powerpoint AppleLanguages '(&quot;zh-cn&quot;)' 如上, 其余的应用, 也可以如此设置. 如果不想要这个语言设置了, 可以使用如下设置: 1defaults delete com.apple.AddressBook AppleLanguages 其实查询语言的ID 的为 1mdls -name kMDItemCFBundleIdentifier /Applications/Microsoft\\ Word.app 结果为 1kMDItemCFBundleIdentifier = &quot;com.microsoft.Word&quot; 简单的方法， 用App Language Chooser ， 把Application目录下的应用拖到这个软件里面， 然后选择中文即刻。记得勾选最下面的默认。","link":"/2018/05/04/mac-OS-%E8%AE%BE%E7%BD%AE%E5%8D%95%E4%B8%AA%E5%BA%94%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/"},{"title":"如何阅读Android源码","text":"阅读Android源码的一些姿势阅读Android源码的一些姿势","link":"/2016/02/19/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BBAndroid%E6%BA%90%E7%A0%81/"},{"title":"安装 oh-my-zsh 插件","text":"macOS的用户安装zsh-autosuggestions等没有自带的插件，基本如下操作： 12git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestionsvi ~/.zshrc 编辑该文件 1234plugins=( git zsh-autosuggestions) 最后更新配置文件 1source ~/.zshrc","link":"/2021/11/16/%E5%AE%89%E8%A3%85-oh-my-zsh-%E6%8F%92%E4%BB%B6/"},{"title":"macOS的brew无法使用tab补全","text":"在M1版本的电脑上安装了brew，但是发现无法使用自动补全的功能，经查得知需要在.zshrc添加如下命令 123456if type brew &amp;&gt;/dev/null; then FPATH=$(brew --prefix)/share/zsh/site-functions:$FPATH autoload -Uz compinit compinitfi 编辑.zshrc，在里面添加上面的命令 source ～/.zshrc","link":"/2021/12/16/macOS%E7%9A%84brew%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8tab%E8%A1%A5%E5%85%A8/"},{"title":"小米6 刷机记录","text":"小米6刷机记录 adb/fastboot工具：Minimal ADB and Fastboot 刷之前的MIUI为：MIUI的稳定版 TWRP：官网上小米6的3.2.1 安装完成后刷入了基于原生Android开源项目的ROM包（基于android 8.1.0） 准备好adb/fastboot工具Google官网地址ADB和fastboot for WindowsADB和fastboot for macOS 下载TWRP在TWRP设备列表找到对应的设备，然后选择一个区域下载img文件到本地 刷机步骤 保证手机已经打开USB调试模式 用adb devices能在输出中看到设备记录就算成功 用数据线连接手机和电脑，打开终端或者进入ADB目录文件下 1234adb devicesadb reboot bootloaderfastboot flash recovery twrp.imgfastboot boot twrp.img # 此行命令可以进TWRP的recovery，但是如果没有刷ROM就重启，那么recovery就会被覆盖 把ROM推送到手机中，刷ROM adb push *.zip /sdcard 然后在手机中操作，先三清，然后选择该ROM刷入","link":"/2019/10/23/%E5%B0%8F%E7%B1%B36-%E5%88%B7%E6%9C%BA%E8%AE%B0%E5%BD%95/"},{"title":"恢复Chrome的地址栏www","text":"打开chrome 地址栏输入 chrome://flags/#omnibox-ui-hide-steady-state-url-scheme-and-subdomains 将选项改为disabled 重启浏览器 恢复HTTPS 安全图标 chrome://flags/#simplify-https-indicator 将选项改为 enabled（show secure chip for non-ev https pages） 重启浏览器","link":"/2018/09/10/%E6%81%A2%E5%A4%8DChrome%E7%9A%84%E5%9C%B0%E5%9D%80%E6%A0%8Fwww/"},{"title":"小工具","text":"好用的小工具 ####Goreplacer gooreplacer 是一款能够自动替换掉网页中的 Google fonts、apis、themes 为中国科学技术大学镜像资源的 Chrome、Firefox 扩展，瞬间提高网页加载速度。 这是一个很奇葩的应用，因为正常情况下这些资源本身就是用来减少网络带宽提高网页浏览速度的，但由于封锁，便利变成了麻烦。绝大多数国内网站已经被训练的不使用国际服务了，但很多主流网站都使用这些服务，gooreplacer 主要替换以下内容： 1234fonts.googleapis.com ————–&gt; fonts.lug.ustc.edu.cnajax.googleapis.com —————&gt; ajax.lug.ustc.edu.cnthemes.googleusercontent.com –&gt; google-themes.lug.ustc.edu.cnfonts.gstatic.com —————–&gt; fonts-gstatic.lug.ustc.edu.cn用了这个，chrome打开本地的doc文件也流畅了很多。 ####Clover Clover 是 Windows Explorer 资源管理器的一个扩展，为其增加类似谷歌 Chrome 浏览器的多标签页功能。 1234567891011方便的 Tab 页功能要掌握功能强大，操作简单的标签页，只需记住Ctrl+T新开页面，Ctrl+W关闭页面，Ctrl+Tab切换页面，工作效率提高何止一倍！操作系统无缝集成Clover 通过插件的形式集成到 Windows Explorer，保留您通常的使用习惯，无需学习新的文件管理操作，马上就可以使用啦。快如闪电的书签栏按Ctrl+D添加当前路径，或者直接将文件夹拖入书签栏。再也不用到处寻找要访问的文件夹了，瞬间到达，何等痛快！ ####XMind7 Mind采用Java语言开发，具备跨平台运行的性质，且基于EclipseRCP体系结构，可支持插件，插件通过编写XML清单文件可以扩展系统定义好的扩展点。XMind的程序主体由一组插件构成，包括一个核心主程序插件、一组Eclipse运行时插件、一个帮助文档插件和一组多语种资源文件插件。Eclipse用户会对它的界面非常亲切。最新的是XMind7，该软件有免费的版本，功能对比如下","link":"/2015/09/25/%E5%B0%8F%E5%B7%A5%E5%85%B7/"},{"title":"开启snippet的本地搜索功能","text":"由于使用的是snippet的主题，使用文档已经说出了如何开启本地的搜索功能。 如果要使用本地站点搜索，必须安装插件hexo-generator-json-content来创建本地搜索json文件 1npm i hexo-generator-json-content@2.2.0 -S 然后修改主题配置_config.yml文件下jsonContent相关参数。 12345678910## 搜索jsonContent: searchLocal: true // 是否启用本地搜索 searchGoogle: true //是否启用谷歌搜索 posts: title: true text: true content: true categories: true tags: true","link":"/2018/08/10/%E5%BC%80%E5%90%AFsnippet%E7%9A%84%E6%9C%AC%E5%9C%B0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/"},{"title":"把SQL的显示结果输出到文本中","text":"MySQL查询结果有三种方法输出到文本中 直接执行命令 1&gt; select name from table into outfile '/tmp/test.txt'; 在目录/tmp/下会产生文件test.txt 报错：ERROR 1 (HY000): Can't create/write to file '/data/test.xls' (Errcode: 13) mysql没有写权限 查询时自动写入文件 12&gt; pager cat &gt; /tmp/test.txt ;PAGER set to 'cat &gt; /tmp/test.txt' 之后的所有查询结果都自动写入/tmp/test.txt'，并前后覆盖 直接在bash下执行 1# mysql -h 127.0.0.1 -u root -p dabase_name -P 3306 -e &quot;select * from table&quot; &gt; /tmp/test.txt ​","link":"/2016/11/30/%E6%8A%8ASQL%E7%9A%84%E6%98%BE%E7%A4%BA%E7%BB%93%E6%9E%9C%E8%BE%93%E5%87%BA%E5%88%B0%E6%96%87%E6%9C%AC%E4%B8%AD/"},{"title":"搞了台台式机","text":"CPU：https://item.taobao.com/item.htm?spm=a230r.1.14.22.r8EkjI&amp;id=521139022497&amp;ns=1&amp;abbucket=10#detail 1185 主板：http://item.jd.com/1853383.html 599 内存：http://item.jd.com/10512793114.html 299 显卡：RX470 肥猫家的玩家版1389 硬盘：http://item.jd.com/1154863.html?jd_pop=1ffd9d60-338f-4cd6-a9c7-b2ef0beddf1a&amp;abt=0 299 https://item.jd.com/2073071.html 310 电源：https://item.jd.com/491717.html 339 主机箱：http://item.jd.com/1842778.html?jd_pop=8f9c3391-3049-4802-8f10-c2c52b62cc79&amp;abt=3 199","link":"/2016/09/04/%E6%90%9E%E4%BA%86%E5%8F%B0%E5%8F%B0%E5%BC%8F%E6%9C%BA/"},{"title":"把自己的lib上传到中央库","text":"如何使用Android Studio把自己的Android library分发到jCenter和Maven Central把自己的lib上传到中央库","link":"/2016/02/25/%E6%8A%8A%E8%87%AA%E5%B7%B1%E7%9A%84lib%E4%B8%8A%E4%BC%A0%E5%88%B0%E4%B8%AD%E5%A4%AE%E5%BA%93/"},{"title":"最新手机号码正则表达式","text":"最新手机号码正则表达式 众所周知，三大运营商已经增加了不少手机号码字段，还用之前的代码就会流失部分用户了。（只讨论国内坏境）于是我在网上查了些数据，在之前的代码基础上改了下，方便适用于现在的环境。所用方法依然还是正则表达式，正则表达式主要就是用一个公式来匹配字符串是否具备某类规则。我们这里的思路和之前也是一样，只是对之前方法的一个补充与解析。新的方法只匹配了手机号码字段前三位，有些朋友可能还不太懂这个方法，为了方便大家使用，在最后会为大家简单拆分该方法，相信大家很快就会灵活应用了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748+ (BOOL)isMobileNumber:(NSString *)mobileNum{ if (mobileNum.length != 11) { return NO; } /** * 手机号码: * 13[0-9], 14[5,7], 15[0, 1, 2, 3, 5, 6, 7, 8, 9], 17[0, 1, 6, 7, 8], 18[0-9] * 移动号段: 134,135,136,137,138,139,147,150,151,152,157,158,159,170,178,182,183,184,187,188 * 联通号段: 130,131,132,145,155,156,170,171,175,176,185,186 * 电信号段: 133,149,153,170,173,177,180,181,189 */ NSString *MOBILE = @&quot;^1(3[0-9]|4[57]|5[0-35-9]|7[0135678]|8[0-9])\\\\d{8}$&quot;; /** * 中国移动：China Mobile * 134,135,136,137,138,139,147,150,151,152,157,158,159,170,178,182,183,184,187,188 */ NSString *CM = @&quot;^1(3[4-9]|4[7]|5[0-27-9]|7[08]|8[2-478])\\\\d{8}$&quot;; /** * 中国联通：China Unicom * 130,131,132,145,155,156,170,171,175,176,185,186 */ NSString *CU = @&quot;^1(3[0-2]|4[5]|5[56]|7[0156]|8[56])\\\\d{8}$&quot;; /** * 中国电信：China Telecom * 133,149,153,170,173,177,180,181,189 */ NSString *CT = @&quot;^1(3[3]|4[9]|53|7[037]|8[019])\\\\d{8}$&quot;; NSPredicate *regextestmobile = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, MOBILE]; NSPredicate *regextestcm = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, CM]; NSPredicate *regextestcu = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, CU]; NSPredicate *regextestct = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, CT]; if (([regextestmobile evaluateWithObject:mobileNum] == YES) || ([regextestcm evaluateWithObject:mobileNum] == YES) || ([regextestct evaluateWithObject:mobileNum] == YES) || ([regextestcu evaluateWithObject:mobileNum] == YES)) { return YES; } else { return NO; }}","link":"/2017/10/18/%E6%9C%80%E6%96%B0%E6%89%8B%E6%9C%BA%E5%8F%B7%E7%A0%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"title":"终端命令行计算文件的散列值","text":"计算 MD5 校验和 1md5 filename 计算 SHA-1 校验和1shasum -a 1 filename 计算 SHA-256 校验和1shasum -a 256 filename","link":"/2018/11/04/%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%A1%E7%AE%97%E6%96%87%E4%BB%B6%E7%9A%84%E6%95%A3%E5%88%97%E5%80%BC/"},{"title":"模块zlib 压缩与解压","text":"模块zlib用来解压和压缩字符串或者文件，能够自动识别压缩格式来自动解压。 字符串的解压与字符串： 12345678import zlibmessage = 'abcd1234'compressed = zlib.compress(message)decompressed = zlib.decompress(compressed)print 'original:', repr(message)print 'compressed:', repr(compressed)print 'decompressed:', repr(decompressed) 结果是： 123original: 'abcd1234'compressed: 'x\\x9cKLJN1426\\x01\\x00\\x0b\\xf8\\x02U'decompressed: 'abcd1234' 文件的压缩和解压文件： 123456789101112131415161718192021222324import zlibdef compress(infile, dst, level=9): infile = open(infile, 'rb') dst = open(dst, 'wb') compress = zlib.compressobj(level) data = infile.read(1024) while data: dst.write(compress.compress(data)) data = infile.read(1024) dst.write(compress.flush())def decompress(infile, dst): infile = open(infile, 'rb') dst = open(dst, 'wb') decompress = zlib.decompressobj() data = infile.read(1024) while data: dst.write(decompress.decompress(data)) data = infile.read(1024) dst.write(decompress.flush())if __name__ == &quot;__main__&quot;: compress('in.txt', 'out.txt') decompress('out.txt', 'out_decompress.txt') 生成的文件： 1out_decompress.txt out.txt PS：zlib.compress用于压缩流数据。参数string指定了要压缩的数据流，参数level指定压缩的级别，它的取值范围是1到9。压缩速度与压缩率成反比，1表示压缩速度最快，而压缩率最低，而9则表示压缩速度最慢但压缩率最高","link":"/2017/07/23/%E6%A8%A1%E5%9D%97zlib-%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B/"},{"title":"相似图片检测：感知哈希算法之dHash的Python实现","text":"根据这篇文章相似图片检测：感知哈希算法之dHash的Python实现 实现步骤如下： 1、将图片缩放至9*8像素，即一共有8行，每行有9个像素 2、将缩放的图转为灰度图，每个像素由一个0到255的整数表示灰度 3、将每一行灰度值与第二个灰度值进行比较，如果大于则用1表示，否则用0表示，不同行间的灰度值不进行比较，比较后的结果可以得到由1、0组成的64个数值，该64个数值可以看作是该图片的指纹 4、将两张图的指纹进行比较，即将两个指纹相同位置的数值进行对比，如果相同则不计数，如不同则计数1，最终比较结果，如果计数小于5，即视为相同或相似的图片，如果大于10则视为两张不同的照片 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485# /user/bin/python# coding:utf-8import osimport shutilfrom PIL import Image # 导入pillow库下的image模块，主要用于图片缩放、图片灰度化、获取像素灰度值path = '/Users/test/Downloads/photo'error_path = '/Users/test/Downloads/HEIC/error'res_path = '/Users/test/Downloads/HEIC/result.txt'# image为图片的路径，resize_width为缩放图片的宽度，resize_heith为缩放图片的高度def grayscale_Image(image, resize_width=9, resize_heith=8): try: im = Image.open(image) # 使用Image的open方法打开图片 smaller_image = im.resize((resize_width, resize_heith)) # 将图片进行缩放 grayscale_image = smaller_image.convert('L') # 将图片灰度化 return grayscale_image except Exception as e: print(image) shutil.move(image, error_path)def hash_String(image, resize_width=9, resize_heith=8): hash_string = &quot;&quot; # 定义空字符串的变量，用于后续构造比较后的字符串 pixels = list(grayscale_Image(image, resize_width, resize_heith).getdata()) # 上一个函数grayscale_Image()缩放图片并返回灰度化图片，.getdata()方法可以获得每个像素的灰度值，使用内置函数list()将获得的灰度值序列化 for row in range(1, len(pixels) + 1): # 获取pixels元素个数，从1开始遍历 if row % resize_width: # 因不同行之间的灰度值不进行比较，当与宽度的余数为0时，即表示当前位置为行首位，我们不进行比较 if pixels[row - 1] &gt; pixels[row]: # 当前位置非行首位时，我们拿前一位数值与当前位进行比较 hash_string += '1' # 当为真时，构造字符串为1 else: hash_string += '0' # 否则，构造字符串为0 # 最后可得出由0、1组64位数字字符串，可视为图像的指纹 return int(hash_string, 2) # 把64位数当作2进制的数值并转换成十进制数值def Difference(dhash1, dhash2): difference = dhash1 ^ dhash2 # 将两个数值进行异或运算 return bin(difference).count('1') # 异或运算后计算两数不同的个数，即个数&lt;5，可视为同一或相似图片if __name__ == '__main__': path_list = [] path_dic = {} pic_list = [] for file in os.listdir(path): if file.endswith('.jpg') or file.endswith('.JPG') or file.endswith('.PNG') or file.endswith('.png'): pic_list.append(file) for file in pic_list: file_path = os.path.join(path, file) try: Image.open(file_path) path_list.append(file_path) tmp_hash = hash_String(file_path) path_dic[file_path] = tmp_hash except Exception as e: print(e) shutil.move(file_path, error_path) continue # for key, value in path_dic.items(): # print(key, value) count = 0 for i in path_dic.values(): for j in path_dic.values(): tmp = Difference(i, j) if tmp &lt;= 5: # print(i, j) # list(dicxx.keys())[list(dicxx.values()).index(&quot;001&quot;)] var_i = list(path_dic.keys())[list(path_dic.values()).index(i)] var_j = list(path_dic.keys())[list(path_dic.values()).index(j)] if var_i != var_j: print(var_i, var_j) with open(res_path, 'a') as f: f.write(var_i) f.write(var_j) f.write('\\n') ​ ​ ​ ​","link":"/2018/07/20/%E7%9B%B8%E4%BC%BC%E5%9B%BE%E7%89%87%E6%A3%80%E6%B5%8B%EF%BC%9A%E6%84%9F%E7%9F%A5%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E4%B9%8BdHash%E7%9A%84Python%E5%AE%9E%E7%8E%B0/"},{"title":"算法和数据结构","text":"算法与数据结构算法与数据结构 《Data structures》 介绍：高级数据结构大全,基本算法：二叉树等 《基于用户投票的排名算法（一）：Delicious和Hacker News》 介绍：此外还有《基于用户投票的排名算法（二）：Reddit》、《基于用户投票的排名算法（三）：Stack Overflow》、《基于用户投票的排名算法（四）：牛顿冷却定律》、《基于用户投票的排名算法（五）：威尔逊区间》 《Paxos算法》 介绍：这是目前的一种基于消息传递且具有高度容错特性的一致性算法，google在分布式文件系统中与分布式锁中就应用到了这个算法，MapReduce，bigTable等等，中国的alibaba集团的中间件也使用此算法．他们把这个算法的英文版翻译成了中文版．有关它的更多描叙可以参考耶鲁大学的专题页面 《How to: What are the lesser known but useful data structures?》 介绍：很少人知道但很有用的数据结构 《Open Data Structures》 介绍：《开放数据结构》，里面有C++.java相关实现的书籍 《Data Structure and Algorithms for Information Processing》 介绍：卡内基梅隆大学的信息处理的数据结构与算法课程课件 《CVonline: Applications》 介绍：图像和视觉算法的应用领域概括，共包含了29个大类，从中可以看到图像视觉算法应用之广泛。例如人就分生物认证、身体、头、脸、脚、手等不同的领域。 《Sampling, or a faster LZ4》 介绍：高速数据压缩算法LZ4. 《Fundraising Roadmap Algorithm》 介绍：融资路线图算法. 《Weak Learning, Boosting, and the AdaBoost algorithm》 介绍：弱学习/Boosting/AdaBoost算法. 《The easy way to implement a Red-Black tree》 介绍：红黑树最容易的实现方式. 《Algorithmic Game Theory》 介绍:这是一本关于博弈论算法的电子书,博弈论介绍 《Algorithms for Hyper-Parameter Optimization》 介绍：参数优化算法. 《A guide to Algorithmic Complexity》 介绍:Introduce Algorithmic Complexity with images. 《The real 10 algorithms that dominate our world》 介绍:真正统治世界的十大算法,译版. 《What is the importance of this algorithm?》 介绍:Quora上的一篇关于有哪些重要的算法提问. 《Clever Algorithms: Nature-Inspired Programming Recipes》 介绍:智能算法手册(7类/45个之智能相关算法及示例). 《Data Structure Visualizations》 介绍:数据结构可视化图形. 《Paxos algorithm》 介绍:如果简单的解释Paxos算法,此外推荐论文Paxos Made Simple,Consensus Protocols: Paxos,Consensus Protocols: Two-Phase Commit,Consensus Protocols: Three-phase Commit 《Introduction to Algorithms》 介绍:Introduction to Algorithms. 《An Open Source Reference Architecture For Real-Time Stock Prediction》 介绍:实时股票分析系统的架构与算法译文. 《Overview of Recommender Algorithms part1》 介绍：推荐算法概览part2,part3,part4,part5,部分译文part1,part2,同时推荐Recommender Systems in Netflix 《The Use of Machine Learning Algorithms in Recommender Systems: A Systematic Review》 介绍:推荐系统机器学习算法系统综述. 《Top 10 data mining algorithms in plain English》 介绍:白话数据挖掘十大算法 《Designing and Implementing a Ranking Algorithm》 介绍:排名算法的设计与实现 《Quantum algorithms: an overview》 介绍:量子算法概述 《Robert Sedgewick HomePage》 介绍:罗伯特·塞奇威克的主页，是算法一书的作者，目前这本书已经到了第四版 Algorithms, 4th Edition,电子版是免费的，而且还有相对于的源码和课程资料,他的Analytic Combinatorics解析组合数学也很有名 《Communicating sequential processes》 介绍:通信顺序进程是并发编程的经典论文,Go的模型（还有Erlang等）都是基于CPS.此外推荐Communicating Parallel Processes 《Niklaus Wirth Homepage》 介绍:尼克劳斯·维尔特主页，图灵奖获得者。Algol W， Modula， Pascal ，Modula-2， Oberon之父。他的论文Programming in Oberon: Steps beyond Pascal and Modula.被视为软件工程的经典之作 《Donald E. Knuth HomePage》 介绍:唐纳德·尔文·克努斯是图灵奖获得者.其经典著作《计算机程序设计艺术》更是被誉为算法中“真正”的圣经，像KMP和LR(K)这样令人不可思议的算法，在此书比比皆是。难怪连Bill Gates都说：“如果能做对书里所有的习题，就直接来微软上班吧！” 《Jon Bentley HomePage》 介绍:著有编程珠玑Programming Pearls, Second Edition 《Edsger Wybe Dijkstra HomePage》 介绍:艾兹赫尔·韦伯·戴克斯特拉是荷兰第一位以程式为专业的科学家,以发现了图论中的最短路径算法（Dijkstra算法）而闻名于世，1972年因为ALGOL第二代编程语言而获得图灵奖。GOTO有害论“Go To StatementConsidered Harmful”(EWD215)也是被广为传颂的经典之作. 《John Backus HomePage》 介绍:FORTRAN之父,提出了规范描述编程语言语法的BNF。这位当年的“差生”终于被整个计算机世界肯定——美国计算机协会于1977年授予John Backus图灵奖 《James Cooley HomePage》 介绍:美国数学家，哥伦比亚大学的数学博士，以他所创造的快速傅立叶变换(FFT)而著名","link":"/2016/04/04/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"title":"统计一个文件中某个单词的出现次数","text":"首先有一个最简单的方法，就是用正则匹配 123import retmp = open(&quot;123.txt&quot;, &quot;r&quot;).read()print len(re.findall(&quot;hello&quot;, tmp)) 还可以利用Counter来实现更多的功能 1234567891011121314import collectionsimport re pa = re.compile(&quot;\\w+&quot;)counter = collections.Counter(patt.findall(open('reparser.py','rt').read())) # top 100for word, times in counter.most_common(100): print word, times # find wordcounter_dict = dict(counter.most_common(0))tobefind = 'hello'print tobefind, counter_dict.get(tobefind, 0)","link":"/2016/11/30/%E7%BB%9F%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E4%B8%AD%E6%9F%90%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0/"},{"title":"解决1080 端口被占用","text":"在用Windows的时候，或者一些特殊软件的时候，会提示端口被占用了，例如1080端口。 有以下几个解决办法： 用cmd命令查看是哪个应用占用了 打开cmd，然后netstat -aon|findstr &quot;1080&quot;，通过最后一列得到该应用的PID， 然后根据PID找出是哪个应用，tasklist|findstr PID ， 最后用任务管理器kill该应用即可。 使用CurrPorts软件来查看 下载地址 下载后直接解压运行 找到被占用的端口 右键，选择 “Close Selected TCP Connections” 修改要用的端口 例如在目录下找到gui-config.json文件，把其中的&quot;localPort&quot; : 1080,换成&quot;localPort&quot; : 1090,或者其余的端口，然后保存文件，重启应用。","link":"/2019/12/24/%E8%A7%A3%E5%86%B31080-%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8/"},{"title":"获取小程序的openid与unionid","text":"需要发布的小程序基本都要用到openid，这里保存一下自己的代码。一种是不需要服务器的，通过微信提供的接口简单获取openid；一种是有服务器的情况下，获取openid和一些加密的信息，如unionid。 简单获取openid这里的简单获取，是指调试的时候可以使用，正常的情况应该是通过服务器来获取 123456789101112131415161718192021222324252627282930313233343536wx.login({ success: function (res) { var code = res.code; // 复制给变量就可以打印了，醉了 if (res.code) { wx.getUserInfo({ success: function (res) { // userInfo 只存储个人的基础数据 wx.setStorageSync('userInfo', res.userInfo); // 只获取openid的话，自己就可以 that.getOpenid(code); } }) } else { console.log('获取用户登录态失败！' + res.errMsg) } }}) // 自己获取openid和session_key // 微信提供的接口，其中appid和secret都是放在globalData中的 getOpenid: function (code) { var that = this; wx.request({ url: 'https://api.weixin.qq.com/sns/jscode2session?appid=' + that.globalData.appid + '&amp;secret=' + that.globalData.secret + '&amp;js_code=' + code + '&amp;grant_type=authorization_code', data: {}, method: 'GET', success: function (res) { var obj = {}; obj.openid = res.data.openid; obj.expires_in = Date.now() + res.data.expires_in; obj.session_key = res.data.session_key; wx.setStorageSync('openid', obj.openid);// 存储openid } }); }, 通过服务器获取openid和unionid123456789101112131415161718192021222324252627282930313233343536373839404142434445wx.login({ success: function (res) { var code = res.code; // 复制给变量就可以打印了，醉了 if (res.code) { wx.getUserInfo({ success: function (res) { // userInfo 只存储个人的基础数据 wx.setStorageSync('userInfo', res.userInfo); // 请求自己的服务器，解密用户信息 获取unionId等加密信息 wx.request({ url: url.host + '/decodeUserInfo',//自己的服务接口地址 method: 'POST', header: { 'content-type': 'application/x-www-form-urlencoded' }, data: { encryptedData: res.encryptedData, iv: res.iv, code: code, }, success: function (data) { //4.解密成功后 获取自己服务器返回的结果 if (data.data.code == 200) { console.log('解密成功'); var encryptInfo = data.data.data; wx.setStorageSync('openid', encryptInfo.openId); // 单独存储openid wx.setStorageSync('encryptInfo', encryptInfo); // 存储解密之后的数据 } else { console.log('解密失败') } } }, fail: function (res) { console.log(res); console.log('请求错误') } }) } else { console.log('获取用户登录态失败！' + res.errMsg) } }}) 最后，可以把这个方法给暴露出来，让其他界面调用123456789// 给其他界面调用，用来获取用户信息，防止没有获取成功 getUserInfo: function () { var that = this var userInfo = wx.getStorageSync('userInfo') || {}; var openid = wx.getStorageSync('openid') || null; if (!userInfo.nickName || !openid) { that.getData(); // 将wx.login({}) 方法放入其中 } } 其实获取unionid的方法主要在后台实现，需要根据微信提供的方法去解密，具体的解密文档可以参考以下内容: 微信小程序获取用户openid 与 微信小程序联盟：微信小程序之获取并解密用户数据（获取openId、unionId）","link":"/2018/04/16/%E8%8E%B7%E5%8F%96%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84openid%E4%B8%8Eunionid/"},{"title":"解决MySQL中文乱码方法","text":"MySQL会出现中文乱码的原因一般为以下几点： server本身设定问题，例如还停留在latin1 table的语系设定问题(包含character与collation) 客户端程式(例如php)的连线语系设定问题 进入MySQL 查看当前的状态 默认的是客户端和服务器都用了latin1，所以会乱码。 解决的方法就是MySQL的字符串修改为utf8. ###第一种: vim /etc/mysql/my.cnf 。**(5.5以前系统)** 在client下面加入 ‘default-character-set=utf8’ 在mysqld下面加入’default-character-set=utf8’ Notice：注意 如果修改后不能启动报错试试把’default-character-set=utf8’改为’character_set_server=utf8’，仅仅加入到mysqld下面的.client就不需要加了 ###第二种: vim /etc/mysql/my.cnf 。**(5.5以后系统)** 123456[client]default-character-set=utf8[mysqld]default-storage-engine=INNODBcharacter-set-server=utf8collation-server=utf8_general_ci 五、重启MySQL 12/etc/init.d/mysql stop /etc/init.d/mysql start","link":"/2018/01/31/%E8%A7%A3%E5%86%B3MySQL%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E6%96%B9%E6%B3%95/"},{"title":"解决Win10下WIFI无法连接到网络","text":"​ 最近在家连接WIFI，出现了【无法连接到网络】的问题。 ​ 具体表现为：在WIFI列表中，可以搜索到WIFI信号，但是连接的时候，就出现了【无法连接到网络】的报错提示。或者在连接上之后，出现了无Internet，安全字样。 解决办法： 看其余笔记本和手机是否能正常上网，可以的话，路由器没问题。 确认自己的笔记本在别的WIFI环境下能否正常上网，可以的话，WIFI驱动是没问题的。其中，把WIFI模块的电源管理给关闭掉。 在路由器的控制界面，它的工作模式是【802.11 b/g/n mixed】混合模式。将其改成n only就可以了。重启路由器就可以了。","link":"/2016/08/27/%E8%A7%A3%E5%86%B3Win10%E4%B8%8BWIFI%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E5%88%B0%E7%BD%91%E7%BB%9C/"},{"title":"解决ln -s 软链接的提示错误","text":"在使用ln -s 的时候，会提示Too many levels of symbolic links， 这个一般是由于使用的是相对路径，改成绝对路径即可： 1ln -s /etc/nginx/sites-available/default //etc/nginx/sites-enabled","link":"/2020/12/08/%E8%A7%A3%E5%86%B3ln-s-%E8%BD%AF%E9%93%BE%E6%8E%A5%E7%9A%84%E6%8F%90%E7%A4%BA%E9%94%99%E8%AF%AF/"},{"title":"解决macOS端口被占用","text":"在部署和测试hexo的时候，经常出现一下提示： Error: listen EADDRINUSE: address already in use :::4000 这是说明4000端口呗占用了，之前讲了Windows下怎么解决，这次说明下macOS下怎么解决 1sudo lsof -i:port # port为对应的端口号 之后出现如下提示： 12COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEnode 10906 username 42u IPv6 0xcd611b6cd0d363df 0t0 TCP *:terabase (LISTEN) 找到PID，然后杀掉该进程就可以 1sudo kill -9 PID #上面显示的PID","link":"/2019/12/26/%E8%A7%A3%E5%86%B3macOS%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8/"},{"title":"让 MacBook 读取 txt 文本","text":"请问如何让 MacBook 读取Windows 下的 txt 文本？很多时候，每次打开都是乱码。 这个就是一个编码转换的问题。Linux 和 MacBook 都提供了一个强大的命令行命令：iconv 步骤如下： 打开terminal，在其中输入：cd [文件所在目录] 回车之后，输入：iconv -c -f GB2312 -t UTF-8 [你要看的文件] &gt;&gt; [新文件的名称] 如上即可。 PS：需要注意的是，在上述命令中，GB2312指的是原文件的编码，UTF-8是要转换的目的文件的编码。GB2312这个是常用的中文编码，其他还有gbk等等编码，如果这个命令不行可以试试其他编码。UTF-8是MacBook能够识别的编码。","link":"/2017/05/31/%E8%AE%A9-macbook-%E8%AF%BB%E5%8F%96-txt-%E6%96%87%E6%9C%AC/"},{"title":"解决macOS声音的问题","text":"macOS系统有时会莫名其妙无法工作，在新添音频设备、唤醒或者更新操作系统后，都可能会遇到音频错误。 在调整了音量大小或者静音无法解决之后，按照如下步骤尝试，应该可以解决。 检查硬件确保系统没有静音，以及声音出问题之前没遇到磕碰之类的。 选择正确音频 插入耳机之后听不到耳机，可能是新音频设备时选择了错误的输出设备。、 System Preferences ——&gt; Sound ——&gt; Output 选择正确的输出设备，尝试切换之后再重新选择正确的输出设备。 重置音频核心1sudo killall coreaudiod 重启大法直接重启电脑，然后尝试听声音。 重置Mac上的NVRAM或PRAM这个方法是Apple官方的案例，重置Mac上的NVRAM 以上几种方法如果还是不能解决，那就判断是不是需要去售后做一个检测了。","link":"/2019/07/18/%E8%A7%A3%E5%86%B3macOS%E5%A3%B0%E9%9F%B3%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"让Chrome显示www和https","text":"新版的Chrome 77又把www和https给隐藏了，日常搞事啊，恢复显示的步骤如下 在浏览器的地址栏输入以下两个命令： chrome://flags/#omnibox-ui-hide-steady-state-url-scheme，然后选择disabled chrome://flags/#omnibox-ui-hide-steady-state-url-trivial-subdomains，然后选择disabled 重启Chrome浏览器 重新打开网站，应该就能恢复了。","link":"/2019/09/23/%E8%AE%A9Chrome%E6%98%BE%E7%A4%BAwww%E5%92%8Chttps/"},{"title":"让终端走代理","text":"在某些时候, mac OS 下的终端在现在这个环境下. GitHub 等网站动不动连不上, 需要走代理. 现在可以有三种方式: Surge Mac 2 的增强模式 Proxifier 把终端设置为走代理模式 zsh 的配置模式 1、在Surge for Mac中，点击menu栏目，选择增强模式 2、其中可以在.zshrc的配置文件中: 12345678910111213# where proxyproxy () { export http_proxy=&quot;http://127.0.0.1:8888&quot; export https_proxy=&quot;http://127.0.0.1:8888&quot; echo &quot;HTTP Proxy on&quot;}# where noproxynoproxy () { unset http_proxy unset https_proxy echo &quot;HTTP Proxy off&quot;} 使用的时候输入 proxy 打开代理模式，关闭代理时输入 noproxy 即可.","link":"/2018/08/08/%E8%AE%A9%E7%BB%88%E7%AB%AF%E8%B5%B0%E4%BB%A3%E7%90%86/"},{"title":"购买域名设置DNS","text":"博客搭建好之后就一直想买个域名，这几天在考虑域名和后缀的选择问题。后缀好说，首选.com，次选.me或.net。 域名的购买，首选Goddady。原因如下：1.在国外，不受国内各种干扰。2.国外域名商中唯一支持支付宝付款的。3.价格不高，还经常有优惠。4.信誉好，口碑好，靠谱。 域名购买完成后就要在Goddady网站里设置dns服务商了。Goddady会默认提供两个国外的，对于国内网站和国内访问来说，最好使用国内的dns服务商，这里选择口碑最好使用最多的免费dns服务商dnspod.cn。这里解释下goddady和dnspod的关系。 Goddady是域名服务商，我们需要在这里选择由哪个dns服务商为我们的网站提供域名解析服务。 设置好之后，去dnspod.cn注册账号，添加网站，设置域名到ip的映射关系.","link":"/2015/05/09/%E8%B4%AD%E4%B9%B0%E5%9F%9F%E5%90%8D%E8%AE%BE%E7%BD%AEDNS/"},{"title":"重置 MacBook 的网卡","text":"手贱用 Unifi 家的控制器来设置 AP，期间不知道是 Java 的 SDK 版本问题还是什么情况，就是突然连接 Unifi 家设置的 WIFI，但是不能上网。 连接别的设备分享出来的 WIFI 就 OK 正常。但是手机连接它家的 WIFI 就能上网。所以猜测应该是 Unifi 的那个控制器搞坏了网卡设置。 那么问题来了。MacBook Pro 如何重置网卡的设置或者恢复网络出厂设置？ 方法如下： 1234cd /Library/Preferences/SystemConfiguration/sudo mv preferences.plist preferences.plist.bak # 输入管理员密码sudo reboot PS：期间网络配置会丢失，特殊的设置需要提前备份。","link":"/2017/08/16/%E9%87%8D%E7%BD%AE-MacBook-%E7%9A%84%E7%BD%91%E5%8D%A1/"},{"title":"阿里云 VPS 开启之路之一","text":"阿里云是的香港服务器对于的国内用户来说是一个很好的低延迟的中转。以下是一些第一次启动可能需要做的事情。 \u000f卸载阿里云安骑士 下载 wget http://update.aegis.aliyun.com/download/uninstall.sh 执行下列命令： 12chmod +x uninstall.sh./uninstall.sh 卸载阿里云aliyun.service killall aliyun-service &amp;&amp; echo &quot;&quot; &gt;/usr/sbin/aliyun-service 删除阿里云登录界面欢迎信息 12vi /etc/motd#编辑/删除倒数第二行的 Welcome to Alibaba Cloud Elastic Compute Service ! 添加用户，授予 sudo权限 添加用户 adduser username 给该用户添加密码 123passwd usernameNew password:Retype new password: 授予 sudo 权限 vi /etc/sudoers 然后找到，如下添加 123## Allow root to run any commands anywhereroot ALL(ALL) = ALLusername ALL(ALL) = ALL # username 是新建的用户名 在保存的时候可能需要wq! 修改 SSH 默认端口 123456vi /etc/ssh/sshd_configPort 2000MaxAuthTries 6PermitEmptyPasswords noservice ssh restart #CentOS6systemctl restart sshd #CentOS7 禁止 root 用户登录 1234vi /etc/ssh/sshd_configPermitRootLogin noservice ssh restart #CentOS6systemctl restart sshd #CentOS7 现在就可以用新建的那个用户登录了。","link":"/2017/08/24/%E9%98%BF%E9%87%8C%E4%BA%91-VPS-%E5%BC%80%E5%90%AF%E4%B9%8B%E8%B7%AF%E4%B9%8B%E4%B8%80/"},{"title":"阿里云 VPS 开启之路之二","text":"在客户端来看，SSH提供两种级别的安全验证。 第一种级别（基于密码的安全验证），知道帐号和密码，就可以登录到远程主机，并且所有传输的数据都会被加密。 第二种级别（基于密钥的安全验证），需要依靠密钥，也就是你必须为自己创建一对密钥，并把公有密钥放在需要访问的服务器上。 这里要讨论的ssh密钥认证自动登录正是基于第二种级别的安全验证方式。 本地创建公钥 打开终端运行如下命令： 1ssh-keygen -t rsa -f filename -C 'your email@domain.com' 在 VPS 对应用户目录下新建对应目录 12345mkdir ~/.sshchmod 700 ~/.sshcd .sshtouch authorized_keyschmod 600 authorized_keys 把生成的公钥复制到VPS 服务，并且合并到authorized_keys 12scp -P port ~/.ssh/*.pub username@hostname:/home/name/.ssh/cat *.pub authorized_keys 快捷登录 修改 config 1vi ~/.ssh/config #没有就新建 添加如下配置文件 12345Host vps HostName hostname IdentityFile ~/.ssh/cert Port port User username 保存即可登录 ssh vps即可自动登录 如果你本地终端使用的是zsh，给 zsh添加别名 123echo &quot;alias ssh-to-username='ssh username@hostname'&quot; &gt;&gt; ~/.zshrc #将username和hostname替换为你的服务器信息source ~/.zshrc #重新加载更改后的zshrc文件ssh-to-username #使用别名，一条命令即可登录你的ssh服务器 ​ 最后关闭密码登录 1vi /etc/ssh/sshd_config 修改如下内容 12345#PasswordAuthentication yes##修改为如下内容：PasswordAuthentication no##使用命令重启ssh服务：systemctl restart sshd ​","link":"/2017/08/24/%E9%98%BF%E9%87%8C%E4%BA%91-VPS-%E5%BC%80%E5%90%AF%E4%B9%8B%E8%B7%AF%E4%B9%8B%E4%BA%8C/"},{"title":"面向对象的文件系统路径-pathlib","text":"该模块提供表示文件系统路径的类，其语义适用于不同的操作系统。 pathlib类在纯路径之间划分，纯路径提供纯粹的计算操作而没有I / O，以及具体路径，它继承纯路径但也提供I / O操作。 如果你之前从未使用过此模块，或者只是不确定哪个类适合你的任务，那么Path很可能就是你所需要的。 为运行代码的平台提供了实例化的具体路径。 纯路径在某些特殊情况下很有用; 例如： 如果要在Unix计算机上操作Windows路径（反之亦然）。 在Unix上运行时无法实例化WindowsPath，但可以实例化PureWindowsPath。 你希望确保你的代码仅操作路径而不实际访问操作系统。 在这种情况下，实例化其中一个纯类可能很有用，因为那些只是没有任何操作系统访问操作。 基础使用导入主类: 1&gt;&gt;&gt; from pathlib import Path 列出子目录 1234&gt;&gt;&gt; p = Path('.')&gt;&gt;&gt; [x for x in p.iterdir() if x.is_dir()][PosixPath('.hg'), PosixPath('docs'), PosixPath('dist'), PosixPath('__pycache__'), PosixPath('build')] 在此目录树中列出Python源文件 123&gt;&gt;&gt; list(p.glob('**/*.py'))[PosixPath('test_pathlib.py'), PosixPath('setup.py'), PosixPath('pathlib.py'), PosixPath('docs/conf.py'),PosixPath('build/lib/pathlib.py')] 在根目录插入目录树 123456&gt;&gt;&gt; p = Path('/etc')&gt;&gt;&gt; q = p / 'init.d' / 'reboot'&gt;&gt;&gt; qPosixPath('/etc/init.d/reboot')&gt;&gt;&gt; q.resolve()PosixPath('/etc/rc.d/init.d/halt') 查询目录属性 1234&gt;&gt;&gt; q.exists()True&gt;&gt;&gt; q.is_dir()False 打开一个文件 123&gt;&gt;&gt; with q.open() as f: f.readline()...'#!/bin/bash\\n' Pure pathsPure path 对象提供了实际上不访问文件系统的路径处理操作。 有三种方法可以访问这些类，我们也称之为flavours： class pathlib.PurePath(*pathsegments)表示系统路径风格的泛型类（实例化它会创建PurePosixPath或PureWindowsPath） 12&gt;&gt;&gt; PurePath('setup.py') # Running on a Unix machinePurePosixPath('setup.py') 每个路径元素可以是一个表示路径段的字符串，一个实现操作系统的对象。返回字符串或其他路径对象的PathLike接口： 1234&gt;&gt;&gt; PurePath('foo', 'some/path', 'bar')PurePosixPath('foo/some/path/bar')&gt;&gt;&gt; PurePath(Path('foo'), Path('bar'))PurePosixPath('foo/bar') 当路径记录为空, 则默认当前目录 12&gt;&gt;&gt; PurePath()PurePosixPath('.') 当给出几个绝对路径时，最后一个被选为一个锚（模仿os.path.join()的行为) 1234&gt;&gt;&gt; PurePath('/etc', '/usr', 'lib64')PurePosixPath('/usr/lib64')&gt;&gt;&gt; PureWindowsPath('c:/Windows', 'd:bar')PureWindowsPath('d:bar') 但是，在Windows路径中，更改本地根目录并不丢弃以前的驱动器设置 12&gt;&gt;&gt; PureWindowsPath('c:/Windows', '/Program Files')PureWindowsPath('c:/Program Files') 双斜线和单点会折叠，但双点（’..’）则不会，因为这将在符号链接面前改变一条路径的含义： 123456&gt;&gt;&gt; PurePath('foo//bar')PurePosixPath('foo/bar')&gt;&gt;&gt; PurePath('foo/./bar')PurePosixPath('foo/bar')&gt;&gt;&gt; PurePath('foo/../bar')PurePosixPath('foo/../bar') （naïve方法将使PurePosixPath（’foo/../bar’）等同于PurePosixPath（’bar’），如果foo是指向另一个目录的符号链接，则该方法是错误的) Pure path对象是实现os.PathLike接口，允许在接受接口的任何地方使用它们 版本3.6中已更改：添加了对os.PathLike接口的支持。 class pathlib.PurePosix\bPath(*pathsegments)作为PurePath的子类，此路径样式表示非Windows文件系统路径 12 &gt;&gt;&gt; PurePosixPath('/etc')PurePosixPath('/etc') 路径指定类似于PurePath class pathlib.PureWindowsPath(*pathsegments)作为PurePath的子类，此路径样式表示Windows文件系统路径 12&gt;&gt;&gt; PureWindowsPath('c:/Program Files/')PureWindowsPath('c:/Program Files') 路径指定类似于PurePath 无论运行的是哪个系统，都可以实例化所有这些类，因为它们不提供任何进行系统调用的操作 一般的属性路径是不可变的和可散列的。同一种风格的路径是可比较和可排序的。这些属性尊重风格的大小写和语义： 12345678&gt;&gt;&gt; PurePosixPath('foo') == PurePosixPath('FOO')False&gt;&gt;&gt; PureWindowsPath('foo') == PureWindowsPath('FOO')True&gt;&gt;&gt; PureWindowsPath('FOO') in { PureWindowsPath('foo') }True&gt;&gt;&gt; PureWindowsPath('C:') &lt; PureWindowsPath('d:')True 不同风格的路径不能比较，不能排序 123456&gt;&gt;&gt; PureWindowsPath('foo') == PurePosixPath('foo')False&gt;&gt;&gt; PureWindowsPath('foo') &lt; PurePosixPath('foo')Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: '&lt;' not supported between instances of 'PureWindowsPath' and 'PurePosixPath' 操作斜杠操作符帮助创建子路径, 类似os.path.join() 12345678&gt;&gt;&gt; p = PurePath('/etc')&gt;&gt;&gt; pPurePosixPath('/etc')&gt;&gt;&gt; p / 'init.d' / 'apache2'PurePosixPath('/etc/init.d/apache2')&gt;&gt;&gt; q = PurePath('bin')&gt;&gt;&gt; '/usr' / qPurePosixPath('/usr/bin') 路径对象可以用任何os.PathLike可接受的接口的地方 1234&gt;&gt;&gt; import os&gt;&gt;&gt; p = PurePath('/etc')&gt;&gt;&gt; os.fspath(p)'/etc' 路径的字符串表示形式是原始文件系统路径本身（以本机形式，例如Windows下的反斜杠），你可以将它传递给任何将文件路径作为字符串的函数 123456&gt;&gt;&gt; p = PurePath('/etc')&gt;&gt;&gt; str(p)'/etc'&gt;&gt;&gt; p = PureWindowsPath('c:/Program Files')&gt;&gt;&gt; str(p)'c:\\\\Program Files' 类似地，在路径上调用字节会将原始文件系统路径作为字节对象提供，如os.fsencode()所编码的那样 12&gt;&gt;&gt; bytes(p)b'/etc' 注意:只建议在Unix下调用字节。在Windows下，unicode表单是文件系统路径的规范化表示形式。 对组件的访问若要访问路径的各个“部件”（组件），请使用以下属性 PurePath.parts一个元组，用于访问路径的各个组件 1234567&gt;&gt;&gt; p = PurePath('/usr/bin/python3')&gt;&gt;&gt; p.parts('/', 'usr', 'bin', 'python3')&gt;&gt;&gt; p = PureWindowsPath('c:/Program Files/PSF')&gt;&gt;&gt; p.parts('c:\\\\', 'Program Files', 'PSF') （注意驱动器和本地根目录是如何在单个部件中重新分组的） UNC 分享也被认为是驱动 12&gt;&gt;&gt; PureWindowsPath('//host/share/foo.txt').drive'\\\\\\\\host\\\\share' PurePath.root一个字符串，表示（本地或全局）根目录（如果有的话） 123456&gt;&gt;&gt; PureWindowsPath('c:/Program Files/').root'\\\\'&gt;&gt;&gt; PureWindowsPath('c:Program Files/').root''&gt;&gt;&gt; PurePosixPath('/etc').root'/' NUC 分享也总有一个根目录 12&gt;&gt;&gt; PureWindowsPath('//host/share').root'\\\\' PurePath.anchor驱动和根目录的连接 12345678&gt;&gt;&gt; PureWindowsPath('c:/Program Files/').anchor'c:\\\\'&gt;&gt;&gt; PureWindowsPath('c:Program Files/').anchor'c:'&gt;&gt;&gt; PurePosixPath('/etc').anchor'/'&gt;&gt;&gt; PureWindowsPath('//host/share').anchor'\\\\\\\\host\\\\share\\\\' PurePath.parents一个不可变序列提供对路径逻辑父级目录的访问 1234567&gt;&gt;&gt; p = PureWindowsPath('c:/foo/bar/setup.py')&gt;&gt;&gt; p.parents[0]PureWindowsPath('c:/foo/bar')&gt;&gt;&gt; p.parents[1]PureWindowsPath('c:/foo')&gt;&gt;&gt; p.parents[2]PureWindowsPath('c:/') PurePath.parent父级目录 123&gt;&gt;&gt; p = PurePosixPath('/a/b/c/d')&gt;&gt;&gt; p.parentPurePosixPath('/a/b/c') 你不能通过锚定或者一个空目录 123456&gt;&gt;&gt; p = PurePosixPath('/')&gt;&gt;&gt; p.parentPurePosixPath('/')&gt;&gt;&gt; p = PurePosixPath('.')&gt;&gt;&gt; p.parentPurePosixPath('.') PurePath.name一个字符串表示最终路径目录（如果有的话），不包括驱动器和根目录 12&gt;&gt;&gt; PurePosixPath('my/library/setup.py').name'setup.py' 不考虑UNC驱动器名 1234&gt;&gt;&gt; PureWindowsPath('//some/share/setup.py').name'setup.py'&gt;&gt;&gt; PureWindowsPath('//some/share').name'' PurePath.suffix最终的文件扩展名(如果有的话) 123456&gt;&gt;&gt; PurePosixPath('my/library/setup.py').suffix'.py'&gt;&gt;&gt; PurePosixPath('my/library.tar.gz').suffix'.gz'&gt;&gt;&gt; PurePosixPath('my/library').suffix'' PurePath.suffixes路径的扩展名的列表 123456&gt;&gt;&gt; PurePosixPath('my/library.tar.gar').suffixes['.tar', '.gar']&gt;&gt;&gt; PurePosixPath('my/library.tar.gz').suffixes['.tar', '.gz']&gt;&gt;&gt; PurePosixPath('my/library').suffixes[] PurePath.stem最终路径的零件, 没有扩展名 123456&gt;&gt;&gt; PurePosixPath('my/library.tar.gz').stem'library.tar'&gt;&gt;&gt; PurePosixPath('my/library.tar').stem'library'&gt;&gt;&gt; PurePosixPath('my/library').stem'library' PurePath.as_posix()返回带有斜杠的路径的字符串表示形式（/） 12345&gt;&gt;&gt; p = PureWindowsPath('c:\\\\windows')&gt;&gt;&gt; str(p)'c:\\\\windows'&gt;&gt;&gt; p.as_posix()'c:/windows' PurePath.as_uri()将路径表示为一个文件URI。如果路径不是绝对的，则引发ValueError。 123456&gt;&gt;&gt; p = PurePosixPath('/etc/passwd')&gt;&gt;&gt; p.as_uri()'file:///etc/passwd'&gt;&gt;&gt; p = PureWindowsPath('c:/Windows')&gt;&gt;&gt; p.as_uri()'file:///c:/Windows' PurePath.is_absolute()无论路径是否绝对，都返回。如果路径同时具有根和（如果允许）驱动器，则认为它是绝对路径： 12345678910111213&gt;&gt;&gt; PurePosixPath('/a/b').is_absolute()True&gt;&gt;&gt; PurePosixPath('a/b').is_absolute()False&gt;&gt;&gt; PureWindowsPath('c:/a/b').is_absolute()True&gt;&gt;&gt; PureWindowsPath('/a/b').is_absolute()False&gt;&gt;&gt; PureWindowsPath('c:').is_absolute()False&gt;&gt;&gt; PureWindowsPath('//some/share').is_absolute()True PurePath.is_reserved()对于PureWindowsPath，如果路径被认为是在Windows下保留的，则返回True，否则返回False 使用PurePosixPath时，False总是返回。 1234&gt;&gt;&gt; PureWindowsPath('nul').is_reserved()True&gt;&gt;&gt; PurePosixPath('nul').is_reserved()False 保留路径上的文件系统调用可能会神秘地失败或产生意外的结果。 PurePath.joinpath(*other)调用此方法相当于依次将路径与其他参数组合在一起。 12345678&gt;&gt;&gt; PurePosixPath('/etc').joinpath('passwd')PurePosixPath('/etc/passwd')&gt;&gt;&gt; PurePosixPath('/etc').joinpath(PurePosixPath('passwd'))PurePosixPath('/etc/passwd')&gt;&gt;&gt; PurePosixPath('/etc').joinpath('init.d', 'apache2')PurePosixPath('/etc/init.d/apache2')&gt;&gt;&gt; PureWindowsPath('c:').joinpath('/Program Files')PureWindowsPath('c:/Program Files') PurePath.match(pattern)将此路径与提供的全局样式模式匹配。如果匹配成功，则返回真。否则为假。 如果模式是相对的，路径可以是相对的，也可以是绝对的，匹配可以从右边进行。 123456&gt;&gt;&gt; PurePath('a/b.py').match('*.py')True&gt;&gt;&gt; PurePath('/a/b/c.py').match('b/*.py')True&gt;&gt;&gt; PurePath('/a/b/c.py').match('a/*.py')False 如果模式是绝对的，那么路径必须是绝对的，并且整个路径必须匹配： 1234&gt;&gt;&gt; PurePath('/a.py').match('/*.py')True&gt;&gt;&gt; PurePath('a/b.py').match('/*.py')False 和其他方法一样，个案敏感性是观察到的，例如： 12&gt;&gt;&gt; PureWindowsPath('b.py').match('*.PY')True PurePath.relative_to(*other)对象所表示的路径相对于此路径的版本。如果不可能，则引发ValueError： 1234567891011&gt;&gt;&gt; p = PurePosixPath('/etc/passwd')&gt;&gt;&gt; p.relative_to('/')PurePosixPath('etc/passwd')&gt;&gt;&gt; p.relative_to('/etc')PurePosixPath('passwd')&gt;&gt;&gt; p.relative_to('/usr')Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; File &quot;pathlib.py&quot;, line 694, in relative_to .format(str(self), str(formatted)))ValueError: '/etc/passwd' does not start with '/usr' PurePath.with_name(name)返回一个已更改名称的新路径。如果原始路径没有名称，则引发ValueError。 12345678910&gt;&gt;&gt; p = PureWindowsPath('c:/Downloads/pathlib.tar.gz')&gt;&gt;&gt; p.with_name('setup.py')PureWindowsPath('c:/Downloads/setup.py')&gt;&gt;&gt; p = PureWindowsPath('c:/')&gt;&gt;&gt; p.with_name('setup.py')Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; File &quot;/home/antoine/cpython/default/Lib/pathlib.py&quot;, line 751, in with_name raise ValueError(&quot;%r has an empty name&quot; % (self,))ValueError: PureWindowsPath('c:/') has an empty name PurePath.with_suffix(suffix)返回一个新路径，其中后缀已更改。如果原始路径没有后缀，则会追加新的后缀。 123456&gt;&gt;&gt; p = PureWindowsPath('c:/Downloads/pathlib.tar.gz')&gt;&gt;&gt; p.with_suffix('.bz2')PureWindowsPath('c:/Downloads/pathlib.tar.bz2')&gt;&gt;&gt; p = PureWindowsPath('README')&gt;&gt;&gt; p.with_suffix('.txt')PureWindowsPath('README.txt') Concrete paths具体路径是纯路径类的子类。除了后者提供的操作之外，它们还提供对路径对象执行系统调用的方法。有三种方法可以实例化具体路径： class pathlib.Path(*pathsegments)这个类是PurePath的一个子类，表示系统路径味道的具体路径（实例化它可以创建PosixPath或WindowsPath）： 12&gt;&gt;&gt; Path('setup.py')PosixPath('setup.py') 路径指定类似于PurePath。 class pathlib.PosixPath(*pathsegments)Path和PurePosixPath的一个子类，这个类表示具体的非Windows文件系统路径： 12&gt;&gt;&gt; PosixPath('/etc')PosixPath('/etc') 路径指定类似于PurePath。 class pathlib.WindowsPath(*pathsegments)这个类是Path和PureWindowsPath的子类，它表示具体的Windows文件系统路径： 12&gt;&gt;&gt; WindowsPath('c:/Program Files/')WindowsPath('c:/Program Files') 路径指定类似于PurePath。 你只能实例化与你的系统对应的类风格（允许系统调用不兼容的路径，可能会导致应用程序中的错误或故障）： 12345678910111213&gt;&gt;&gt; import os&gt;&gt;&gt; os.name'posix'&gt;&gt;&gt; Path('setup.py')PosixPath('setup.py')&gt;&gt;&gt; PosixPath('setup.py')PosixPath('setup.py')&gt;&gt;&gt; WindowsPath('setup.py')Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; File &quot;pathlib.py&quot;, line 798, in __new__ % (cls.__name__,))NotImplementedError: cannot instantiate 'WindowsPath' on your system 方法除了纯路径方法外，具体路径还提供以下方法。如果系统调用失败（例如，路径不存在），这些方法中的许多都会引发OSError。 classmethod* Path.cwd()返回一个表示当前目录的新路径对象（由os.getcwd()返回）： 12&gt;&gt;&gt; Path.cwd()PosixPath('/home/antoine/pathlib') classmethod Path.hom()返回一个新的路径对象，该对象表示用户的主目录（由os.path.expanduser（）返回，带有~结构）： 12&gt;&gt;&gt; Path.home()PosixPath('/home/antoine') New in version 3.5. Path.stat()返回关于此路径的信息（类似于os.stat（））。结果在每次调用这个方法时都会被查询出来。 12345&gt;&gt;&gt; p = Path('setup.py')&gt;&gt;&gt; p.stat().st_size956&gt;&gt;&gt; p.stat().st_mtime1327883547.852554 Path.chmod(mode)更改文件模式和权限，如os.chmod()： 123456&gt;&gt;&gt; p = Path('setup.py')&gt;&gt;&gt; p.stat().st_mode33277&gt;&gt;&gt; p.chmod(0o444)&gt;&gt;&gt; p.stat().st_mode33060 Path.exists()该路径是否指向现有的文件或目录： 12345678&gt;&gt;&gt; Path('.').exists()True&gt;&gt;&gt; Path('setup.py').exists()True&gt;&gt;&gt; Path('/etc').exists()True&gt;&gt;&gt; Path('nonexistentfile').exists()False 注意：如果路径指向符号链接，则存在（）返回符号链接指向的是现有的文件还是目录。 Path.expanduser()返回一个新路径，其中包含展开的和user构造，由os.path.expanduser()返回： 123&gt;&gt;&gt; p = PosixPath('~/films/Monty Python')&gt;&gt;&gt; p.expanduser()PosixPath('/home/eric/films/Monty Python') Path.glob(pattern)将此路径所表示的目录中的给定模式全局化，生成所有匹配的文件（任何类型的）： 1234&gt;&gt;&gt; sorted(Path('.').glob('*.py'))[PosixPath('pathlib.py'), PosixPath('setup.py'), PosixPath('test_pathlib.py')]&gt;&gt;&gt; sorted(Path('.').glob('*/*.py'))[PosixPath('docs/conf.py')] “**”模式意味着“此目录和所有子目录，递归地”。换句话说，它支持递归全局化： 123456&gt;&gt;&gt; sorted(Path('.').glob('**/*.py'))[PosixPath('build/lib/pathlib.py'), PosixPath('docs/conf.py'), PosixPath('pathlib.py'), PosixPath('setup.py'), PosixPath('test_pathlib.py')] 注意：在大型目录树中使用“**”模式可能消耗大量的时间。 Path.group()返回拥有该文件的组的名称。如果文件的gid在系统数据库中没有找到，则会引发KeyError。 Path.is_dir()返回True如果路径指向一个目录（或指向一个目录的符号链接），则False指向另一种文件。如果路径不存在或符号链接已损坏，也会返回False；其他错误（如权限错误）也会被传播。 Path.is_file()返回真如果路径指向常规文件（或指向常规文件的符号链接），则Falseif指向另一种文件。如果路径不存在或符号链接已损坏，也会返回False；其他错误（如权限错误）也会被传播。 Path.is_mount()如果路径是一个挂载点，返回True：文件系统中已挂载不同文件系统的点。在POSIX上，函数检查路径的父路径/..，是否在与路径不同的设备上，或者路径/..，路径指向同一设备上的同一个i节点 —这应该可以检测所有Unix和POSIX变体的挂载点。没有在Windows上实现。","link":"/2018/09/11/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%B7%AF%E5%BE%84-pathlib/"}],"tags":[{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Debian","slug":"Debian","link":"/tags/Debian/"},{"name":"CentOS 7","slug":"CentOS-7","link":"/tags/CentOS-7/"},{"name":"HTTP","slug":"HTTP","link":"/tags/HTTP/"},{"name":"tar","slug":"tar","link":"/tags/tar/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"list","slug":"list","link":"/tags/list/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"格式化时间","slug":"格式化时间","link":"/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%B6%E9%97%B4/"},{"name":"CSV","slug":"CSV","link":"/tags/CSV/"},{"name":"XML","slug":"XML","link":"/tags/XML/"},{"name":"Hash","slug":"Hash","link":"/tags/Hash/"},{"name":"xml","slug":"xml","link":"/tags/xml/"},{"name":"SSH","slug":"SSH","link":"/tags/SSH/"},{"name":"Ubuntu18","slug":"Ubuntu18","link":"/tags/Ubuntu18/"},{"name":"windows","slug":"windows","link":"/tags/windows/"},{"name":"iTunes","slug":"iTunes","link":"/tags/iTunes/"},{"name":"macOS","slug":"macOS","link":"/tags/macOS/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"webp","slug":"webp","link":"/tags/webp/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"python, linux","slug":"python-linux","link":"/tags/python-linux/"},{"name":"叉号","slug":"叉号","link":"/tags/%E5%8F%89%E5%8F%B7/"},{"name":"Xposed","slug":"Xposed","link":"/tags/Xposed/"},{"name":"ufw","slug":"ufw","link":"/tags/ufw/"},{"name":"Google Play","slug":"Google-Play","link":"/tags/Google-Play/"},{"name":"IPV4","slug":"IPV4","link":"/tags/IPV4/"},{"name":"zsh","slug":"zsh","link":"/tags/zsh/"},{"name":"brew","slug":"brew","link":"/tags/brew/"},{"name":"小米 6","slug":"小米-6","link":"/tags/%E5%B0%8F%E7%B1%B3-6/"},{"name":"Chrome","slug":"Chrome","link":"/tags/Chrome/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"terminal","slug":"terminal","link":"/tags/terminal/"},{"name":"端口","slug":"端口","link":"/tags/%E7%AB%AF%E5%8F%A3/"},{"name":"Apple","slug":"Apple","link":"/tags/Apple/"},{"name":"网卡","slug":"网卡","link":"/tags/%E7%BD%91%E5%8D%A1/"},{"name":"path","slug":"path","link":"/tags/path/"}],"categories":[{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"Study Class","slug":"Study-Class","link":"/categories/Study-Class/"},{"name":"Google","slug":"Google","link":"/categories/Google/"},{"name":"Android Studio","slug":"Android-Studio","link":"/categories/Android-Studio/"},{"name":"Life","slug":"Life","link":"/categories/Life/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"GIT","slug":"GIT","link":"/categories/GIT/"},{"name":"HTTP","slug":"HTTP","link":"/categories/HTTP/"},{"name":"hexo教程","slug":"hexo教程","link":"/categories/hexo%E6%95%99%E7%A8%8B/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"Github","slug":"Github","link":"/categories/Github/"},{"name":"Soft","slug":"Soft","link":"/categories/Soft/"},{"name":"Tools","slug":"Tools","link":"/categories/Tools/"},{"name":"Windows","slug":"Windows","link":"/categories/Windows/"},{"name":"Xposed","slug":"Xposed","link":"/categories/Xposed/"},{"name":"Apple","slug":"Apple","link":"/categories/Apple/"},{"name":"macOS","slug":"macOS","link":"/categories/macOS/"},{"name":"SQL","slug":"SQL","link":"/categories/SQL/"},{"name":"Regex","slug":"Regex","link":"/categories/Regex/"},{"name":"WeiXin","slug":"WeiXin","link":"/categories/WeiXin/"}]}